<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「CS229」Lecture6：拉普拉斯平滑和SVM简介</title>
      <link href="/2023/07/06/ml/cs229-lecture6/"/>
      <url>/2023/07/06/ml/cs229-lecture6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="拉普拉斯平滑">拉普拉斯平滑</h2><h3 id="问题引入">问题引入</h3><p>在上一节中，我们使用朴素贝叶斯来解决垃圾邮件分类问题。我们设 <span class="math inline">\(x\)</span> 表示邮件内容特征，<span class="math inline">\(x\)</span>的每一个分量（取值0或1）表示词典中对应位置的单词是否出现，<span class="math inline">\(y\)</span> 表示该邮件是否为垃圾邮件。我们假设<span class="math inline">\(P(x \mid y )\)</span> 和 <span class="math inline">\(P(y)\)</span> 都遵循伯努利分布，因此参数有</p><ul><li><span class="math inline">\(\phi_{j \mid y = 1} = P(x_j = 1 \mid y =1)\)</span></li><li><span class="math inline">\(\phi_{j \mid y = 0} = P(x_j = 1 \mid y =0)\)</span></li><li><span class="math inline">\(\phi_y = p(y = 1)\)</span></li></ul>通过极大似然估计，可以得到这三个参数的最优值<br>$$<br><span class="math display">\[\begin{aligned}&amp;\phi_y \ \ \ \ \ \ = \frac{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)}= 1)}{m} \\&amp; \phi_{j \mid y = 1} = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 1)}{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 1)} \\&amp; \phi_{j \mid y = 0} = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 0)}{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 0)} \\\end{aligned}\]</span><p>$$</p><p>尽管这些值都是通过计算得到的，但其实一打眼看上去也很好理解。以<span class="math inline">\(\phi_{j \mid y=1}\)</span>为例，其最优值计算公式的分母 <span class="math inline">\(\sum\limits_{i=1}^m \mathcal{I}(y^{(i)} =1)\)</span> 表示“训练数据集中垃圾邮件的数目”，<span class="math inline">\(\sum\limits_{i=1}^m \mathcal{I}(x_j^{(i)} = 1,y^{(i)} = 1)\)</span> 表示“包含词典中第 j个单词的垃圾邮件的数量”。得这些参数的最优值，也就得到了<span class="math inline">\(P(x|y)\)</span> 和 <span class="math inline">\(P(x)\)</span>。因此当我们预测时，就可以套用下面的公式<br><span class="math display">\[\begin{aligned}P(y=1\mid x) &amp;= \frac{P(x\mid y=1) P(y=1)}{P(x\mid y=1) P(y=1) +P(x\mid y=0) P(y=0)} \\&amp;= \frac{\prod\limits_{j=1}^{n} P(x_j\mid y=1)P(y=1)}{P(\prod\limits_{j=1}^{n}x_j\mid y=1) P(y=1)+\prod\limits_{j=1}^{n} P(x_j \mid y=0) P(y=0)}\end{aligned}\]</span><br>我们考虑这样一个情况——假设词典中第 k个单词在训练集所有邮件里都没有出现过，即<span class="math inline">\(P(x_k = 1 | y=1) = P(x_k \mid y = 0) =0\)</span>。假设预测时出现一封包含该单词的邮件，此时我们计算 <span class="math inline">\(P(y = 1 \mid x)\)</span> 会得到<br><span class="math display">\[P(y=1|0) = \frac{0}{0 + 0}\]</span><br>显然，我们得不到一个有意义的概率值。那么问题的根源在哪里呢?</p><h3 id="根源剖析">根源剖析</h3><p>通过观察我们可以发现，<span class="math inline">\(P(x_k = 1 | y=1) =P(x_k \mid y = 0) = 0\)</span>是有问题的。根据概率论的知识我们知道，“某个事件的概率为 0 ” 表示“该永远不会发生”。<span class="math inline">\(P(x_k = 1 | y=1)\)</span>，也就是<span class="math inline">\(\phi_{k |y=0}\)</span>，是我们完全根据训练集的数据计算得到的。我们不能奢求训练集可以涵盖所有的情况，因此不能保证垃圾邮件中永远不可能出现<span class="math inline">\(x_k\)</span> 对应的单词。所以， <span class="math inline">\(P(x_k = 1\mid y=1)\)</span> 不能是 <span class="math inline">\(0\)</span>，而是应该是一个比较小的非负值。</p><p>为了达到这个目的，我们需要在计算 <span class="math inline">\(\phi_{j\mid y=1}\)</span> 的时候做一些“手脚“——也就是使用拉普拉斯平滑（LaplaceSmoothing）。</p><h3 id="问题解决">问题解决</h3><p>绕了这么大一圈，终于引出拉普拉斯平滑。但是别急，我们需要先看一个拉普拉斯平滑的简单案例。假设有一个足球队A，该球队先前和B、C、D、E、F五个队伍都打过比赛，数据如下</p><table><thead><tr class="header"><th style="text-align: center;">对手</th><th style="text-align: center;">结果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">B</td><td style="text-align: center;">输</td></tr><tr class="even"><td style="text-align: center;">C</td><td style="text-align: center;">输</td></tr><tr class="odd"><td style="text-align: center;">D</td><td style="text-align: center;">输</td></tr><tr class="even"><td style="text-align: center;">E</td><td style="text-align: center;">输</td></tr><tr class="odd"><td style="text-align: center;">F</td><td style="text-align: center;">输</td></tr></tbody></table><p>下周A队要和G队打比赛，A队胜利的概率有多大？很显然，我们可以根据历史数据对A的胜率进行预测，即<br><span class="math display">\[P(A队打赢G队) = \frac{A队赢的次数}{A队赢的次数+A队输的次数} = \frac{0}{0+ 5} = 0\]</span><br>这里出现了和刚才一样的问题 ——只通过历史数据不能完全推断未来的数据，因此不能100%断定A队一定输（万一人家奋发图强了呢）。为了解决该问题，拉普拉斯平滑的做法是：将A队赢的次数增加1，A队输的次数也增加1，这样计算出来的概率就不是0了，即<br><span class="math display">\[P(A队打赢G队) = \frac{A队赢的次数 + 1}{A队赢的次数 + 1+A队输的次数 + 1}= \frac{1}{7}\]</span><br>将该思想运用在垃圾邮件分类问题中 <span class="math inline">\(\phi_{j\midy=1}\)</span> 和 <span class="math inline">\(\phi_{j\mid y=0}\)</span>的计算上，有<br><span class="math display">\[\begin{aligned}\phi_{j \mid y = 1} &amp;= \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 1) + 1 }{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 1) + 2 } \\\phi_{j \mid y = 0} &amp;= \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 0) + 1 }{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 0) + 2 }\end{aligned}\]</span></p><h3 id="泛化">泛化</h3><p>更一般的，假设特征 <span class="math inline">\(x\)</span>有多个分量，并且每个分量取值有k个——即<span class="math inline">\(x \in\{1, 2, \dots, k\}\)</span> 。根据朴素贝叶斯的思想，<span class="math inline">\(P(x \mid y)\)</span>的计算公式为——<br><span class="math display">\[P(x \mid y) = \prod_{j=1}^n P(x_j \mid y)\]</span><br>我们可以根据历史数据预测 <span class="math inline">\(P(x_j = x* \mid y =y*)\)</span> 的值，有<br><span class="math display">\[P(x_j = x^*\mid y = y^*) = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = x^* \mid y = y^*)}{\sum\limits_{i=1}^m\mathcal{I}(y=y^*)}\]</span><br>应用拉普拉斯平滑，我们可以改写<span class="math inline">\(P(x_j = k \midy = y*)\)</span> 的计算公式，即<br><span class="math display">\[P(x_j = x^*\mid y = y^*) = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = x^* \mid y = y^*) + 1}{\sum\limits_{i=1}^m\mathcal{I}(y=y^*) + k}\]</span></p><h2 id="两种事件模型">两种事件模型</h2><h3 id="多元伯努利事件模型">多元伯努利事件模型</h3><p>对于以前提到的“垃圾邮件分类任务”，我们用 <span class="math inline">\(x\)</span> 表示邮件内容特征，<span class="math inline">\(x\)</span>​的每一个分量（取值0或1）表示词典中对应位置的单词是否出现。假设词典为 [a,English， I， like，zoo]，维度为5。有一封邮件的内容为“I likeEnglist”，则对应的 <span class="math inline">\(x\)</span> 就是<br><span class="math display">\[x = \begin{bmatrix}0 &amp;1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}^T\]</span><br>这种模型我们称作“多元伯努利事件模型”。在该模型中，<span class="math inline">\(x\)</span> 的维度为词典的规模，即<span class="math inline">\(x \in \{0,1\}^{\#dict}\)</span>。该模型的缺点也很明显，就是我们只知道某个单词是否存在，无法得知该单词的具体数量，另外单词的位置我们也无法得知。</p><h3 id="多项事件模型">多项事件模型</h3><p>为了解决上述的问题，我们换用另一种<span class="math inline">\(x\)</span> 的表示方法。假设词典是这样的</p><table><thead><tr class="header"><th style="text-align: center;">Index</th><th style="text-align: center;">Word</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td style="text-align: center;">56</td><td style="text-align: center;">English</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td style="text-align: center;">129</td><td style="text-align: center;">I</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td style="text-align: center;">234</td><td style="text-align: center;">like</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td><td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td></tr></tbody></table><p>那么对应的<span class="math inline">\(x\)</span> 可以写作<br><span class="math display">\[x = \begin{bmatrix}56 &amp; 129 &amp; 234\end{bmatrix}^T\]</span><br>很容易可以看出，<span class="math inline">\(x\)</span>维度为“邮件的长度”，<span class="math inline">\(x\)</span>的每一个分量表示“邮件对应位置的单词在词典中的下标”。我们把这种模型称作"多项事件模型"。该模型中<span class="math inline">\(P(y \mid x)\)</span>的计算公式如下所示（其中n表示邮件长度）<br><span class="math display">\[\begin{aligned}P(y \mid x) &amp;= \frac{P(x \mid y) P(y)}{P(x)}\\&amp;=\frac{\prod\limits_{j=1}^{n}P(x_j \mid y) P(y)}{P(x)}\end{aligned}\]</span><br>其实本质上需要对 $P(x_j y) $ 和 <span class="math inline">\(P(y)\)</span>进行预测。假设这两个概率都遵循伯努利分布，则可以设置以下参数</p><ul><li><span class="math inline">\(\phi_y = P(y=1)\)</span></li><li><span class="math inline">\(\phi_{k \mid y=0} = P(x_j = k \midy=0)\)</span></li><li><span class="math inline">\(\phi_{k \mid y=1} = P(x_j = k \midy=1)\)</span></li></ul><p>可以发现，我们已经做出了如下假设——邮件中每个位置出现单词 <span class="math inline">\(k\)</span>的概率都是相同的。我们极大化联合似然概率 <span class="math inline">\(P(x, y) = P(x \mid y) P(y)\)</span>，可以得到参数的估计值<br><span class="math display">\[\begin{aligned}\phi_y &amp;= \frac{\sum\limits_{i=1}^n \mathcal{I}(y^{(i)}=1)}{m} \\\phi_{k \mid y=0}&amp; = \frac{\sum\limits_{i=1}^n(\mathcal{I}(y^{(i)}=0)\sum\limits_{j=1}^{m}\mathcal{I}(x_j^{(i)})=k)}{\sum\limits_{i=1}^n\mathcal{I}(y^{(i)}=0)\cdot n_i} \\\phi_{k \mid y=1}&amp; = \frac{\sum\limits_{i=1}^n(\mathcal{I}(y^{(i)}=1)\sum\limits_{j=1}^{m}\mathcal{I}(x_j^{(i)})=k)}{\sum\limits_{i=1}^n\mathcal{I}(y^{(i)}=1)\cdot n_i}\end{aligned}\]</span><br>上面公式中<span class="math inline">\(n_i\)</span> 表示训练数据集中第 i封邮件的长度，也就是 <span class="math inline">\(x^{(i)}\)</span>的维度。当然，我们可以应用拉普拉斯平滑，将<span class="math inline">\(\phi_{k\mid y=0}\)</span> 改写成如下形式，<span class="math inline">\(\phi_{k \mid y=0}\)</span> 同理。</p><p><span class="math display">\[\phi_{k \mid y=0} = \frac{\sum\limits_{i=1}^n(\mathcal{I}(y^{(i)}=0)\sum\limits_{j=1}^{m}\mathcal{I}(x_j^{(i)})=k) +1}{\sum\limits_{i=1}^n \mathcal{I}(y^{(i)}=0)\cdot n_i + 词典长度}\]</span></p><h2 id="支持向量机简介">支持向量机简介</h2><p>支持向量机（Support VectorMachine，SVM）是一种机器学习算法，可以用于分类和回归问题。它通过在高维空间中寻找一个最优的超平面，将不同类别的样本实例分开。在支持向量机中，数据点被看作是高维空间中的向量，不同类别的数据点被分别标记为正样本（+1）和负样本（-1）。SVM的目标是找到一个超平面，使得离该平面最近的数据点的距离最大化，这些离超平面最近的数据点就是支持向量（SupportVector）。</p><p>另外，支持向量机还可以将一个简单的特征集（如<span class="math inline">\([x_1,x_2]\)</span>），映射到一个高维的特征集(如<span class="math inline">\([x_1, x_2, x_1^2, x_2^2,x_1x_2]\)</span>)，从而找到一个非线性的边界。</p><h3 id="特殊记号">特殊记号</h3><ul><li><p>标签 <span class="math inline">\(y \in \{-1,+1\}\)</span></p></li><li><p>h 预测的值在 <span class="math inline">\(\{-1, +1\}\)</span>之中<br><span class="math display">\[g(z) =\begin{cases} &nbsp;1, &amp;  z \ge 0 \\-1, &amp;  z &lt; 0\end{cases}\]</span></p></li><li><p><span class="math inline">\(h_{w, b}(x) = g(w^Tx +b)\)</span>，其中 <span class="math inline">\(w \in\mathbb{R}^n\)</span>，<span class="math inline">\(b \in\mathbb{R}\)</span></p></li></ul><h3 id="functional-margin">Functional margin</h3><p>Functional margin可以看做数据点到由 <span class="math inline">\((w,b)\)</span> 决定的超平面的距离的一种度量。对于一个数据点<span class="math inline">\((x^{(i)}, y^{(i)})\)</span>，其对应的Functionalmargin定义如下：<br><span class="math display">\[\hat{\gamma}^{(i)} = y^{(i)} (w^Tx^{(i)} + b)\]</span><br>根据<span class="math inline">\(\hat{\gamma}^{(i)}\)</span>的定义也定看出，当<span class="math inline">\(\hat{\gamma}^{(i)} &gt;0\)</span> 时，表示<span class="math inline">\(h(x^{(i)}) =y^{(i)}\)</span>。我们希望，我们的分类器可以达到一个较大的 FunctionalMargin， 即<span class="math inline">\(\hat{\gamma}^{(i)} \gg0\)</span>，也就是说，</p><ul><li>当<span class="math inline">\(y^{(i)} = 1\)</span> 时，我们希望<span class="math inline">\(w^Tx^{(i)} + b \gg 0\)</span></li><li>当<span class="math inline">\(y^{(i)} = -1\)</span> 时，我们希望<span class="math inline">\(w^Tx^{(i)} + b \ll 0\)</span></li></ul><p>对于整个数据集来说，其 Functional margin 可以被定义为<br><span class="math display">\[\hat{\gamma} = \min_{i} \hat{\gamma}^{(i)}\]</span><br>当然，我们可以采取一种trick 来增加<span class="math inline">\(\hat{\gamma}^{(i)}\)</span> 的值——即把 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 同时增大相同的倍数，这样<span class="math inline">\(\hat{\gamma}^{(i)}\)</span>也会增大相同的倍数，但是边界的位置不会改变。为了解决这个问题，我们可以增加约束，一种是限制<span class="math inline">\(||w|| = 1\)</span> ，另一种是<span class="math inline">\(w = \frac{w}{||w||}, b =\frac{b}{||b||}\)</span>。</p><h3 id="geometric-margin">Geometric margin</h3><p>Geometric margin 也是数据点到由 <span class="math inline">\((w,b)\)</span>决定的超平面的距离的一种度量，其实就是数据点到超平面的欧几里得距离。对于一个数据点<span class="math inline">\((x^{(i)}, y^{(i)})\)</span>，其对应的 Geometricmargin 定义如下：<br><span class="math display">\[\gamma^{(i)} = \frac{y^{(i)} (w^Tx^{(i)} + b)}{||w||}\]</span><br>结合 Functional margin 的定义，我们可以发现<br><span class="math display">\[\gamma^{(i)} = \frac{\hat{\gamma}^{(i)}}{||w||}\]</span><br>对于整个数据集来说，其 Geometric margin 可以被定义为<br><span class="math display">\[\gamma = \min_{i} \gamma^{(i)}\]</span><br>他的几何意义也很简单，就是“距离超平面最近的数据点”到超平面的距离。为了能够获得一个最佳边际分类器（optimalmargin classifier），我们需要让选择<span class="math inline">\((w,b)\)</span> 让 <span class="math inline">\(\gamma\)</span>最大化，也就是让所有数据点尽量离着超平面远一些。下图中，绿线分界线对应的<span class="math inline">\(\gamma\)</span>显然要大于红线分界线，因此绿色分界线更优。</p><p><img src="./1.png"></p>最大化 <span class="math inline">\(\gamma\)</span>我们可以形式化的描述为<br>$$<br><span class="math display">\[\begin{aligned}&amp;\max_{\gamma, w, b} \ \gamma \\&amp;s.t. \frac{y^{(i)} (w^Tx^{(i)} + b)}{||w||} \ge \gamma \ \ \ \ \ (i= 1, \dots, m)\end{aligned}\]</span><span class="math display">\[通过推导我们可以把这个问题转化为\]</span><br><span class="math display">\[\begin{aligned}&amp;\min_{w, b} ||w||^2 \\&amp;s.t. \  y^{(i)} (w^Tx^{(i)} + b) \ge 1 \ \ \ \ \ (i = 1, \dots, m)\end{aligned}\]</span><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CS229」Lecture5：生成学习算法、GDA和朴素贝叶斯</title>
      <link href="/2023/06/26/ml/cs229-lecture5/"/>
      <url>/2023/06/26/ml/cs229-lecture5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引入">引入</h2><p>在前面的课程中，我们学会了使用 Logistic 回归来解决二分类问题。</p><ul><li>Logistc回归本质上是一种<strong>判别学习算法</strong>（Discriminative LearningAlgorithm），目标是找到一个<strong>决策边界</strong>或者一个<strong>条件概率分布函数</strong>，将输入数据映射到对应的类别或者数值。</li><li>与此不同，本节课学习的 GDA 和 Naive Bayes本质上是<strong>生成学习算法</strong>（Generative LearningAlgorithm），即通过学习输入数据和标签的<strong>联合概率分布</strong>来进行分类或回归任务。</li></ul><p>上面的说法还是有点抽象，我们以肿瘤性质预测任务为例进行分析。假设输入特征<span class="math inline">\(x\)</span> 是肿瘤的大小。</p><ul><li><p>对于判别学习算法来说，目标是学习到一个良性肿瘤和恶性肿瘤的边界——也就是“<span class="math inline">\(x\)</span>大于某个值时表明肿瘤是恶性，小于某个值时肿瘤是良性”。从概率的角度来说，我们学到的其实是<strong><span class="math inline">\(P(y | x)\)</span></strong>。当获得新的输入 <span class="math inline">\(x^*\)</span> 时，只需要计算<span class="math inline">\(P(y=1 | x = x^*)\)</span> 和 <span class="math inline">\(P(y = 0 | x = x^*)\)</span>，然后比较两者的大小就能够做出预测。</p></li><li><p>对于生成学习算法来说，我们学到的是 <strong><span class="math inline">\(P(x | y)\)</span> 和 <span class="math inline">\(P(y)\)</span></strong> 。</p><ul><li><span class="math inline">\(P(x|y)\)</span> 表示给定<span class="math inline">\(y\)</span> 的时候 <span class="math inline">\(x\)</span> 的概率，具体来说<span class="math inline">\(P(x| y=1)\)</span>表示恶性肿瘤大小的概率分布，<span class="math inline">\(P(x|y=1)\)</span>表示良性肿瘤大小的概率分布。因此，最终我们每个类别都建立一个概率分布。</li><li><span class="math inline">\(P(y)\)</span> 表示 <span class="math inline">\(y\)</span> 本身的概率，具体来说 <span class="math inline">\(P(y = 1)\)</span> 表示恶性肿瘤出现的概率，<span class="math inline">\(P(y = 0)\)</span> 表示良性肿瘤出现的概率。</li></ul><p>最终，我们的目标仍然是“给定一个输入<span class="math inline">\(x\)</span>，预测对应 的<span class="math inline">\(y\)</span>”，即找到 <span class="math inline">\(\mathop{\arg\max}\limits_{y}P(y |x)\)</span>。根据贝叶斯公式，我们有</p></li></ul><p><span class="math display">\[\begin{aligned}&amp;P(y=1 \mid x) = \frac{P(x|y=1) \cdot P(y = 1)}{P(x)}=  \frac{P(x|y=1) \cdot P(y =1)}{P(x|y = 1) \cdot P(y=1) + P(x|y=0)\cdot P(y=0) } \\&amp;P(y=0 \mid x) = \frac{P(x|y=0) \cdot P(y = 0)}{P(x)}=  \frac{P(x|y=0) \cdot P(y = 0)}{P(x|y = 1) \cdot P(y=1) + P(x|y=0)\cdot P(y=0) }\end{aligned}\]</span></p><p>对于一个特定输入<span class="math inline">\(x^*\)</span>,我们只需要比较<span class="math inline">\(P(y = 1 | x = x^*)\)</span> 和<span class="math inline">\(P(y = 0 | x = x^*)\)</span>的相对大小即可。又因为<span class="math inline">\(P(x)\)</span>是相同的，我们只需要比较<span class="math inline">\(P(x|y) \cdotP(y)\)</span>即可。<span class="math inline">\(P(x|y) \cdotP(y)\)</span> 也即是联合概率分布<span class="math inline">\(P(x,y)\)</span>，因此前面我们说<strong>“生成学习算法实际上是学习的输入数据和标签的联合概率分布”</strong>。</p><h2 id="高斯判别分析gda">高斯判别分析（GDA）</h2><p>高斯判别分析是生成学习算法中的一种。在数据集非常小的时候执行速度很快，只需要以此计算，不需要迭代。</p><h3 id="关键假设">关键假设</h3><p>在 GDA 中，我们假设 :</p><ul><li><span class="math inline">\(x | y\)</span>满足多元高斯分布（Gaussian）</li><li><span class="math inline">\(y\)</span>满足伯努利分布（Bernoulli）</li></ul><h3 id="模型参数">模型参数</h3><p>假如是二分类任务，根据上述假设我们有</p><p><span class="math display">\[\begin{aligned}&amp;P(x \mid y=0) = \frac{1}{\sqrt{(2\pi)^n|\sum|}} \exp (-\frac{1}{2}(x - \mu_0)^T \mathop{\sum}\nolimits^{-1}(x - \mu_0)) \\&amp;P(x \mid y=1) = \frac{1}{\sqrt{(2\pi)^n|\sum|}} \exp (-\frac{1}{2}(x - \mu_1)^T \mathop{\sum}\nolimits^{-1}(x - \mu_1)) \\&amp;P(y) = \phi^y(1-\phi)^{1-y}\end{aligned}\]</span></p><p>不难看出有四个参数：</p><ul><li><span class="math inline">\(\mu_0 \in \mathbb{R}^n\)</span></li><li><span class="math inline">\(\mu_1 \in \mathbb{R}^n\)</span></li><li><span class="math inline">\(\sum \in \mathbb{R}^{n \times n}\)</span></li><li><span class="math inline">\(\phi \in \mathbb{R}\)</span>。</li></ul><blockquote><p>因为我们假定<span class="math inline">\(P(x | y=0)\)</span>和<span class="math inline">\(P(x | y=1)\)</span> 有相同协方差矩阵，因此并没有<span class="math inline">\(\sum\nolimits_0\)</span> 和 <span class="math inline">\(\sum\nolimits_1\)</span> 之分，而是使用同一个<span class="math inline">\(\sum\)</span>。当我们采用同一个<span class="math inline">\(\sum\)</span>，最终的决策边界是线性的，比较适合需要线性边界的分类问题。当然可以用不同的<span class="math inline">\(\sum\)</span>，但这样决策边界就不是线性的了，同时也增加了计算量。</p></blockquote><h3 id="训练">训练</h3><p>我们采用最大似然估计来找到这四个参数的值。在判别学习算法中，比如Logistic 回归，我们使用的是条件似然（conditionallikehood）。而对于生成学习算法，我们使用的是联合似然（jointlikehood），似然函数的定义为</p><p><span class="math display">\[\begin{aligned}\mathcal{L}(\phi, \mu_0, \mu_1,\sum) &amp;= \prod_{i=1}^m P(x^{(i)},y^{(i)}; \ \  \phi, \mu_0, \mu_1,\sum ) \\&amp;= \prod_{i=1}^m P( x^{(i)} \mid y^{(i)}; \ \  \phi, \mu_0,\mu_1,\sum ) \cdot P(y^{(i)})\\\end{aligned}\]</span></p><p>我们对似然函数取对数得到<span class="math inline">\(\ell(\phi, \mu_0,\mu_1,\sum)\)</span>，并令其<strong>导数</strong>等于0，得到最终的参数值：</p>$$<br><span class="math display">\[\begin{aligned}&amp; \phi = \frac{\sum\limits_{i=1}^m y^{(i)}}{m} =\frac{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)}=1)}{m}  \\\\&amp; \mu_0 = \frac{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)} =0) \cdotx^{(i)}    }{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)} =0)} \\\\&amp; \mu_1 = \frac{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)} =1) \cdotx^{(i)}    }{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)} = 1)} \\\\&amp; \sum = \frac{1}{m}\sum_{i=1}^{m}(x^{(i)} - \mu \cdot y^{(i)})(x^{(i)} -  \mu \cdot y^{(i)})^T\end{aligned}\]</span><p>$$</p><p>其中 <span class="math inline">\(\mathcal{I}(A)\)</span>是指示器函数（Indicator）</p><p><span class="math display">\[\mathcal{I}(A)  = \begin{cases}    1, &amp; \text{if } A = \tt{true} \\    0, &amp; \text{if } A = \tt{false}\end{cases}\]</span></p><h3 id="预测">预测</h3><p>给定输入 <span class="math inline">\(x\)</span>，我们可以利用上面训练得到的参数，找到对应的预测值<span class="math inline">\(y\)</span></p><p><span class="math display">\[\begin{aligned}y &amp;= \mathop{\arg\max}\limits_y P(y | x) \\&amp;= \mathop{\arg\max}\limits_y \frac{P(y) \cdot P(x | y)}{P(x)}\end{aligned}\]</span></p><p>因为 <span class="math inline">\(P(x)\)</span>是相同的，只起到归一化的作用，所以我们通常可以不用计算（除非需要求出具体的概率值），即</p><p><span class="math display">\[y = \mathop{\arg\max}\limits_y (P(y) \cdot P(x | y))\]</span></p><h2 id="判别学习算法和生成学习算法">判别学习算法和生成学习算法</h2><p>我们可以画出<span class="math inline">\(P(x\mid y=1)\)</span>、<span class="math inline">\(P(x \mid y = 0)\)</span> 以及对应的<span class="math inline">\(P(y=1 \mid x)\)</span>的图像。</p><p><img src="./GDA.png" style="zoom:50%;"></p><p>不难看出，<span class="math inline">\(P(y=1 \midx)\)</span>的图像很像 Logistc 函数。实际上，GDA这些概率分布假设是可以<strong>推出</strong> <span class="math inline">\(P(y=1 \mid x)\)</span>是Logistic函数，但是反之不成立。也就是说，GDA的假设更强一些（strongassume），Logistic 的假设更弱一些（weak assume）。</p><p><img src="./imply.png" style="zoom:50%;"></p><p>当然，如果 <span class="math inline">\(x|y=0\)</span> 和 <span class="math inline">\(x | y=1\)</span>取指数族的其他分布，比如泊松分布，也能够推出$ P(y=1 x)$ 是 Logistic函数。反之同样不可以。</p><p>设置更强的假设实际上是为模型注入了更多的信息。因此，当我们数据量比较少时，可以通过设置比较强的假设提高模型的效果。但是，如果假设和实际的偏差比较大，模型效果可能会非常差。所以，如果事先不知道<span class="math inline">\(x \mid y\)</span> 属于什么分布时，还是使用Logistic 回归比较可靠。</p><p>在大数据时代，我们可以获得非常多的数据来训练模型，因此可以不需要设置假设，直接让模型从数据中获得信息即可。像GPT2、GPT3、GPT4等模型，也都是采用了“暴力美学”的思想，给模型投喂大量的数据，最终获得了amazing的效果。</p><h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>朴素贝叶斯（NaiveBayes）是一种基于贝叶斯定理的简单且常用的分类算法。<strong>它假设特征之间相互独立，即特征之间没有任何关联</strong>。尽管这个假设在现实中往往是不成立的，但朴素贝叶斯仍然在许多实际问题中表现良好。</p><h3 id="问题引入">问题引入</h3><p>我们可以通过“垃圾邮件分类”问题来介绍朴素贝叶斯算法。在该问题中，输入特征<span class="math inline">\(x\)</span> 是一个n维向量，n是词典的大小，<span class="math inline">\(x\)</span>每一个分量表示“词典该位置的单词是否出现”。标签 <span class="math inline">\(y\)</span> 为0 或者 1，表示是否为垃圾邮件。</p><p>假设词典为 [a, English， I，like，zoo]，维度为5。有一封邮件的内容为“I like Englist”，则对应的 <span class="math inline">\(x\)</span> 就是</p><p><span class="math display">\[x = \begin{bmatrix}0 &amp;1 &amp; 1 &amp; 1 &amp; 0\end{bmatrix}^T\]</span></p><p>如果我们使用<strong>生成学习算法</strong>，则需要对<span class="math inline">\(P(x | y)\)</span>进行建模。因为词典的规模一般非常大，假设n = 10000，则 <span class="math inline">\(x\)</span> 的可能取值的数量就达到<span class="math inline">\(2^{10000}\)</span>，然后我们需要<span class="math inline">\((2^{100000} -1)\)</span>维的参数向量，这就太过复杂了。</p><h3 id="问题解决">问题解决</h3><h4 id="思路">思路</h4><p>如果应用朴素贝叶斯，那么问题就会变得简单——即假设给定<span class="math inline">\(y\)</span> 值的条件下，<span class="math inline">\(x\)</span> 的各个分量都是独立的，即</p><p><span class="math display">\[\begin{aligned}P(x|y) &amp;= P(x_1, x_2, ..., x_n \mid y) \\       &amp;= P(x_1 \mid y) P(x_2 \mid y)\ ... \ P(x_n \mid y)\end{aligned}\]</span></p><p>具体到这个例子，就是说——在该邮件是垃圾邮件的条件下（<span class="math inline">\(y = 1\)</span>），</p><h4 id="模型参数-1">模型参数</h4><p>我们假设 <span class="math inline">\(P(x \mid y)\)</span> 和 <span class="math inline">\(P(y)\)</span>都遵循伯努利分布，则模型具有以下参数</p><ul><li><span class="math inline">\(\phi_{j \mid y = 1} = P(x_j = 1 \mid y =1)\)</span></li><li><span class="math inline">\(\phi_{j \mid y = 0} = P(x_j = 1 \mid y =0)\)</span></li><li><span class="math inline">\(\phi_y = p(y = 1)\)</span></li></ul><h4 id="训练-1">训练</h4><p>我们采用最大似然估计来找到这三个参数的值。似然函数 $(<em>y,</em>{jy=1}, _{jy=0}) $ 的定义如下所示</p>$$<br><span class="math display">\[\begin{aligned}\mathcal{L}(\phi_y, \phi_{j\mid y=1}, \phi_{j\mid y=0}) &amp;= \prod_{i= 1}^{n} P(x^{(i)}, y^{(i)}; \phi_y, \phi_{j\mid y=1}, \phi_{j\mid y=0})\end{aligned}\]</span><p>$$</p><p>令其<strong>导数</strong>等于0，得到最终的参数值</p>$$<br><span class="math display">\[\begin{aligned}&amp;\phi_y \ \ \ \ \ \ = \frac{\sum\limits_{i=1}^m \mathcal{I}(y^{(i)}= 1)}{m} \\&amp; \phi_{j \mid y = 1} = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 1)}{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 1)} \\&amp; \phi_{j \mid y = 0} = \frac{\sum\limits_{i=1}^m\mathcal{I}(x_j^{(i)} = 1, y^{(i)} = 0)}{\sum\limits_{i=1}^m\mathcal{I}(y^{(i)} = 0)} \\\end{aligned}\]</span><p>$$</p><h4 id="预测-1">预测</h4><p>预测时可以使用贝叶斯公式，结合朴素贝叶斯的假设，我们有</p><p><span class="math display">\[\begin{aligned}y &amp;= \mathop{\arg\max}\limits_y P(y | x) \\&amp;= \mathop{\arg\max}\limits_y \frac{P(y) \cdot P(x | y)}{P(x)} \\&amp;= \mathop{\arg\max}\limits_y \frac{P(y) \cdot P(x_1 | y) \cdotP(x_2 | y) \dots  P(x_n | y)}{P(x)}\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CS229」Lecture4：Perception、GLM和Softmax</title>
      <link href="/2023/06/25/ml/cs229-lecture4/"/>
      <url>/2023/06/25/ml/cs229-lecture4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="perception算法">Perception算法</h2><p>Perception也是一种用来解决二分类问题的算法。它的具体形式也很直观——<br><span class="math display">\[h_\theta(x) = g(\theta^Tx) \\ \\g(z) = \begin{cases}    1, &amp;  z \ge 0 \\    0, &amp;  z &lt; 0\end{cases}\]</span><br><span class="math inline">\(g(z)\)</span>函数的表示形式比较符合我们的直觉：当 <span class="math inline">\(z \ge0\)</span> ，即 <span class="math inline">\(\theta^Tx \ge 0\)</span>的时候，直接将 x 分到某一类（用 1 表示），直接令 <span class="math inline">\(y = g(z) = 1\)</span> ；反之将 x 分到另外一类，直接令 <span class="math inline">\(y = g(z) = 0\)</span>。</p><p>类似于求解Logistic回归的损失函数的过程，我们可以通过极大似然估计得到Perception 算法的损失函数（过程和结果和Logistic是一样的）<br><span class="math display">\[J(\theta) = \sum_{i=1}^m  - \ y^{(i)} \cdot \log(h_\theta(x^{(i)}))  -(1 - y^{(i)}) \cdot \log(1 - h_\theta(x^{(i)}))\]</span><br>定义好损失函数，我们就可以采用梯度下降求解参数。<br><span class="math display">\[\begin{aligned}\theta_j := \theta_j - \alpha \frac{\partial \J(\theta)}{\partial\  \theta_j} =  \theta_j - \alpha \sum_{i=1}^m(h_\theta(x ^{(i)})  -  y^{(i)}) \cdot x_j^{(i)}\end{aligned}\]</span><br>因为 <span class="math inline">\(g(z)\)</span>的表示十分简洁并且符合直觉，所以Perception算法求解有很好的的几何解释，具体可以看课程视频对应部分。但是，Perception 缺乏概率解释，这是它没有得到广泛应用的原因之一。</p><p>此外，Perception还有一个明显缺点——它只能处理线性可分的数据集。对于线性不可分的数据集，Perception算法将无法收敛。比如下面这个图就不是线性可分的。</p><h6 id="section"><img src="./线性不可分.png" alt="image-20230624202845085" style="zoom:75%;"></h6><h2 id="指数族the-exponential-family">指数族（The exponentialfamily）</h2><h3 id="指数族的定义">指数族的定义</h3><p>如果一个分布能用下面的方式写出来，我们就说这个分布属于指数族<br><span class="math display">\[P(y;\eta) = b(y) \cdot \exp(\eta^TT(y) - a(\eta))\]</span><br>现在简要介绍以下公式中的参数：</p><ul><li><p><span class="math inline">\(y\)</span> 是研究的数据</p></li><li><p><span class="math inline">\(\eta\)</span> 是自然参数（naturalparameter），也叫典范参数（canonical parameter）。</p></li><li><p><span class="math inline">\(T(y)\)</span>叫做充分统计量（sufficient statistic），在这里我们可以认为<span class="math inline">\(T(y) = y\)</span>。</p></li><li><p><span class="math inline">\(a(\eta)\)</span>叫做对数分割函数（log partition function），它与数据 <span class="math inline">\(y\)</span> 无关。<span class="math inline">\(\exp(-a(\eta))\)</span>主要起“归一化”的作用。</p></li><li><p><span class="math inline">\(b(y)\)</span> 叫做基础度量（basemeasure），只与数据 <span class="math inline">\(y\)</span>有关，与自然参数 <span class="math inline">\(\eta\)</span>无关。</p></li></ul><p>其中，<span class="math inline">\(T(y), a(\eta), b(y)\)</span>是可以根据我们的需求任意选择的。对于一组固定的<span class="math inline">\(T(y), a(\eta), b(y)\)</span> ，就得到了一个由<span class="math inline">\(\eta\)</span>参数化的一组分布。通过改变<span class="math inline">\(\eta\)</span>，我们就可以得到该组分布中的不同特定分布了。</p><h3 id="举例说明">举例说明</h3><p>我们学过的伯努利分布、高斯分布、泊松分布等都属于指数族。</p><h4 id="伯努利分布bernoulli">伯努利分布（Bernoulli）</h4><p>对于伯努利分布，我们熟知的表示形式为<br><span class="math display">\[P(y; \phi) = \phi^y(1-\phi)^{1-y}\]</span><br>我们可以对其进行变换<br><span class="math display">\[\begin{aligned}P(y; \phi) &amp;= \phi^y(1-\phi)^{1-y} \\&amp;= \exp(\log(\phi^y(1-\phi)^{1-y})) \\&amp;= \exp(y\cdot \log(\phi) + (1-y) \cdot(1-\log(\phi))) \\&amp;= \exp(y \cdot \log(\frac{\phi}{1 - \phi}) + \log(1 - \phi))\end{aligned}\]</span><br>很显然，这符合指数族的定义。其中：</p><ul><li><p><span class="math inline">\(\eta =\log(\frac{\phi}{1-\phi})\)</span>，即 <span class="math inline">\(\phi= \frac{1}{1 + e^{-\eta}}\)</span></p></li><li><p><span class="math inline">\(T(y) = y\)</span></p></li><li><p><span class="math inline">\(a(\eta) = -\log(1 - \phi) = \log(1 +e^\eta)\)</span></p></li><li><p><span class="math inline">\(b(y) = 1\)</span></p></li></ul><h4 id="高斯分布gaussian">高斯分布（Gaussian）</h4><p>对于高斯分布，我们熟知的表示形式为<br><span class="math display">\[P(y; \mu, \sigma^2) = \frac{1}{\sqrt{2\pi} \sigma} \exp(-\frac{(y-\mu)^2}{2 \sigma^2})\]</span><br>当<span class="math inline">\(\sigma\)</span> 固定，比如<span class="math inline">\(\sigma = 1\)</span>时，高斯分布也是属于指数族的。我们通过下面的推导证明：<br><span class="math display">\[\begin{aligned}P(y; \mu, 1) &amp;= \frac{1}{\sqrt{2\pi}} \exp (-\frac{(y-\mu)^2}{2}) \\&amp;= \frac{1}{\sqrt{2\pi}} e^{-\frac{y^2}{2}}\exp(\mu y - \frac{1}{2}\mu^2) \\\end{aligned}\]</span><br>很显然，这符合指数族的定义。其中：</p><ul><li><p><span class="math inline">\(\eta = \mu\)</span></p></li><li><p><span class="math inline">\(T(y) = y\)</span></p></li><li><p><span class="math inline">\(a(\eta) = \frac{1}{2}\mu^2\)</span></p></li><li><p><span class="math inline">\(b(y) = \frac{1}{\sqrt{2\pi}}e^{-\frac{y^2}{2}}\)</span></p></li></ul><h3 id="指数族的性质">指数族的性质</h3><ol type="1"><li><p>对于指数族中的某一组分布<span class="math inline">\(p(y;\eta)\)</span>，关于<span class="math inline">\(\eta\)</span>的极大似然估计（MLE）是凹优化的，即<span class="math inline">\(\eta\)</span>的负对数似然（NLL）是凸优化的。</p></li><li><p>概率分布 <span class="math inline">\(p(y;\eta)\)</span>的期望<span class="math inline">\(E(y;h)\)</span>满足:<br><span class="math display">\[E(y;h) = \frac{\partial \ a(\eta)}{\partial\ \eta}\]</span><br>方差<span class="math inline">\(Var(y;\eta)\)</span> 满足:<br><span class="math display">\[Var(y;\eta) = \frac{\partial^2 \ a(\eta)}{\partial\ \eta^2}\]</span></p></li></ol><h2 id="广义线性模型glm">广义线性模型（GLM）</h2><p>广义线性模型（GLM）是上面提到的指数族的自然延伸。我们前面学到的线性回归和Logistic 回归都可以通过广义线性模型导出。</p><h3 id="glm的三个假设">GLM的三个假设</h3><ul><li><p><span class="math inline">\(y \mid x;\theta \sim \tt{Exponential\ Family}\)</span></p></li><li><p><span class="math inline">\(\eta = \theta^Tx;\ (\theta \in\mathbb{R}^n, \ x \in \mathbb{R}^n)\)</span>这条假设被称为设计选择（design choice）</p></li><li><p>给定一个<span class="math inline">\(x\)</span>，如果想要对 <span class="math inline">\(y\)</span> 的值进行预测，则 <span class="math inline">\(y\)</span> 的预测值为" $ y x ; $ " 的期望，即<span class="math inline">\(E(y\mid x; \theta)\)</span>。因此，当我们使用 GLM进行预测时，<span class="math inline">\(h_\theta(x)\)</span>可以写作：<br><span class="math display">\[h_\theta(x) = E(y \mid x ;\theta)\]</span></p></li></ul><h3 id="glm的训练和预测">GLM的训练和预测</h3><p>通过上述假设可以看出，GLM 的参数是<span class="math inline">\(\theta\)</span>。因此训练目标就是“根据训练数据找到最合适的<span class="math inline">\(\theta\)</span>”，而预测目标就是“根据训练好的<span class="math inline">\(\theta\)</span>针对指定的<span class="math inline">\(x\)</span> 进行预测”。</p><p>GML的训练和预测过程如下图所示：</p><p><img src="./GLM训练与预测.svg"></p><ul><li><p>预测时，直接让<span class="math inline">\(x\)</span>与训练好的<span class="math inline">\(\theta\)</span> 进行点积运算，得到<span class="math inline">\(\eta\)</span>，输入到指数族中，对应的期望即为<span class="math inline">\(y\)</span> 的预测值。</p></li><li><p>训练时，可以直接根据最大似然估计找到损失函数，并利用梯度下降算法对<span class="math inline">\(\theta\)</span>进行求解。（这里我们采用的是随机梯度下降）<br><span class="math display">\[\begin{aligned}\theta_j := \theta_j - \alpha \cdot(h_\theta(x ^{(i)})  -  y^{(i)})\cdot x_j^{(i)}\end{aligned}\]</span></p><blockquote><p>当然，我们也可以进行梯度上升<br><span class="math display">\[\begin{aligned}\theta_j := \theta_j + \alpha \cdot(y^{(i)} - h_\theta(x ^{(i)})) \cdotx_j^{(i)}\end{aligned}\]</span><br>看上去仅仅是做了一个简单的数学变换，但是实际上我们这里的目标是“极大化似然函数”，而上面的梯度下降是“极小化损失函数”。</p></blockquote></li></ul><h3 id="glm-中的几个重要术语">GLM 中的几个重要术语</h3><ul><li><p><span class="math inline">\(\eta\)</span> 被称为自然参数（naturalparameter）</p></li><li><p><span class="math inline">\(\mu =E(y;\eta) = g(\eta)\)</span>被称为规范响应函数（cannonical responsefunction）。主要用于根据自然参数<span class="math inline">\(\eta\)</span> 得到均值 <span class="math inline">\(\mu\)</span> ，也就是 <span class="math inline">\(y\)</span> 的预测值。</p></li><li><p><span class="math inline">\(\eta = g^{-1}(\mu)\)</span>被称为规范连接函数（canonical link function）。主要用于根据均值 <span class="math inline">\(\mu\)</span> 得到自然参数 <span class="math inline">\(\eta\)</span> 。</p></li></ul><h3 id="glm-的三类参数">GLM 的三类参数</h3><p>GLM中涉及三类参数：</p><ul><li><p>首先最直接的是模型参数 <span class="math inline">\(\theta\)</span>，也就是我们通过训练求解的参数。（ModelParameter）</p></li><li><p>其次是指数族中的自然参数<span class="math inline">\(\eta\)</span>， 它等于<span class="math inline">\(\theta^T x\)</span>。（NaturalParameter）</p></li><li><p>最后是某个具体分布的参数（Cannonical Parameter）</p><ul><li><p>如果我们从指数族中选择伯努利分布<span class="math inline">\(P(y;\phi)\)</span>，则参数就是 <span class="math inline">\(\phi\)</span>。</p></li><li><p>如果我们选择高斯分布<span class="math inline">\(P(y;\mu)\)</span> （方差<span class="math inline">\(\sigma^2\)</span>固定），则参数就是 <span class="math inline">\(\mu\)</span>。</p></li><li><p>如果我们选择...</p></li></ul></li></ul><p>这三类参数之间的关系如下图所示：</p><p><img src="./GLM三个参数.svg"></p><p>需要注意，上图中<span class="math inline">\(g^{-1}(\mu)\)</span> 中的<span class="math inline">\(\mu\)</span>代表具体某个分布的期望（均值），并不单指高斯分布中的 <span class="math inline">\(\mu\)</span> 。</p><h3 id="具体分布的选择">具体分布的选择</h3><p>在上文我们提到，当我们使用 GLM进行预测时，需要针对任务类型（即需要预测的 y 的类型）选择合适的指数族分布。那么如何选择合适的分布呢？根据经验，我们有：</p><ul><li>对于回归问题，即<span class="math inline">\(y \in\mathbb{R}\)</span>时，我们选择高斯分布。</li><li>对于二分类问题，即 y 只取两个离散值时，我们选择伯努利分布。</li><li>对于计数类问题，即 <span class="math inline">\(y \in\mathbb{N}\)</span> 时，我们选择泊松分布。</li><li>对连续的、非负的随机变量进行建模，即 <span class="math inline">\(y\in \mathbb{R}^+\)</span> 时，例如时间间隔，我们选择<span class="math inline">\(\gamma\)</span>和指数分布。</li><li>对概率进行建模，即 <span class="math inline">\(y \in [0,1]\)</span>时，我们选择<span class="math inline">\(\beta\)</span>和狄利克雷分布。</li></ul><h2 id="softmax回归">Softmax回归</h2><p>对于单标签多分类问题，我们一般采用Softmax回归。例如给定一张图片，推测图上是什么动物——狗、喵还是小兔子。在该问题中，<span class="math inline">\(x^{(i)}\)</span> 仍然是输入的特征；但是标签<span class="math inline">\(y^{(i)}\)</span> 不再是一个值，而是一个“独热向量”，只有预测类别的对应位置为1，其余位置都为0。假设图中的动物是猫，此时对应的标签<span class="math inline">\(y^{(i)}\)</span> 就是<br><span class="math display">\[y^{(i)} = [0, 1, 0]^T\]</span><br>在Softmax回归中，我们需要为每一个类别训练出一个参数<span class="math inline">\(\theta_{class_i}\)</span>（维度和输入<span class="math inline">\(x\)</span> 相同）。因此最终的参数<span class="math inline">\(\theta\)</span> 就会形成一个矩阵：<br><span class="math display">\[\theta = \begin{bmatrix}|  &amp; | &amp; &amp;| \\   \theta_1 &amp; \theta_2 &amp; \dots &amp; \theta_n\\|  &amp; | &amp;  &amp;| \end{bmatrix}\]</span><br>预测函数<span class="math inline">\(h_\theta(x)\)</span>的定义如下所示：<br><span class="math display">\[h_\theta(x) = \begin{bmatrix}\frac{e^{\theta_1^Tx}}{\sum_{l=1}^m(e^{\theta_l^Tx})} &amp;\frac{e^{\theta_2^Tx}}{\sum_{l=1}^m(e^{\theta_l^Tx})} &amp;\dots &amp;\frac{e^{\theta_k^Tx}}{\sum_{l=1}^m(e^{\theta_l^Tx})}\end{bmatrix}^T\]</span><br>根据定义不难看出 <span class="math inline">\(h_\theta(x)\)</span> 是一个<span class="math inline">\(k\)</span> 维列向量，和标签 <span class="math inline">\(y\)</span> 的维度相同，其中<span class="math inline">\(k\)</span> 是分类数量。只不过 <span class="math inline">\(h_\theta(x)\)</span> 每一个分量都是一个<span class="math inline">\([0, 1]\)</span> 之间的实数值，并且分量和为1；而<span class="math inline">\(y\)</span> 是一个独热向量。</p><p>根据预测值<span class="math inline">\(h_\theta(x^{(i)})\)</span>和对应标签<span class="math inline">\(y^{(i)}\)</span>，我们可以定义Softmax 回归的损失函数<span class="math inline">\(J(\theta)\)</span>：<br><span class="math display">\[\begin{aligned}J(\theta) &amp;= - \sum_{i = 1}^m \tt{Cross \ Emtropy}(h_{\theta}(x^{(i)}),y^{(i)})\\&amp;= -\sum_{i = 1}^m \sum_{l=1}^k y_l^{(i)} \cdot\log(h_\theta^{(i)}(x)_l) \\&amp;= -\sum_{i = 1}^m  y_j^{(i)} \cdot \log(h_\theta^{(i)}(x)_j)\tt{(其中y_j^{(i)}=1)}\end{aligned}\]</span><br>接下来我们可以继续通过梯度下降求解<span class="math inline">\(\theta\)</span> 的最优值：<br><span class="math display">\[\theta_j := \theta_j - \alpha \frac{\partial \J(\theta)}{\partial\  \theta_j}\]</span><br>当然也可以通过随机梯度下降求解。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CS229」Lecture3： 局部加权回归、Logistic回归和牛顿方法</title>
      <link href="/2023/06/24/ml/cs229-lecture3/"/>
      <url>/2023/06/24/ml/cs229-lecture3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="局部加权线性回归">局部加权线性回归</h2><h3 id="参数学习算法和非参数学习算法">参数学习算法和非参数学习算法</h3><p>在机器学习中，我们有<strong>参数学习算法和非参数学习算法</strong></p><ul><li><p><strong>参数学习算法是指对具有特定参数的模型进行拟合的算法。</strong></p><ul><li><p>在该算法中，模型具有一组已知的参数。也就是说，我们明确知道“模型的表示形式”——例如对于下面这个散点图，我们一眼就能看出模型应该形如<span class="math inline">\(y = \theta x\)</span>。</p><p><img src="./1.png"></p></li><li><p>算法的主要任务是：基于训练数据集来估计这些参数的值，以使模型能够预测未来的数据。也就是说，模型训练完成之后，训练集（数据）就可以从计算机内存中“扔掉”，只需要保留模型的参数值即可完成后续预测任务。</p></li><li><p>常见的参数学习算法：一元线性回归</p></li></ul></li><li><p><strong>非参数学习算法是指对没有特定参数的模型进行拟合的算法。</strong></p><ul><li><p>在该算法中，模型没有固定的参数，因此它们能够学习和适应数据的不同特征和复杂性。也就是说，我们不知道“模型的表示形式”——例如下面这个散点图，我们一眼无法看出哪一种模型拟合的最好。</p><p><img src="./2.png"></p></li><li><p>每一次预测都需要用到所有的数据</p></li><li><p>常见的非参数学习算法：局部加权线性回归、决策树等等</p></li></ul></li></ul><h3 id="局部加权线性回归-1">局部加权线性回归</h3><p>局部加权线性回归的基本思想是：<strong>如果要预测 <span class="math inline">\(x^*\)</span>对应的 label,我们可以根据其附近的数据点进行拟合</strong>。最简单的方式是，根据 x附近的数据点拟合一条直线（当然是在 x 维度为1的前提下），根据这条直线对<span class="math inline">\(x^*\)</span> 进行预测。如下图所示</p><p><img src="./3.png"></p><p>此时，局部加权线性回归的成本函数我们可以写作——<br><span class="math display">\[J(\theta) = \sum_{i=1}^m w^{(i)}(y^{(i)} - \theta^Tx^{(i)})^2\]</span><br>可以看出，和线性回归的成本函数相比，该成本函数的每一项都乘了一个权重<span class="math inline">\(w^{(i)}\)</span>。根据局部加权线性回归的思想，我们需要更加关注 <span class="math inline">\(x^*\)</span>(需要预测的数据)附近的数据点。因此，<span class="math inline">\(x^{*}\)</span> 附近的数据点 <span class="math inline">\(x^{(i)}\)</span>我们应该赋予更高的权重，也就是更关注该数据点处的“损失”。一种常用的<span class="math inline">\(w^{(i)}\)</span> 的计算方式是：<br><span class="math display">\[w^{(i)} = \exp{(-\frac{(x^{(i)} - x^*)^2}{2})}\]</span><br>显然，当 <span class="math inline">\(x^{(i)}\)</span> 距离 <span class="math inline">\(x^*\)</span> 非常近的时候，<span class="math inline">\(w^{(i)}\)</span> 接近 1；当 <span class="math inline">\(x^{(i)}\)</span> 距离 <span class="math inline">\(x^*\)</span> 非常远的时候，<span class="math inline">\(w^{(i)}\)</span> 接近 0。<span class="math inline">\(w\)</span> 的图像如下图所示:</p><p><img src="./4.png"></p><p>有的时候，我们想要控制这个图像的“胖瘦”——即有的时候我们需要更大范围内的"邻居"，有的时候我们只需要非常靠近<span class="math inline">\(x^*\)</span>的"邻居"。此时，我们可以在<span class="math inline">\(w^{(i)}\)</span>中增加一个带宽（bandwidth）参数<span class="math inline">\(\sigma\)</span>，通过<span class="math inline">\(\sigma\)</span> 来控制：<br><span class="math display">\[w^{(i)} = \exp{(-\frac{(x^{(i)} - x^*)^2}{2 \sigma^2})}\]</span></p><h3 id="适用范围">适用范围</h3><p>当数据量比较大，且特征值比较少时（例如n=2,3），我们可以采用加权线性回归。</p><h2 id="线性回归的概率解释">线性回归的概率解释</h2><h3 id="问题引入">问题引入</h3><p>我们在线性回归中，使用“所有误差的平方和”作为成本函数，即：<br><span class="math display">\[J(\theta) =  \frac{1}{2} \sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^2\]</span><br>在这里我们为什么要采用平方，而不是采用四次方，或者直接取绝对值呢？</p><h3 id="概率解释">概率解释</h3><p>对于每一个数据点<span class="math inline">\((x^{(i)},y^{(i)})\)</span> ，我们可以写作<br><span class="math display">\[y^{(i)} = \theta^Tx^{(i)} + \varepsilon^{(i)}\]</span><br>其中，<span class="math inline">\(\varepsilon^{(i)}\)</span>是误差项。在这里，我们假设<span class="math inline">\(\varepsilon^{(i)}\)</span> 服从“均值为0,方差为<span class="math inline">\(\sigma^2\)</span>”的正态分布，即$^{(i)} (0, ^2) $ 。且所有的<span class="math inline">\(\varepsilon^{(i)}\)</span>都是独立同分布的（i.i.d.）。<br><span class="math display">\[P(\epsilon^{(i)}) = \frac{1}{\sqrt{2\pi} \sigma} \exp(-\frac{(\varepsilon^{(i)})^2}{2 \sigma^2})\]</span><br>根据前面的假设，有<br><span class="math display">\[P(y^{(i)} \mid x^{(i)}; \theta) = \frac{1}{\sqrt{2\pi} \sigma} \exp(-\frac{(y^{(i)} - \theta^Tx^{(i)})^2}{2 \sigma^2})\]</span><br>我们的目标是根据训练数据，得到最佳的参数值，也就是<span class="math inline">\(\theta\)</span>。我们可以根据最大似然估计的思想，“固定”训练数据（即把训练数据当做已知量），得到<span class="math inline">\(\theta\)</span> 的似然函数 <span class="math inline">\(\mathcal{L}(\theta)\)</span>：<br><span class="math display">\[\begin{aligned}\mathcal{L}(\theta) &amp;= P(Y \mid X; \theta) \\&amp;= \prod_{i=1}^{m} P(y^{(i)} \mid x^{(i)}; \theta) \\&amp;= \prod_{i=1}^{m} \frac{1}{\sqrt{2\pi} \sigma} \exp(-\frac{(y^{(i)} - \theta^Tx^{(i)})^2}{2 \sigma^2}) \\\end{aligned}\]</span><br>通常情况下，为了便于求解，我们经常对<span class="math inline">\(\mathcal{L}(\theta)\)</span> 取对数，得到<span class="math inline">\(\ell(\theta)\)</span><br><span class="math display">\[\begin{aligned}\ell(\theta) &amp;= \log (\mathcal{L}(\theta)) \\&amp;= \log(\prod_{i=1}^{m} \frac{1}{\sqrt{2\pi} \sigma} \exp(-\frac{(y^{(i)} - \theta^Tx^{(i)})^2}{2 \sigma^2})) \\&amp;=\sum_{i=1}^m \log(\frac{1}{\sqrt{2 \pi} \sigma} ) - \frac{1}{2\sigma^2} \sum_{i=1}^m (y^{(i)} - \theta^Tx^{(i)})^2\end{aligned}\]</span><br>根据最大似然估计，我们应该找到一个<span class="math inline">\(\theta\)</span>，使得最大化<span class="math inline">\(\mathcal{L}(\theta)\)</span>，也就是最大化<span class="math inline">\(\ell(\theta)\)</span>。因此有<br><span class="math display">\[\theta = \mathop{\arg\max}\limits_{\theta} \ \ell(\theta)\]</span></p><p>根据<span class="math inline">\(\ell(\theta)\)</span>的表示，很容易可以看出，我们只需要 <span class="math inline">\(\sum_{i=1}^m (y^{(i)} -\theta^Tx^{(i)})^2\)</span> 最大即可。这不就是线性回归成本函数<span class="math inline">\(J(x)\)</span>的表示嘛！</p><p>当然了，还是需要注意——所有的推导都是基于一开始的假设：误差<span class="math inline">\(\varepsilon^{(i)}\)</span>服从“均值为0,方差为<span class="math inline">\(\sigma^2\)</span>”的正态分布，即$^{(i)} (0, ^2)$。尽管这看上去非常理想，但是在实践中通常拟合的很好（满足中心极限定律）。</p><blockquote><p>似然（likehood）和概率（probably）的区别：</p><ul><li>似然是参数的似然，数据是固定的</li><li>概率是数据的概率，参数是固定的</li></ul></blockquote><h2 id="logistics-回归">Logistics 回归</h2><h3 id="基本形式">基本形式</h3><p>Logistics 回归主要是为了解决二分类问题。在分类问题中， y 是离散的，如<span class="math inline">\(y \in \{0, 1\}\)</span> 。对于二分类问题，一个典型的散点图如下所示（我们可以将它应用于肿瘤性质的预测—— x 表示肿瘤的大小， y 表示肿瘤是恶性还是良性）</p><p><img src="./5.png"></p><p>很显然，我们不能简单的用线性回归来拟合它，因为线性拟合很容易受到“离群值”的影响。在这里我们使用Logistics 回归来拟合它，函数 <span class="math inline">\(h_\theta(x)\)</span> 可以表示为<br><span class="math display">\[h_\theta(x) = g(\theta^Tx) = \frac{1}{1+e^{-\theta^Tx}} \\g(z) = \frac{1}{1 + e^{-z}}\]</span><br>其中函数 <span class="math inline">\(g(z)\)</span> 我们称为 Logistics函数，函数图像如下所示</p><p><img src="./6.png"></p><p>不难看出<span class="math inline">\(h_\theta \in [0,1]\)</span>。当<span class="math inline">\(h_\theta(x) &gt; 0.5\)</span>时，我们可以认为预测值为 1；当<span class="math inline">\(h_\theta(x)\leq 0.5\)</span> 时，我们可以认为预测值为 0 。</p><h3 id="损失函数">损失函数</h3><p>利用<span class="math inline">\(h_\theta(x)\)</span>的定义，我们可以写出“给定 x 时 y = 1 的概率” 以及 “给定 x 时 y = 0的概率”：<br><span class="math display">\[P(y = 1 \mid x; \theta) = h_\theta(x) \\P(y = 0 \mid x; \theta) = 1 - h_\theta(x)\]</span><br>因为 <span class="math inline">\(y \in \{0, 1\}\)</span>，所以我们可以利用这一点将上面两个式子合成一个：<br><span class="math display">\[P(y \mid x;\theta) = h_\theta(x)^{y} \cdot (1 - h_\theta(x))^{1-y}\]</span><br>我们继续用极大似然估计来推导损失函数。似然函数可以写作<br><span class="math display">\[\begin{aligned}\mathcal{L}(\theta) &amp;= P(Y \mid X; \theta) \\&amp;= \prod_{i=1}^{m} P(y^{(i)} \mid x^{(i)}; \theta) \\&amp;= \prod_{i=1}^{m}  h_\theta(x^{(i)})^{y^{(i)}} \cdot (1 -h_\theta(x^{(i)}))^{1-y^{(i)}}\end{aligned}\]</span><br>同样为了便于计算，需要对 <span class="math inline">\(\mathcal{L}(\theta)\)</span> 取对数<br><span class="math display">\[\begin{aligned}\ell(\theta) &amp;= \log (\mathcal{L}(\theta)) \\&amp;= \log(\prod_{i=1}^{m}  h_\theta(x^{(i)})^{y^{(i)}} \cdot (1 -h_\theta(x^{(i)}))^{1-y^{(i)}}) \\&amp;=\sum_{i=1}^m  y^{(i)} \cdot \log(h_\theta(x^{(i)}))  + (1 -y^{(i)}) \cdot \log(1 - h_\theta(x^{(i)}))\end{aligned}\]</span><br><span class="math inline">\(\theta\)</span> 的最优值应该使得 <span class="math inline">\(\ell(\theta)\)</span> 最大化。因此，成本函数<span class="math inline">\(J(\theta)\)</span>可以定义为<br><span class="math display">\[J(\theta) = \sum_{i=1}^m  - \ y^{(i)} \cdot \log(h_\theta(x^{(i)}))  -(1 - y^{(i)}) \cdot \log(1 - h_\theta(x^{(i)}))\]</span><br>当<span class="math inline">\(J(\theta)\)</span> 最小时，<span class="math inline">\(\ell(\theta)\)</span> 最大，此时<span class="math inline">\(\theta\)</span>是最优值。接下来，我们同样可以使用梯度下降求解 <span class="math inline">\(\theta\)</span><br><span class="math display">\[\theta_j := \theta_j - \alpha \frac{\partial \J(\theta)}{\partial\  \theta_j} \ \\ \tt{(repeat \ until \ convergence)}\]</span><br>将<span class="math inline">\(\frac{\partial \J(\theta)}{\partial\  \theta_j}\)</span> 的值计算并代入，即可得到<br><span class="math display">\[\theta_j := \theta_j - \alpha \sum_{i=1}^m (h_\theta(x^{(i)})  -  y^{(i)}) \cdot x_j^{(i)} \\]</span></p><h2 id="牛顿法">牛顿法</h2><h3 id="问题引入-1">问题引入</h3><p>无论是线性回归，还是 Logistics回归，他们的局部最优值就是全局最优值。也就是说，他们的似然函数 <span class="math inline">\(\ell(\theta)\)</span>的唯一极值也就是最值。因此，我们可以直接对似然函数对<span class="math inline">\(\theta\)</span> 求导数，并令导数等于0，即<br><span class="math display">\[\ell^{\prime}(\theta) = 0\]</span><br>对于<span class="math inline">\(\ell(\theta)\)</span>，求导数是很容易的，但是求解 <span class="math inline">\(\ell^{\prime}(\theta)\)</span>的零点却不简单。</p><h3 id="基本思想">基本思想</h3><p>我们可以采用牛顿法来解决上述问题。假设我们求解的方程是<br><span class="math display">\[f(x) = 0\]</span><br>牛顿方法的基本过程是：</p><ol type="1"><li>随机挑选一个 x 值 ，设定一个终止误差值<span class="math inline">\(\varepsilon\)</span></li><li>找到<span class="math inline">\(f(x)\)</span> 在 x处的切线，该切线与 x 轴交于一点 m</li><li>当 <span class="math inline">\(|x - m| &lt; \varepsilon\)</span>时，结束迭代，反之令 x = m ，继续第2步...</li></ol><p>整个过程可以用下图来表示</p><p><img src="./7.png"></p><p>该过程可以形式化表示为<br><span class="math display">\[x := x - \frac{f(x)}{f^{\prime}(x)}\]</span><br>将牛顿法应用到求解<span class="math inline">\(\ell^{\prime}(\theta)\)</span>零点的问题上，则<span class="math inline">\(\theta\)</span>目标值的求解过程可以形式化的表示为<br><span class="math display">\[\theta := \theta -\frac{\ell^{\prime}(\theta)}{\ell^{\prime\prime}(\theta)} \\ \tt{(repeat\ until \ convergence)}\]</span><br>上述公式只是适用于<span class="math inline">\(\theta\)</span>是0维的时候。当<span class="math inline">\(\theta\)</span>为一个向量时，牛顿法可以扩展为<br><span class="math display">\[\theta := \theta - H^{-1} \nabla_{\theta}\ell(\theta)\]</span></p><p>其中<span class="math inline">\(H\)</span>表示Hession矩阵。这个方法也叫牛顿-拉普森法（Newton-Raphson）。</p><p>牛顿法具有二次收敛的特性，即每次迭代有效数字的位数加倍，因此和梯度下降相比有很高的迭代速度。但是，每次迭代的开销比梯度下降要高很多，因为要计算<span class="math inline">\(n \times n\)</span> 规模的 <span class="math inline">\(H\)</span> 矩阵。所以，牛顿法适用于参数量不是很大的情况（也就是<span class="math inline">\(\theta\)</span> 的分量数），参数量在 10~50之间比较适合。如果参数量比较大，梯度下降法比较适合。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CS229」Lecture2： 线性回归和梯度下降</title>
      <link href="/2023/06/23/ml/cs229-lecture2/"/>
      <url>/2023/06/23/ml/cs229-lecture2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线性回归">线性回归</h2><ul><li><p>线性回归是最简单的监督学习回归问题。监督学习的基本流程：</p><ol type="1"><li>测试数据集，包含一系列<span class="math inline">\((x,y)\)</span>对</li><li>数据输入到学习算法</li><li>输出一个函数<span class="math inline">\(h\)</span>，使得该函数可以很好地为输入的 x生成对应的 y</li><li>使用函数<span class="math inline">\(h\)</span>对其他数据进行预测</li></ol><p><img src="./1.png"></p></li><li><p>函数的表示<br><span class="math display">\[h = \theta_{1}x_1 + \theta_{2}x_2 + ... + \theta_nx_n + b =\sum_{j=0}^{n}\theta_i x_i\]</span><br>其中，<span class="math inline">\(x_0\)</span>始终为1。如果写成矩阵形式，即 <span class="math inline">\(\theta = \begin{bmatrix}\theta_0 \\ \theta_2 \\\vdots\end{bmatrix}, \ x = \begin{bmatrix}x_0 \\ x_1 \\ \vdots\end{bmatrix}\)</span> , 则上述公式可以写成:<br><span class="math display">\[h_\theta(x) = \theta^T x\]</span></p></li><li><p>常用符号</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\theta\)</span></td><td style="text-align: center;">参数</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(m\)</span></td><td style="text-align: center;">训练集的大小</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\)</span></td><td style="text-align: center;">输入 / 特征</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(y\)</span></td><td style="text-align: center;">输出 / 目标变量</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\((x^{(i)},y^{(i)})\)</span></td><td style="text-align: center;">训练集中第 i 个训练样本</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\((x,y)\)</span></td><td style="text-align: center;">训练集中某一个训练样本</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x_j^{(i)}\)</span></td><td style="text-align: center;">第 i 个训练样例的第 j 个特征</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n\)</span></td><td style="text-align: center;">特征数量</td></tr></tbody></table></li><li><p>参数的选择<br><span class="math display">\[\tt{choose} \ \theta \\ st. h(x) \approx y \ \ \ \tt{for \ every \training \ example}\]</span><br>对于线性回归问题，目标参数可以形式化的表示为<br><span class="math display">\[J(\theta) =  \frac{1}{2} \sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^2\\ \\\theta = \mathop{\arg\min}\limits_{\theta} \ J(\theta)\]</span><br><span class="math inline">\(J(x)\)</span>通常被称为<strong>成本函数</strong>，即 cost function.</p></li></ul><h2 id="批量梯度下降和随机梯度下降">批量梯度下降和随机梯度下降</h2><h3 id="批量梯度下降">批量梯度下降</h3><p><img src="./2.png"></p><ul><li>批量梯度下降形式化表示：<br><span class="math display">\[\theta_j := \theta_j - \alpha \frac{\partial \J(\theta)}{\partial\  \theta_j} \ \\ \tt{(repeat \ until \ convergence)}\]</span></li></ul><p>​ 其中，<span class="math inline">\(\alpha\)</span>表示学习率。对于线性回归来说，<span class="math inline">\(\frac{\partial \J(\theta)}{\partial\  \theta_j}\)</span>的计算如下所示：<br><span class="math display">\[\frac{\partial \ J(\theta)}{\partial\  \theta_j} = \sum_{i = 1}^m(h_\theta(x^{(i)}) - y^{(i)}) \ x_j^{(i)}\]</span><br>​因此，线性回归的梯度下降公式就可以表示为：<br><span class="math display">\[\theta_j := \theta_j - \alpha \sum_{i = 1}^m (h_\theta(x^{(i)}) -y^{(i)}) \ x_j^{(i)} \\ \tt{(repeat \ until \ convergence)}\]</span></p><ul><li>这里的“批“的意思是：每一次进行梯度下降更新参数时，都用到了一批数据参与运算。在上面的例子中，我们将训练集中所有的数据作为“一批”。每一次参数更新时，计算该批中每一条数据对应的“损失”，最终将所有的损失求和，其实也就是<span class="math inline">\(J(\theta)\)</span>。然后根据<span class="math inline">\(J(\theta)\)</span> 和公式$_j := _j - &nbsp;\ $对每个参数进行“一次“更新。</li></ul><h3 id="随机梯度下降">随机梯度下降</h3><p>对于每一条数据，即<span class="math inline">\((x^{(i)},y^{(i)})\)</span>，都进行一次梯度下降。此时梯度下降的过程就变为<br><span class="math display">\[\begin{aligned}&amp;\tt{repeat \ until \ convergence} \ \{ \\&amp;\qquad\tt{for \ \ i \ = \ 0 \ \ to \ \ m } \ \{  \\&amp;\qquad\qquad  \theta_j := \theta_j - \alpha\frac{(h_{\theta}(x^{(i)}) - y^{(i)})^2}{\theta_j} \\&amp;\qquad\} \\&amp;\}\end{aligned}\]</span><br>批量梯度下降法在进行一次迭代之前必须扫描整个训练集，如果m很大的话，计算开销非常高。而随机梯度下降法每次只针对一条数据进行梯度下降，因此能够更快地使<span class="math inline">\(\theta\)</span>“接近”最小值。但是需要注意的是，随机梯度下降可能永远不会“收敛”到最小值，并且参数<span class="math inline">\(\theta\)</span> 将在 <span class="math inline">\(\theta\)</span>的最小值周围振荡；但在实践中，大多数“接近最小值的值”就是对真实最小值的合理近似。</p><p>因此，通常更推荐使用随机梯度下降，尤其是数据集合规模较大的时候。</p><h2 id="正规方程">正规方程</h2><h3 id="基本形式">基本形式</h3><p>正规方程其实就是对上述的<span class="math inline">\(J(\theta)\)</span>求偏导、并令偏导数等于0得到的。因此他只适用于线性回归。<br><span class="math display">\[\theta = (X^TX)^{-1}X^TY \\ \\X = \begin{bmatrix} — \ (x^{(1)})^T \ — \\ — \ (x^{(2)})^T \ — \\ \vdots\\ — \  (x^{(m)})^T  —\end{bmatrix},\ \ \  Y = \begin{bmatrix}\ y^{(1)}\\ y^{(2)} \\ \vdots \\ y^{(m)}\end{bmatrix}\]</span></p><h3 id="推导">推导</h3><p>在推导之前我们需要用到以下公式：<br><span class="math display">\[\begin{aligned}\nabla_Atr AB &amp;= B^T \\\nabla_{A^T} f(A)&amp;= (\nabla_A f(A))^T \\\nabla_A tr ABA^TC &amp;= CAB + C^TAB^T \\\nabla_A |A| &amp;= |A|(A^{-1})^T\end{aligned}\]</span><br>下面就可以开始推导啦<br><span class="math display">\[\begin{aligned}\nabla_\theta J(\theta) &amp;= \nabla_\theta\frac{1}{2}(X\theta-Y)^T(X\theta-Y) \\&amp;= \frac{1}{2} \nabla_\theta(\theta^TX^T - Y^T)(X\theta - Y) \\&amp;= \frac{1}{2} \nabla_\theta(\theta^TX^TX\theta - \theta^TX^TY -Y^TX\theta + Y^TY) \\&amp;= \frac{1}{2} \nabla_\theta tr(\theta^TX^TX\theta - \theta^TX^TY -Y^TX\theta + Y^TY) \\&amp;= \frac{1}{2} \nabla_\theta (tr \theta^TX^TX\theta - 2 trY^TX\theta) \\&amp;= \frac{1}{2} (\nabla_\theta tr \theta^TX^TX\theta - 2\nabla_\theta tr Y^TX\theta) \\&amp;= \frac{1}{2} ((\nabla_{\theta^T} tr \theta^T(X^TX)\theta I)^T - 2\nabla_\theta tr Y^TX\theta) \\&amp;= \frac{1}{2} (X^TX\theta + X^TX\theta - 2 \nabla_\theta trY^TX\theta) \\&amp;= X^TX\theta - X^TY\end{aligned}\]</span><br>令 <span class="math inline">\(\nabla_\theta J(\theta) = 0\)</span>即可得到正规方程：<br><span class="math display">\[\theta = (X^TX)^{-1}X^TY\]</span></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CS229」 Lecture 1： 机器学习导引</title>
      <link href="/2023/06/21/ml/cs229-lecture1/"/>
      <url>/2023/06/21/ml/cs229-lecture1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="监督学习">监督学习</h2><p>监督学习：应用最广泛 。给定数据集——输入特征<span class="math inline">\(X\)</span>、输出标签<span class="math inline">\(Y\)</span>， 学习从<span class="math inline">\(X\)</span>到<span class="math inline">\(Y\)</span>的映射。</p><ul><li>回归(Regression)：需要预测的 Y 是连续的<ul><li>线性回归</li><li>多项式回归</li><li>......</li></ul></li><li>分类(Classification): 需要预测的 Y 是 离散的<ul><li>Logistic</li><li>支持向量机 (SVM)</li><li>高斯判别分析（GDA）</li><li>......</li></ul></li></ul><h2 id="深度学习">深度学习</h2><p>深度学习：通过构建多层神经网络来对数据进行学习和分析。与传统的机器学习方法相比，深度学习可以自动从数据中提取特征，并且具有更强大的模型表达能力。</p><ul><li>前馈神经网络（FNN）</li><li>卷积神经网络（CNN）</li><li>循环神经网络（RNN）</li><li>生成对抗网络（GAN）</li><li>......</li></ul><h2 id="无监督学习">无监督学习</h2><p>无监督学习：给定没有标签的数据集（即只有<span class="math inline">\(X\)</span>），要求从数据中找到interestingpattern，比如“<span class="math inline">\(X\)</span>大致可以分成几类“等等</p><ul><li>聚类(Clustering)</li><li>独立组件分析(ICA)</li><li>类比(Analogies)</li><li>......</li></ul><h2 id="强化学习">强化学习</h2><p>强化学习：让机器从环境中不断地试错，通过奖励和惩罚的方式（奖励信号），自动学习如何做出最优决策的一种方法。</p><ul><li>基于梯度</li><li>基于值函数</li><li>......</li></ul><h2 id="机器学习tips">机器学习Tips</h2><ul><li>运行学习算法时第一次通常不会起作用，调试机器学习算法会对效率产生极大的影响</li><li>不要专注于通过dive in代码本身去优化代码、让代码run的更快，更是应该借助profiler找出代码瓶颈，然后专注于对此进行更改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS229 </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Compile」SysY编译器设计</title>
      <link href="/2023/01/11/compile/compile-sysy-bian-yi-qi-she-ji/"/>
      <url>/2023/01/11/compile/compile-sysy-bian-yi-qi-she-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编译器总体设计">编译器总体设计</h2><h3 id="总体结构">总体结构</h3><p>本文描述的编译器是采用Java语言编写的MIPS编译器。该编译器分为前端，中端，后端三部分——</p><ul><li>前端：词法分析、语法分析、语义分析，最终将源程序生成为LLVM IR</li><li>中端：中间代码优化，包括mem2reg，GVN，图着色寄存器分配，死代码删除，常量计算</li><li>后端：目标代码生成，即将LLVM IR进一步翻译成MIPS代码</li></ul><h3 id="文件组织与接口">文件组织与接口</h3><p>编译器项目结构如下所示</p><pre class="line-numbers language-none"><code class="language-none">├─src│  ├─back_end       # 后端    │  │  └─mips  │  │      └─assembly│  ├─exception│  ├─front_end          # 前端│  │  ├─AST│  │  │  ├─Exp   │  │  │  ├─Func│  │  │  ├─Stmt│  │  │  └─Var│  │  ├─lexer│  │  ├─parser│  │  └─symbol│  ├─llvm_ir# LLVM IR定义│  │  ├─initial│  │  ├─instr│  │  └─type│  ├─mid_end            # 中端│  ├─utils              # 工具类│  └─Compliler.java     # 入口程序└─test                  # 测试文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从入口程序Complier.java中，我们可以看出不同部分之间的接口——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// token analyse</span><span class="token class-name">Lexer</span> lexer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lexer</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TokenStream</span> tokenStream <span class="token operator">=</span> lexer<span class="token punctuation">.</span><span class="token function">getTokenStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// syntax analyse</span><span class="token class-name">Parser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parser</span><span class="token punctuation">(</span>tokenStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Node</span> compUnit <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parseCompUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check error</span>compUnit<span class="token punctuation">.</span><span class="token function">checkError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Printer</span><span class="token punctuation">.</span><span class="token function">printAllErrorMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// generate IR</span><span class="token class-name">IRBuilder</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token class-name">IRBuilder</span><span class="token punctuation">.</span><span class="token constant">AUTO_INSERT_MODE</span><span class="token punctuation">;</span>compUnit<span class="token punctuation">.</span><span class="token function">genIR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Module</span> <span class="token keyword">module</span> <span class="token operator">=</span> <span class="token class-name">IRBuilder</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Printer</span><span class="token punctuation">.</span><span class="token function">printOriLLVM</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// optimize</span><span class="token class-name">IRBuilder</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token class-name">IRBuilder</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_MODE</span><span class="token punctuation">;</span><span class="token class-name">Optimizer</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">module</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// generate MIPS</span><span class="token keyword">module</span><span class="token punctuation">.</span><span class="token function">toAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AssemblyTable</span> assemblyTable <span class="token operator">=</span> <span class="token class-name">MipsBuilder</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAssemblyTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Printer</span><span class="token punctuation">.</span><span class="token function">printMIPS</span><span class="token punctuation">(</span>assemblyTable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大体流程是——</p><ul><li>Lexer类解析源程序，将源程序按照词法解析成一个个token，并封装成token流（TokenStream类）。</li><li>Parae类获取Lexer类解析出来的token流，按照文法规则构建抽象语法树（AST），构建完成后返回AST的根节点（compUnit）。</li><li>从AST根节点开始，自顶向下递归调用每个节点的checkError方法，进行错误检查。</li><li>从AST根节点开始，自顶向下递归调用每个节点的genIR方法，生成中间代码，并由IRBuilder返回封装好的LLVMIR顶层模块——module。（IRBuilder是一个单例模式类，统一管理中间代码的生成过程）。</li><li>将module传入Optimizer类,启动run方法，对module进行优化——mem2reg，GVN，图着色寄存器分配，死代码删除，常量计算，简单乘除优化(Optimizer是一个单例模式类，统一管理中间代码的优化过程)。</li><li>调用module类的toAssembly方法，自顶向下递归调用每个LLVM相关类的toAssemply的方法，进行中间代码生成，并由MipsBuilder返回封装好的mips指令列表assemblyTable。（MipsBuilder是一个单例模式类，统一管理中间代码的翻译过程）。</li></ul><h2 id="前端">前端</h2><h3 id="词法分析">词法分析</h3><p>词法分析主要由Lexer类实现。首先，我们将源文件转化为输入流（笔者采用的是可回退的输入流——PushbackInputStream），然后依次读取每个字符，按照下面的词法规则进行解析——</p><p><img src="./lexer.png"></p><p>每识别出一个token，我们就将其封装到下面的Token类中。其中TokenType为表示token类型的枚举类，value为token本身的名称，lineNumber是Token所在的行号（便于在错误处理时输出出错行号）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">TokenType</span> type<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> value<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> lineNumber<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当识别完所有的token后，我们将其封装成TokenStream类，便于后续语法分析的使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenStream</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Token</span><span class="token punctuation">&gt;</span></span> tokenList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> pos<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> watchPoint<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TokenStream</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Token</span><span class="token punctuation">&gt;</span></span> tokenList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tokenList <span class="token operator">=</span> tokenList<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>watchPoint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在识别的过程中，有下面几个细节需要注意——</p><ul><li>换行符在不同平台上的表示是不同的，Windows下为<code>\r + \n</code>，linux下为<code>\n</code>。为了保证编译器在不同平台上的可迁移性，我们需要对其进行特殊处理——无论是哪种表示，换行符中必定有<code>\n</code>，因此我们遇到<code>\r</code>时直接忽略即可，只以<code>\n</code>作为换行标志。</li><li>对于<code>!=, ==, &gt;, &gt;=, &lt;, &lt;=, =, ==, //, /, /*</code>，只读一个字符是无法进行判断的，需要向前多读一个字符。</li><li>标识符和关键字是无法通过预读进行区分的。我们可以先按照标识符的词法规则进行识别，然后再判断它是否和某个关键字相同。</li><li>Java采用Unicode编码，每个字符（char）是用两个字节表示的。由此，文件结束符应该表示为<code>\uFFFF</code>，这一点需要注意。</li></ul><h3 id="语法分析">语法分析</h3><p>语法分析主要由Parser类实现——Parser将词法分析阶段解析出来的token流作为自己的成员变量，然后按照文法规则对token流进行递归下降分析，同时构建出语法树。</p><h4 id="文法规则重构">文法规则重构</h4><p>为了便于语法分析以及后续阶段的处理，我们在这里对文法规则进行了一定的调整，和原文法相比有以下几点不同——</p><ul><li>删除Decl，BType，BlockItem这三个语法变量，精简文法。</li><li>将Stmt产生式改写为——<code>Stmt ==&gt; AssignStmt | ExpStmt | BlockStmt | IfStmt | WhileStmt | BreakStmt | CReturnStmt | GetIntStmt | PrintfStmt</code>，即为每一种Stmt创建一个语法变量，并添加新的产生式。在后面递归下降分析时，我们可以为每一种Stmt单独设置一个函数进行解析，这样可以防止出现超大型函数，便于后期调试。</li><li>将AddExp，MulExp，RelExp，EqExp，LAndExp，LOrExp改写为巴克斯范式，消除左递归，便于递归下降分析。</li></ul><h4 id="语法树相关类">语法树相关类</h4><p>我们为每一个语法变量都创建一个对应的语法树节点，并且都继承自基类Node。Node类的定义如下所示——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> startLine<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> endLine<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">SyntaxVarType</span> type<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> children<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>startLine和endLIne分别表示该“语法变量对应的字符串的开始行号和结束行号”，实际上就是对应token串中第一个token的lineNumber和最后一个token的lineNumber。</li><li>SyntaxVarType是表示语法变量类型的枚举类。</li><li>children表示该节点的子节点，用于形成树型结构。</li></ul><blockquote><p>文法规则中还有一些独立的token，他们直接出现在产生式的右侧。这些token同样是“所在产生式的语法变量”的children。因此，我们除了为每一个语法变量建立节点类，还要单独建立一个TokenNode类，表示由token构成的树节点。很显然，语法树的所有叶子节点都是TokenNode。</p></blockquote><p>因为我为每一个语法变量（包括Token）都单独建立了节点类，这样直接导致了类的数量爆炸。为了更好的管理（debug），我把建好的节点类按相关性大致分为4类，分别放在不同的文件夹内——</p><ul><li><strong>表达式相关</strong>：AddExp，CondExp，ConstExp，EqExp，Exp，LAndExp，LOrExp，LValExp，MulExp，Number，PrimaryExp，RelExp，UnaryExp，UnaryOp</li><li><strong>函数相关</strong>：FuncDef，FuncFormalParam，FuncFormalParams，FuncRealParams，FuncType，MainFuncDef</li><li><strong>语句相关</strong>：AssignStmt，BlockStmt，BreakStmt，ContinueStmt，ExpStmt，GetIntStmt，IfStmt，PrintfStmt，ReturnStmt，Stmt，WhileStmt</li><li><strong>变(常)量定义相关</strong>：Const</li><li>Decl，ConstDef，ConstInitVal，InitVal，VarDecl，VarDef</li><li><strong>其他</strong>：Block，CompUnit，TokenNode</li></ul><h4 id="递归下降分析">递归下降分析</h4><p>这一部分比较简单，直接为每一个语法变量编写一个parse函数即可。在编写程序时我做了统一约定——要求进入某个语法变量的分析子程序前，必须从token流中读取所要分析的语法成分的第一个token；而在分析子程序的出口前，读取下一个token，以便为进入下一个分析子程序做好准备。递归向下分析的整体结构如下所示——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">parseCompUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// if (...)</span>    <span class="token function">parseVarDecl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// if (...)</span>    <span class="token function">parseConstDecl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// if (...)</span>    <span class="token function">parseFuncDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// if (...)</span>    <span class="token function">parseMainFuncDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">parseVarDecl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">parseConstDecl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">parseFuncDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">parseMainFuncDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在解析Stmt的时候会出现一个问题——AssignStmt的产生式为<code>AssignStmt ==&gt; LVal '=' Exp ';'</code>，GetIntStmt的产生式为<code>GetIntStmt ==&gt; LVal '=' 'getint''('')'';'</code>，ExpStmt的产生式为<code>ExpStmt ==&gt; [Exp] ';'</code>。其中LVal和Exp是无法进行区分的，因此我们不能直接判断应该进入AssignStmt的分析子程序，还是进入GetIntStmt，还是进入ExpStmt的分析子程序。我采用的做法是——</p><ul><li>先设置一个“监视点”，即记录下当前token流的指针位置，然后用Exp的分析子程序进行解析；</li><li>解析完之后，如果发现后面的token为<code>=</code>，说明此时应该解析的语法成分为AssignStmt或者GetIntStmt。然后进一步看看后面的token是否是<code>getint</code>，进一步判断是AssignStmt还是GetIntStmt。最后，将token流的指针恢复到“监视点”的位置，并使用AssignStmt或GetIntStmt的分析子程序重新进行解析；</li><li>如果后面没有<code>=</code>，则说明应该解析的语法成分正好为ExpStmt，不需要回溯，继续往后解析即可。</li></ul><h3 id="错误处理">错误处理</h3><h4 id="总体架构">总体架构</h4><p>在这一阶段，我们需要处理两类错误——语法错误和语义错误</p><ul><li><p>对于和语法相关的错误，例如缺少分号，缺少小括号等等，我们可以直接在语法分析中顺带处理。注意，这里可能对原来递归下降的流程产生影响。因为可能会缺少一些必要的token，所以“判断是否进入某个递归子程序” 的逻辑需要进行调整。</p></li><li><p>对于其他和语义相关的错误，我们直接在Node类增加checkError这一方法，然后让继承它的各个节点类重写这一方法，处理各自可能出现的语义错误。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// for token nodes</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// for other nodes</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        child<span class="token punctuation">.</span><span class="token function">checkError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在入口程序中，可以直接调用语法树根节点的checkError方法，然后自顶向下调用各个children的checkError方法。</p></li></ul><h4 id="符号表">符号表</h4><p>处理语义错误，符号表是关键。笔者所使用的是“一次性”的栈式符号表。</p><h5 id="symbol">Symbol</h5><p>笔者创建了一个Symbol这一符号类，用于存储符号的基本信息。然后由该类派生出VarSymbol、ConstSymbol、FuncSymbol这些子类，用来存储不同类型符号的信息——</p><ul><li><strong>VarSymbol</strong>：变量名，变量值类型（int），变量维度，变量各维度的长度，变量初始值，是否为全局变量。</li><li><strong>ConstSymbol</strong>：常量名，常量值类型（int），常量维度，常量各维度的长度，常量初始值，是否为全局常量。</li><li><strong>FuncSymbol</strong>：函数名，函数返回值类型（int/void），函数各形参类型，函数各形参维度。</li></ul><blockquote><p>只有全局常量和全局变量的初始值才能够在编译阶段计算出，因此对于非全局的常量和变量，其“变量初始值”一项为null</p></blockquote><h5 id="symboltable">SymbolTable</h5><p>此外，笔者又创建了符号表类SymbolTable，每个SymbolTable实例用来存储“某个作用域产生的所有符号“。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SymbolTable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Symbol</span><span class="token punctuation">&gt;</span></span> symbols<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="symbolmanager">SymbolManager</h5><p>最后，为了方便管理符号的创建、插入、查找和删除，笔者创建了SymbolManager单例模式类——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SymbolManager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SymbolManager</span> <span class="token constant">MANAGER</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SymbolManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SymbolTable</span><span class="token punctuation">&gt;</span></span> symbolTables<span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Stack</span><span class="token punctuation">&lt;</span><span class="token class-name">SymbolTable</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> symbolNameMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">FuncSymbol</span> latestFunc<span class="token punctuation">;</span> <span class="token comment">// for check return sentence</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> loopDepth<span class="token punctuation">;</span> <span class="token comment">// for check continue and break</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isGlobal<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>symbolTable是由“各个作用域的符号表”组成的堆栈。在定义变量时，我们把变量对应的符号加入到栈顶符号表中；如果栈顶符号表中已有同名符号，则说明重复定义。</li><li>symbolNameMap是一个HashMap，key是符号名，value是所有“定义过该符号的符号表”组成的堆栈。在引用变量时，栈顶符号表中的同名符号就是该变量最新的定义，直接返回即可；如果栈为空，则说明该变量没有被定义。</li><li>lastestFunc是当前正在解析的函数所对应的符号，用与检查函数中是否出现不匹配的return语句。</li><li>loopDepth记录当前循环的嵌套层数，用于检查continue和break是否出现在非循环语句中。</li><li>isGlobal表示记录当前是否处于全局变量/常量定义阶段，用于判断生成的变量和常量是否具有编译期间就可以计算出的常量（主要在代码生成阶段使用）。</li></ul><p>SymbolManager是一个单例，因此每个节点在调用checkError方法时都能够很方便的访问它，为符号的增删查操作提供了极大便利。</p><h4 id="函数参数匹配问题">函数参数匹配问题</h4><p>在这次作业中，我们需要处理函数参数个数和维度匹配的问题。函数参数个数匹配比较简单，难的是函数维度的匹配（维度匹配包括维度个数的匹配、各维度长度的比较）。有些变量在定义时，纬度的长度不是简单的常数，而是用常量表达式（即ConstInitVal）来表示长度。因此，为了能够进行匹配，我们需要进行在编译时将该长度计算出来。笔者采用的方法是，给Exp、MulExp、AddExp等类都编写一个evaluate方法。在需要计算Exp的值时，即调用Exp的evaluate方法，在这个方法中又调用AddExp的evaluate……以此类推，最终Exp的evaluate返回的就是整个表达式的值。</p><h3 id="中间代码生成">中间代码生成</h3><h4 id="总体架构-1">总体架构</h4><p>笔者在Node类增加genIR这一方法，然后让继承它的各个节点类重写这一方法，生成各自对应的中间代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">genIR</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// for token nodes</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> child <span class="token operator">:</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        child<span class="token punctuation">.</span><span class="token function">genIR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在入口程序中，我们直接调用语法树根节点的genIR方法，然后就会自顶向下依次调用各个children的genIR方法，最终生成整个程序的中间代码。</p><h4 id="llvm-ir的内存形式">LLVM IR的内存形式</h4><p>LLVM中的核心观点就是“一切皆Value”——也就是说和LLVM相关的所有类继承了Value这一基类。</p><blockquote><p><code>Value</code> 是一个非常基础的基类，一个继承于<code>Value</code> 的子类表示它的结果可以被其他地方使用。 一个继承于<code>User</code> 的类表示它会使用一个或多个 <code>Value</code> 对象根据 <code>Value</code> 与 <code>User</code> 之间的关系，还可以引申出use-def 链和 def-use 链这两个概念。use-def 链是指被某个<code>User</code> 使用的 <code>Value</code> 列表，def-use 链是使用某个<code>Value</code> 的 <code>User</code> 列表。实际上，LLVM中还定义了一个 <code>Use</code> 类，<code>Use</code>就是上述的使用关系中的一个边。</p><p>​ ——来自软院编译实验指导书</p></blockquote><p>笔者在编程时也参考了这一观点，并参考LLVM原本的继承关系编写了User、Module、Function、Instr、Constant、Param、StringLiteral、UndefinedValue等类。</p><p><img src="./llvm_ir.png"></p><p>关键类的定义如下所示——</p><ul><li><p><strong>Module</strong>：整个顶层编译单元，由外部函数声明列表、字符串字面值列表、全局变量列表、函数列表组成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Module</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> declareList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">StringLiteral</span><span class="token punctuation">&gt;</span></span> stringLiterals<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GlobalVar</span><span class="token punctuation">&gt;</span></span> globalVarList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Function</span><span class="token punctuation">&gt;</span></span> functionList<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Function</strong>:全局函数定义，由参数列表、基本块列表、返回值类型组成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Function</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token comment">// 基本信息</span>    <span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Param</span><span class="token punctuation">&gt;</span></span> paramList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BasicBlock</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">BBList</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LLVMType</span> retType<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>BasicBlock</strong>:基本块，由指令列表，所属函数的指针组成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BasicBlock</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Instr</span><span class="token punctuation">&gt;</span></span> instrList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Function</span> parentFunction<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>User</strong>：可以使用其他Value的类，由操作数列表组成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span> operands<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Instr</strong>:LLVM指令，由指令类型，所属基本块指针组成。此外，我们还为每一种指令单独建立了类，都继承自Instr。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Instr</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> <span class="token class-name">InstrType</span> <span class="token punctuation">{</span>        <span class="token constant">ALU</span><span class="token punctuation">,</span>        <span class="token constant">ALLOCA</span><span class="token punctuation">,</span>        <span class="token constant">BRANCH</span><span class="token punctuation">,</span>        <span class="token constant">CALL</span><span class="token punctuation">,</span>        <span class="token constant">GEP</span><span class="token punctuation">,</span>        <span class="token constant">ICMP</span><span class="token punctuation">,</span>        <span class="token constant">JUMP</span><span class="token punctuation">,</span>        <span class="token constant">LOAD</span><span class="token punctuation">,</span>        <span class="token constant">RETURN</span><span class="token punctuation">,</span>        <span class="token constant">STORE</span><span class="token punctuation">,</span>        <span class="token constant">ZEXT</span><span class="token punctuation">,</span>        <span class="token constant">IO</span><span class="token punctuation">,</span>        <span class="token constant">PHI</span><span class="token punctuation">,</span>        <span class="token constant">PCOPY</span><span class="token punctuation">,</span>        <span class="token constant">MOVE</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">InstrType</span> instrType<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BasicBlock</span> parentBB<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="value的命名">Value的命名</h3><p>在LLVMIR中，每个Value都应该有名字，并且必须保证函数名不重复、同一函数中的基本块名不重复、统一基本块中的指令名不重复。IRBuilder是一个管理中间代码生成过程的单例模式类，我们可以用它来控制不同Value的命名。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IRBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">GLOBAL_VAR_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"@g"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">STRING_LITERAL_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"@s"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">LOCAL_VAR_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"%v"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PARAM_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"%a"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">BB_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">FUNC_NAME_PREFIX</span> <span class="token operator">=</span> <span class="token string">"@f_"</span><span class="token punctuation">;</span>    <span class="token comment">// class attributes</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> bbCnt<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> paramCnt<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Function</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> localVarCntMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> globalVarCnt<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> stringLiteralCnt<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Module</span> curModule<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Function</span> curFunction<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BasicBlock</span> curBB<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在IRBuilder类中定义了每种Value的前缀，然后用每种Value（除Function）用一个计数器记录已经命名的该类型Value的个数。当创建新的Value时，我们直接用“前缀+计数器值”为其命名。对于Function，我们用“前缀+原函数名进行命名”。</p><h3 id="类型系统">类型系统</h3><p>在LLVMIR中，每个Value都有特定的类型。笔者首先定义了LLVMType作为类型基类，然后定了ArrayType，PointerType，BaseType，OtherType继承它。</p><p><img src="./llvm_type.png"></p><ul><li><strong>BaseType</strong>：基础类型，包括INT1（i1），INT8（i8），INT32(i32)，VOID（void）。该类构造方法私有，上述类型都是已经建好的实例（相当于枚举）。</li><li><strong>ArrayType</strong>：数组类型，由元素类型和元素数量组成。</li><li><strong>PointerType</strong>：指针类型，由其指向的类型组成。</li><li><strong>OtherType</strong>：其他类型，包括函数类型，基本块类型，模块类型。该型构造方法私有，上述类型都是已经建好的实例（相当于枚举）。</li></ul><p>为了便于快速判断类型，防止大量出现<code>instance of</code>，我在基类LLVMType中提前设置好了若干判断方法，如isInt1、isArray，isPointer等等。</p><h2 id="中端">中端</h2><h3 id="mem2reg">mem2reg</h3><p>前端生成的LLVMIR并不是真正的SSA形式，而是把所有局部变量都变成了<code>alloca/load/store</code>形式。即用借用内存操作来满足LLVM本身SSA的限制，实际上是借助memory开了个后门。采用内存操作的特点是实现简单，便于调试，但是效率极低。因此，在保证前端生成的LLVM代码都是正确的前提下，mem2reg就成我们的不二之选。</p><blockquote><p>注意：我们只将非数组变量的操作变成SSA形式，数组变量仍然使用内存存取方式。</p></blockquote><p>mem2reg本质上就是在正确的位置上加入<span class="math inline">\(\phi\)</span>函数，也即是LLVM中的phi指令。实现mem2reg有两个步骤——</p><ul><li><p>插入phi</p></li><li><p>变量重命名</p></li></ul><h4 id="准备工作">准备工作</h4><p>在执行这两个步骤之前，我们需要根据基本块之间的跳转关系构建出控制流图、支配树，并计算出每个节点的支配边界。具体概念和算法可以参考<a href="https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html">软院编译实验指导书</a>。</p><h4 id="插入phi">插入phi</h4><p>只有在来自多个基本块的控制流汇合到一个基本块中时，才会出现同一个变量的多个不同定义。我们可以将该基本块称为汇合点。</p><p>如果某个变量在多个基本块中都有定义（在内存形式的LLVMIR中表现为——一个alloca出来的指针在多个基本块中有store操作），那么我们需要在这些基本块的汇合点添加和该变量相关的phi。实际上，汇合点可以用“定义该变量的所有基本块”的<a href="https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html">迭代支配边界</a>替代（前提是所有的变量都在入口基本块中被定义一次）。我们在准备工作阶段已经计算出来了每个基本块的支配边界，基本块的迭代支配边界可以在插入phi的过程中迭代地计算出来。</p><p>具体算法如下所示——</p><p><img src="./DF.png"></p><h4 id="变量重命名">变量重命名</h4><p>在上一阶段，我们已经在必要的基本块中插入了phi指令，但是该phi指令是空的，没有加入来自不同基本块的数据流信息（表现为<code>%4 = phi i32 [ ?, ? ], [ ?, ? ]</code>），并且相关<code>alloca</code>、<code>load</code>、<code>store</code>也没有被删除。在这一阶段，我们需要根据数据流补全phi指令，调整use-def关系，最后删除相关的访存指令。</p><p>具体思路是：前序遍历支配树，对于每个基本块，顺序遍历所有的指令——</p><ul><li>如果遇到了alloca指令，记录下alloca的指针名，为该指针建立一个空堆栈，并将该指令删除；</li><li>如果遇到了store指令，将需要写入内存的Value压入指针对应的堆栈，并将该指令删除；</li><li>如果遇到了load指令，那么将所有使用该load指令对应Value的指令，改为使用指针对应堆栈的栈顶Value，并将该指令删除；</li><li>如果遇到了phi指令，则将该指令对应的Value压入指针对应的堆栈。</li></ul><p>当我们扫描完某基本块所有指令后，需要再扫描一遍其在支配树中的子节点，将最新的数据流（也就是每个指针对应的栈顶Value）信息，写入子节点中的phi指令。最后为所有子节点调用该重命名函数，进行后续的遍历过程。</p><h3 id="gvn">GVN</h3><p>GVN又称为全局值标号，效果等同于常量传播、复写传播、消除全局和局部的公共子表达式。我们已经通过mem2reg将中间代码转化成了SSA形式，即所有的变量都只定义了一次，这为GVN的实现奠定了良好的基础。</p><p>GVN的基本思路是：为每一个运算相关的表达式指定一个hashcode，并将两者的映射关系存入到一个哈希表中。在进行某一次运算时，如果发现表达式对应的hashcode已经存在，说明该表达式以前被运算过。那么我们直接从哈希表中找到对应的已经计算好的Value即可，不需要进行重复计算。</p><p>GVN优化是以函数作为基本单位的（不同函数不存在公共表达式）。在对某一个函数执行GVN时，我们需要前序遍历其支配树，这样才能保证遍历到某一条指令时，其使用的各个变量都被前面的便利过程中被定义过。</p><p>此外，函数调用也是可以进行GVN优化的。但是，并不是所有的函数调用都可以进行优化——只有不操作全局变量、不调用其他函数、不进行IO的函数才能被优化掉。</p><h3 id="寄存器分配">寄存器分配</h3><p>我的编译器是以LLVMIR作为中间代码，对于每一条中间代码，都仅需两个临时寄存器即可翻译成对应的MIPS代码。在一般约定中，临时寄存器需要使用t0-t9如果把这些寄存器全部作为临时变量，只有其中两个可以真正被使用，显然是浪费的。又考虑到我们的编译器并没有真正的与操作系统交互，k0和k1寄存器实际上是没有被使用的，恰好可以满足笔者编译器临时变量的需要。因此，笔者使用k0-k1作为临时寄存器，而t0-t9,s0-s7都作为全局寄存器。此外，对于函数前四个参数，笔者为其分配了a0-a3寄存器，同时在栈中为其预留空间，满足MIPS约定。</p><p>对于临时寄存器，我们可以根据MIPS指令规则直接进行转化。例如中间代码<code>%v2 = add i32 1, 2</code>，我们可以将其翻译成下面的目标代码（优化前）——</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">li $k0, 1li $k1, 2addu $t0, $k0, $k1 # $t0表示分配给%v2的寄存器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于全局寄存器，笔者采用图着色的策略进行分配。但是实际上，笔者并没有真正的建立冲突图，根据活跃变量分析的结果判断某个变量所在的寄存器是否可以释放。具体思路是，活跃变量分析，计算基本块的in和out，然后前序遍历dom树——</p><ul><li>当遇到需要定义的变量时（也就是LLVMIR中%v*），我们为这个定义的变量分配寄存器。如果当前寄存器有剩余，那么我们可以在全局寄存器池中为其分配一个寄存器；否则随机释放一个寄存器。</li><li>在分配完当前基本块后，如果下一个基本块的 in没有这个变量，当前寄存器就可以先释放，在处理完下一个基本块后再恢复即可。处理完全部dom子节点后，再释放当前基本块“定义”的变量所占用的寄存器。</li></ul><p>上面的过程实际上是在中端优化中作为独立的一个pass完成的，其结果是得到“变量到全局寄存器的映射”（由HashMap存储，并保存到每一个Function中）。在后端翻译的时候，我们可以直接按照这个映射关系为全局变量分配寄存器。我们为func3执行分配全局寄存器的步骤后得到的映射关系如下所示——</p><h3 id="死代码删除">死代码删除</h3><p>死代码删除是指“通过活跃变量分析，找出所有只定义不使用的变量，将其定义点删除”。因为在寄存器分配阶段，我们已经获得了所有变量的def、use信息，在这一阶段我们只需要遍历一遍指令，将没有被使用的变量的定义点删除即可。</p><p>需要注意的是，并不是所有的“定义但不使用”变量都可以删除，有以下两种特殊情况——</p><ul><li>对于<code>%v1 = call i32 @f_fibo(i32 5)</code>等函数调用指令，即使%v1在后面都没有使用也不能贸然删除。因为被调用的函数可能将指针作为形参，或者修改了全局变量，或者调用了其他函数，如果删除可对其他部分的执行产生影响</li><li>对于<code>%v2 = call i32 (...) @getint()</code>等输入指令（在笔者设计中，IO和call不是一类指令），即使%2在后面没有被使用，我们也需要完成IO操作，因此也不能删除。</li></ul><h3 id="常量计算">常量计算</h3><p>对于两个常数的运算和比较，我们直接可以在编译阶段算出结果。此外，对于变量和常量之间的运算，我们也有如下优化策略——</p><ul><li><p><span class="math inline">\(a * 0 = 0\)</span></p></li><li><p><span class="math inline">\(a + 0 = a\)</span></p></li><li><p><span class="math inline">\(a - 0 = a\)</span></p></li><li><p><span class="math inline">\(0 \ / \ a = 0\)</span></p></li><li><p><span class="math inline">\(a\ /\ 1 = a\)</span></p></li><li><p><span class="math inline">\(a\ \%\ 1 = a\)</span></p></li></ul><h2 id="后端">后端</h2><h3 id="消除phi">消除Phi</h3><p>mem2reg后生成的phi指令是无法直接翻译的，我们需要将其变为一系列move指令，便于翻译。例如在b1基本块中有这样一条指令——<code>%v1 = phi i32 [ %v2, %b2 ], [ %v3, %b3 ]</code>，我们需要将其进一步变为<code>move $V1, $V2</code>和<code>move $v1, $v3</code>。</p><p>转化逻辑很简单，难的是生成的move指令应该如何放置。对于<code>move %v1, %v2</code>，我们需要考察%v2所在的基本块——b2的后继数量，进一步确定move的位置。</p><ul><li>如果b2只有b1一个后继，那么我们直接将该move指令放到b2结尾处即可</li><li>如果b2还有其他后继基本块，那么我们需要在b1-b2中新建一个基本块，然后将move指令放到新基本块中</li></ul><p>此外还需要注意，同一基本块中所有的phi指令都是并行赋值的，那么生成的若干move也应该满足并行赋值的特点。但是很不幸，直接生成move指令序列可能出现下面这种情况——</p><pre class="line-numbers language-none"><code class="language-none">move $v4, $v5move $v6, $v4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很显然，第二个move指令用到的是$v4的原始值，而不是通过第一条move指令赋值后的值。我们可以通过增加临时变量来解决这个问题——</p><pre class="line-numbers language-none"><code class="language-none">move $v4_temp, $v4move $v4, $v5move $v6, $v4_temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="内存管理">内存管理</h3><p>LLVM IR中的指令最多有两个操作数，这和mips是很相近的，因此每条LLVMIR指令都可以很方便的直接转化为MIPS形式。对于已经分配好寄存器的变量，我们可以直接将其翻译成对应的寄存器，而对于其他变量，我们只能将其放到内存中，使用的时候从内存中取。这就要涉及到内存管理了——</p><p>我采用的内存管理策略是：</p><ul><li><p>每个函数以<code>$sp</code>为栈底指针。在当前函数的作用域中，<code>$sp</code>的值不会随内存分配而变化。只有调用新函数前，才会将<code>$sp</code>的值变为新函数的栈底</p></li><li><p>首先在栈底为形参预留空间。在笔者的设计中，函数前3个形参保存在<code>$a1, $a2, $a3</code>中（<code>$a0</code>只用于IO），但是仍然在栈中为其预留空间。</p></li><li><p>局部变量依次放到上面的空间中。我们在MIPSBuilder这一单例模式类中记录每个局部变量的存放位置相对于栈底的偏移（因为栈从高地址向低地址增长的，所以偏移为负数），以及当前栈顶到栈底的总偏移量。</p><ul><li>每定义一个需要分配空间的变量时，总偏移量自减4，然后在MIPSBuilder中记录好该变量到该偏移量的映射关系。</li><li>当使用到某变量时，从MIPSBuilder中获取其偏移量，偏移量和$sp的值相加就是该变量在栈上的位置。</li></ul></li><li><p>在调用某个函数时，我们需要先保存当前已经分配的寄存器，然后将函数参数、$sp和$ra寄存器依次保存栈顶。最后，将$sp的值加上目前的总偏移量，作为被调用函数的栈底。接下来，直接jump到目标函数对应的lable即可。当函数返回时，我们还需要将上面保存的变量按照保存的顺序逆序进行恢复。</p></li></ul><h2 id="附录">附录</h2><h3 id="文法重构">文法重构</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">CompUnit  <span class="token operator">==</span><span class="token operator">&gt;</span>  <span class="token punctuation">{</span>VarDecl <span class="token operator">|</span> ConstDecl<span class="token punctuation">}</span> <span class="token punctuation">{</span>FUncDef<span class="token punctuation">}</span> MainFunDefConstDecl <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'const'</span> <span class="token char">'int'</span> ConstDef <span class="token punctuation">{</span> <span class="token char">','</span> ConstDef <span class="token punctuation">}</span> <span class="token char">';'</span>      <span class="token comment">//error i: 可能缺少分号</span>ConstDef <span class="token operator">==</span><span class="token operator">&gt;</span> Indent <span class="token punctuation">{</span><span class="token char">'['</span> ConstExp <span class="token char">']'</span><span class="token punctuation">}</span> <span class="token char">'='</span> ConstInitVal    <span class="token comment">//error b: 重复定义const变量； </span>    <span class="token comment">//error k: cosnt数组定义中缺少右中括号</span>ConstInitVal <span class="token operator">==</span><span class="token operator">&gt;</span> ConstExp <span class="token operator">|</span> <span class="token char">'{'</span> <span class="token punctuation">[</span>ConstInitVal <span class="token punctuation">{</span><span class="token char">','</span> ConstInitVal<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token char">'}'</span>VarDecl   <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'int'</span> VarDef <span class="token punctuation">{</span><span class="token char">','</span> VarDef<span class="token punctuation">}</span> <span class="token char">';'</span>    <span class="token comment">//error i: 可能缺少分号</span>VarDef  <span class="token operator">==</span><span class="token operator">&gt;</span>  Ident <span class="token punctuation">{</span><span class="token char">'['</span>  ConstExp  <span class="token char">']'</span><span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token char">'='</span>  InitVal<span class="token punctuation">]</span><span class="token comment">//error b: 重复定义变量； </span>    <span class="token comment">//error k: 数组定义中缺少右中括号</span>InitVal <span class="token operator">==</span><span class="token operator">&gt;</span>  Exp <span class="token operator">|</span> <span class="token char">'{'</span> <span class="token punctuation">[</span>InitVal <span class="token punctuation">{</span><span class="token char">','</span> InitVal<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token char">'}'</span>         FuncDef  <span class="token operator">==</span><span class="token operator">&gt;</span>  FuncType Ident <span class="token char">'('</span> <span class="token punctuation">[</span>FuncFormalParams<span class="token punctuation">]</span> <span class="token char">')'</span> Block    <span class="token comment">//error b: 重复定义函数</span>    <span class="token comment">//error g: 有返回值的函数最后一句缺少return</span>    <span class="token comment">//error j: 缺少右小括号</span>FuncType <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'void'</span> <span class="token operator">|</span> <span class="token char">'int'</span>MainFuncDef  <span class="token operator">==</span><span class="token operator">&gt;</span>  <span class="token char">'int'</span> <span class="token char">'main'</span> <span class="token char">'('</span>  <span class="token char">')'</span> Block    <span class="token comment">//error b: 重复定义函数</span>    <span class="token comment">//error g: 有返回值的函数最后一句缺少return</span>    <span class="token comment">//error j: 缺少右小括号</span>FuncFormalParams  <span class="token operator">==</span><span class="token operator">&gt;</span>  FuncFormalParam <span class="token punctuation">{</span><span class="token char">','</span> FuncFormalParam<span class="token punctuation">}</span>FuncFormalParam  <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'int'</span> Indent <span class="token punctuation">[</span><span class="token char">'['</span> <span class="token char">']'</span>  <span class="token punctuation">{</span><span class="token char">'['</span> ConstExp <span class="token char">']'</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token comment">//gerror b: 形参名重复定义</span>    <span class="token comment">//error k: 对于数组形参缺少右中括号</span>FuncRealParams → Exp <span class="token punctuation">{</span> <span class="token char">','</span> Exp <span class="token punctuation">}</span> Block <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'{'</span> <span class="token punctuation">{</span>VarDecl <span class="token operator">|</span> ConstDecl <span class="token operator">|</span> Stmt<span class="token punctuation">}</span> <span class="token char">'}'</span>           Stmt <span class="token operator">==</span><span class="token operator">&gt;</span> AssignStmt <span class="token operator">|</span> ExpStmt <span class="token operator">|</span> BlockStmt <span class="token operator">|</span> IfStmt <span class="token operator">|</span> WhileStmt <span class="token operator">|</span> BreakStmt <span class="token operator">|</span> CReturnStmt <span class="token operator">|</span> GetIntStmt <span class="token operator">|</span> PrintfStmtAssignStmt <span class="token operator">==</span><span class="token operator">&gt;</span> LVal <span class="token char">'='</span> Exp <span class="token char">';'</span>    <span class="token comment">//error h: LVal不可以是常量</span>    <span class="token comment">//error i: 可能缺少分号</span>ExpStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>Exp<span class="token punctuation">]</span> <span class="token char">';'</span>    <span class="token comment">//error i: 可能缺少分号</span>BlockStmt <span class="token operator">==</span><span class="token operator">&gt;</span> blockIfStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'if'</span> <span class="token char">'('</span> Cond <span class="token char">')'</span> Stmt <span class="token punctuation">[</span> <span class="token char">'else'</span> Stmt <span class="token punctuation">]</span>    <span class="token comment">//error j: 缺少右小括号</span>WhileStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'while'</span> <span class="token char">'('</span> Cond <span class="token char">')'</span> Stmt    <span class="token comment">//error j: 缺少右小括号</span>BreakStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'break'</span> <span class="token char">';'</span>    <span class="token comment">//error i: 可能缺少分号</span>    <span class="token comment">//error m: 循环中可能缺少break语句</span>ContinueStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'continue'</span> <span class="token char">';'</span>    <span class="token comment">//error i: 可能缺少分号</span>    <span class="token comment">//error m: 循环中可能缺少continue语句</span>ReturnStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'return'</span> <span class="token punctuation">[</span>Exp<span class="token punctuation">]</span> <span class="token char">';'</span>    <span class="token comment">//error f: 无返回值的函数有return exp</span>    <span class="token comment">//error i: 可能缺少分号</span>GetIntStmt <span class="token operator">==</span><span class="token operator">&gt;</span> LVal <span class="token char">'='</span> <span class="token char">'getint'</span><span class="token char">'('</span><span class="token char">')'</span><span class="token char">';'</span>    <span class="token comment">//error h: LVal不可以是常量</span>    <span class="token comment">//error i: 可能缺少分号</span>    <span class="token comment">//error j: 可能缺少右小括号</span>PrintfStmt <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'printf'</span><span class="token char">'('</span>FormatString<span class="token punctuation">{</span><span class="token char">','</span>Exp<span class="token punctuation">}</span><span class="token char">')'</span><span class="token char">';'</span>    <span class="token comment">//error i: 可能缺少分号</span>    <span class="token comment">//error j: 可能缺少右小括号</span>    <span class="token comment">//error l: 格式字符与表达式个数不匹配</span>            LValExp <span class="token operator">==</span><span class="token operator">&gt;</span> Ident <span class="token punctuation">{</span><span class="token char">'['</span> Exp <span class="token char">']'</span><span class="token punctuation">}</span><span class="token comment">//error c: 使用未定义的名字</span><span class="token comment">//error k: 缺少右中括号</span>PrimaryExp <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'('</span> Exp <span class="token char">')'</span> <span class="token operator">|</span> LValExp <span class="token operator">|</span> NumberUnaryExp <span class="token operator">==</span><span class="token operator">&gt;</span> PrimaryExp <span class="token operator">|</span> Ident <span class="token char">'('</span> <span class="token punctuation">[</span>FuncRealParams<span class="token punctuation">]</span> <span class="token char">')'</span> <span class="token operator">|</span> UnaryOp UnaryExp    <span class="token comment">//error c: 可能使用未定义的名字（函数调用中） </span>    <span class="token comment">//error d: 函数调用时形参和实参的个数不匹配</span>    <span class="token comment">//error e: 函数调用时参数类型不匹配</span>    <span class="token comment">//error j: 可能缺少右小括号</span>MulExp <span class="token operator">==</span><span class="token operator">&gt;</span> UnaryExp <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token char">'*'</span> <span class="token operator">|</span> <span class="token char">'/'</span> <span class="token operator">|</span> <span class="token char">'%'</span><span class="token punctuation">)</span> UnaryExp<span class="token punctuation">}</span>  <span class="token comment">//注意归约</span>AddExp <span class="token operator">==</span><span class="token operator">&gt;</span> MulExp <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token char">'+'</span> <span class="token operator">|</span> <span class="token char">'-'</span><span class="token punctuation">)</span> MulExp<span class="token punctuation">}</span> <span class="token comment">//注意归约</span>RelExp <span class="token operator">==</span><span class="token operator">&gt;</span> AddExp <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token char">'&lt;'</span> <span class="token operator">|</span> <span class="token char">'&gt;'</span> <span class="token operator">|</span> <span class="token char">'&lt;='</span> <span class="token operator">|</span> <span class="token char">'&gt;='</span><span class="token punctuation">)</span> AddExp<span class="token punctuation">}</span> <span class="token comment">//注意归约</span>EqExp <span class="token operator">==</span><span class="token operator">&gt;</span> RelExp <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token char">'=='</span> <span class="token operator">|</span> <span class="token char">'!='</span><span class="token punctuation">)</span> RelExp<span class="token punctuation">}</span> <span class="token comment">//注意归约</span>LAndExp <span class="token operator">==</span><span class="token operator">&gt;</span> EqExp <span class="token punctuation">{</span><span class="token char">'&amp;&amp;'</span> EqExp<span class="token punctuation">}</span> <span class="token comment">//注意归约</span>LOrExp <span class="token operator">==</span><span class="token operator">&gt;</span>  LAndExp <span class="token punctuation">{</span><span class="token char">'||'</span> LAndExp<span class="token punctuation">}</span> <span class="token comment">//注意归约</span>CondExp <span class="token operator">==</span><span class="token operator">&gt;</span> LorExpConstExp <span class="token operator">==</span><span class="token operator">&gt;</span> AddExpExp <span class="token operator">==</span><span class="token operator">&gt;</span> AddExp    UnaryOp <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'+'</span> <span class="token operator">|</span> <span class="token char">'-'</span> <span class="token operator">|</span> <span class="token char">'!'</span>Number <span class="token operator">==</span><span class="token operator">&gt;</span> IntConst<span class="token comment">//下面的语法单元不单独建类</span>FormatString <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token char">'"'</span><span class="token punctuation">{</span>Char<span class="token punctuation">}</span><span class="token char">'"'</span> <span class="token comment">//error a: 格式字符串中有非法字符</span>Char <span class="token operator">==</span><span class="token operator">&gt;</span> FormatChar <span class="token operator">|</span> NormalCharFormatChar <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token operator">%</span>dNormalChar <span class="token operator">==</span><span class="token operator">&gt;</span> 十进制编码为<span class="token number">32</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token operator">-</span><span class="token number">126</span>的ASCII字符，<span class="token char">'\'（编码92）出现当且仅当为'</span>\n'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考编译器">参考编译器</h3><ul><li><p>郭衍培学长的课设编译器：https://github.com/gyp2847399255/SysY-compiler</p></li><li><p>陈昊学长的课设编译器：https://github.com/Chenrt-ggx/MipsCompiler</p></li><li><p>毕昇杯“喵喵队仰卧起坐”队编译器：https://gitlab.eduxiji.net/educg-group-12619-928705/compiler2022-meowcompiler</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ruby」 Block的理解和使用</title>
      <link href="/2022/10/08/ruby/ruby-block-de-li-jie-he-shi-yong/"/>
      <url>/2022/10/08/ruby/ruby-block-de-li-jie-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Block是Ruby中比较重要的概念，也算是一块比较难啃的骨头。笔者在学Ruby基础的时候，碰到了很多关于块的“神奇操作“，但是在google上搜了很久也没有找到满意的答案（毕竟Ruby相对小众一点）。本想先跳过，在学完rails之后再补习ruby基础，没成想打开rails官方教程后，密密麻麻的全是块的操作...（晕）。于是不得不回来继续啃，特以此篇博客作为记录。</p><h2 id="proc和lambda">Proc和Lambda</h2><p>在理解Block之前，我们必须要清楚另一个概念——Proc。Proc实际上就是“一小段代码”，它在定义之后可以在其他地方被调用，在调用时也可以传入一些变量，这跟函数是很相似的。不过与函数不同的是，Proc对象必须通过<code>call</code>方法才能被调用。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 创建方式</span><span class="token comment"># 创建一般Proc</span>p <span class="token operator">=</span> <span class="token class-name">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>p <span class="token operator">=</span> proc <span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment"># 创建lambda类型的Proc</span>p <span class="token operator">=</span> <span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>p <span class="token operator">=</span> lambda <span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment"># 调用方式</span>p<span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>lambda是一种特殊的Proc，它和普通Proc有以下两点区别——<br>-lambda在调用时会检查参数的个数。如果传入的参数太多或太少，都会抛出<code>ArgumentError</code>异常。而普通Proc不会对参数个数进行检查。<br>-lambda可以使用return返回某个对象，其行为和函数很相似。但是普通Proc不可以使用return，否则会抛出<code>LocalJumpError</code>异常。<p></p><blockquote><p>Q: 如何判断一个Proc对象是lambda还是普通Proc?<br>A: 只需要puts一下该对象即可。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">puts proc <span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment"># 输出#&lt;Proc:0x00005635d72eb518 /home/hyggge/Desktop/test.rb:1&gt;</span>puts lambda <span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment"># 输出#&lt;Proc:0x00005635d72eb310 /home/hyggge/Desktop/test.rb:2 (lambda)&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></blockquote><h2 id="block">Block</h2><h3 id="隐式传递">隐式传递</h3><p>Block实际上就是一种特殊的Proc，但是它不能独立存在，不能被保存（一次性的，不能赋值给某个变量），只能与函数结合来使用。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">func</span></span>    <span class="token keyword">yield</span> <span class="token string-literal"><span class="token string">'hyggge'</span></span><span class="token keyword">end</span>func <span class="token punctuation">{</span><span class="token operator">|</span>name<span class="token operator">|</span> puts <span class="token string-literal"><span class="token string">"hello </span><span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token content">name</span><span class="token delimiter punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在这里，我们可以把Block理解成传给函数一个“特殊实参”，不过这种传递是一种“隐式传递”，因为函数不需要设置对应的形参。要想在函数里调用这个Block，我们只需使用<code>yield</code>关键字即可。感觉很像在C语言中把一个函数的指针传递给另一个函数——<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">block</span><span class="token punctuation">(</span><span class="token string">"hyggge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello %s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">func</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="显式传递">显式传递</h3><p>当然，我们也可以在函数的定义中增加一个形参，该形参用于接收要将要传入的块，这种传递就是“显式传递”。需要注意的是，这个特殊形参的前面需要加一个前缀<code>&amp;</code>。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">func</span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>call <span class="token string-literal"><span class="token string">'hyggge'</span></span>    <span class="token keyword">yield</span> <span class="token string-literal"><span class="token string">'hyggge'</span></span><span class="token keyword">end</span>func <span class="token punctuation">{</span><span class="token operator">|</span>name<span class="token operator">|</span> puts <span class="token string-literal"><span class="token string">"hello </span><span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token content">name</span><span class="token delimiter punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此时，我们既可以用yield关键字来调用块，也可以通过形参p的call方法来调用。<p></p><h2 id="的使用">&amp;的使用</h2><p>在不同的上下文环境下，&amp;的作用和意义也不甚相同，在这里我们只介绍&amp;和Block、Proc相关的一些用法。</p><h3 id="作用于block">&amp;作用于Block</h3><p>当&amp;作用于Block时，会将Block转化为普通Proc，这其实就是“显式传递”背后的原理。</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">func</span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>call <span class="token string-literal"><span class="token string">'hyggge'</span></span>    puts p <span class="token comment"># 输出&lt;Proc:0x000055987014f0b0 /home/hyggge/Desktop/test.rb:6&gt;</span><span class="token keyword">end</span>func <span class="token punctuation">{</span><span class="token operator">|</span>name<span class="token operator">|</span> puts <span class="token string-literal"><span class="token string">"hello </span><span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token content">name</span><span class="token delimiter punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作用于proc">&amp;作用于Proc</h3><p>如果&amp;作用于Proc（包括普通Proc和lambda），那么它就会将这个Proc转换成一个Block。因为Block是不能独立存在的，所以<code>&amp;proc</code>必须结合函数来使用。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">func</span></span>    <span class="token keyword">yield</span> <span class="token string-literal"><span class="token string">'hyggge'</span></span><span class="token keyword">end</span>p <span class="token operator">=</span> proc <span class="token punctuation">{</span><span class="token operator">|</span>name<span class="token operator">|</span> puts <span class="token string-literal"><span class="token string">"hello </span><span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token content">name</span><span class="token delimiter punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">}</span>func<span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="作用于非proc对象">&amp;作用于非Proc对象</h3><p>如果&amp;作用于非Proc对象（例如Symbol、Hash等等），它会先调用该对象的<code>to_proc</code>方法将该对象转换成Proc，然后再将其转化成一个Block。同样，这个用法也需要结合函数来使用。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">func</span></span>    puts <span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">end</span>hash <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span> <span class="token operator">=&gt;</span> <span class="token string-literal"><span class="token string">'a'</span></span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">=&gt;</span> <span class="token string-literal"><span class="token string">'b'</span></span><span class="token punctuation">}</span>func<span class="token punctuation">(</span><span class="token operator">&amp;</span>hash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>下面重点讨论一下&amp;作用于Symbol的情形。我们经常看到这样的代码——<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token symbol">:to_i</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>通过上面的讲解我们知道，这里的<code>:to_i</code>首先通过自身的<code>to_proc</code>方法转换成一个Proc对象，然后再转换成一个Block，最后被传入<code>map</code>函数。但问题是，<code>to_proc</code>是如何将<code>:to_i</code>转化成一个Proc的呢？<p></p><p>假设<code>:obj</code>是我们研究的Symbol对象，那么<code>:obj.to_proc</code>的返回值可以理解为<code>proc{|x| x.obj()}</code>，这是一种比较直接的理解方式。但是，如果调用者向这个Proc传入的参数(对象)x中没有<code>obj()</code>这样一个成员方法该怎么办呢？换句话说，对象x怎么检查自己有没有obj()这个方法的？</p><p>实际上，<code>:obj</code>的to_proc的返回值应该理解为<code>{ |x| x.send(:obj) }</code>。调用send方法时，相当于外界给对象x传入了一个信息，信息的内容是<code>:obj</code>（当然也可以时字符串），如果send方法发现x中有一个和<code>:obj</code>同名的方法，那么这个方法就会接着被调用。</p>]]></content>
      
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ruby」Case Equality</title>
      <link href="/2022/09/06/ruby/ruby-case-equality/"/>
      <url>/2022/09/06/ruby/ruby-case-equality/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>当笔者第一次看到<code>===</code>时，便想当然的认为这与JavaScript中<code>===</code>的用法相同，即“同时比较数据类型和数值”。为了验证这个猜想，我在irb中做了以下测试</p><p><img src="lab2_pic1.png"></p><p><code>1.0</code>是浮点类型，而<code>1</code>是整数类型，但是<code>1===1.0</code>的结果却是true。很显然，我一开始的猜想是不正确的。</p><p>随后通过查阅资料得知，当比较两个相同类型的对象时，<code>===</code>的用法和 <code>==</code>相同；但是在其他情况下，尤其是比较两个不同类型的对象时，<code>===</code>的用法会随着对象类型的不同而不同。尽管这些用法看上去眼花缭乱，但是仔细想想会发现它们有着异曲同之妙...<br><!-- 同时，在编程的过程中如果适当的运用===运算符号，会让自己的代码变得更加简洁和优雅。 --></p><h2 id="相同类型对象比较">相同类型对象比较</h2><p>当我们在比较数字、比较字符串或者比较其他大多数类型的对象时，可以将<code>===</code>当做<code>==</code>来使用——<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 比较数字</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>puts a <span class="token operator">===</span> b            <span class="token comment"># output: true</span><span class="token comment"># 比较字符串</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"hello"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"world"</span></span>puts a <span class="token operator">===</span> b            <span class="token comment"># output: false</span><span class="token comment"># 比较数组</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>puts a <span class="token operator">==</span> b             <span class="token comment"># output: false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>不过这种用法不常见，毕竟能写<code>==</code>为什么要大费周章地写<code>===</code>呢？</p><h2 id="不同类型对象比较">不同类型对象比较</h2><p>当我们比较两个不同类型的对象时，<code>===</code>的用法便随着对象类型的不同而不同了——</p><ul><li><p>当左侧是整数，右侧是浮点数，如果两数的值相等，则表达式会返回true，否则返回false(其实就是引言中的例子)。此时，<code>===</code>相当于<code>==</code>。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token number">1</span> <span class="token operator">===</span> <span class="token number">1.0</span>               <span class="token comment"># output: true</span><span class="token number">6.0</span> <span class="token operator">===</span> <span class="token number">6</span>              <span class="token comment"># output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li><li><p>当左侧是类名，右侧是某个对象时，如果该对象是左侧的类的实例，则表达式会返回true，否则返回false。此时，<code>===</code>相当于 <code>is_a?</code>。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token builtin">String</span> <span class="token operator">===</span> <span class="token string-literal"><span class="token string">"hyggge"</span></span>     <span class="token comment"># output: true</span><span class="token builtin">Range</span> <span class="token operator">===</span> <span class="token punctuation">(</span><span class="token number">1.</span><span class="token number">.2</span><span class="token punctuation">)</span>        <span class="token comment"># output: true</span><span class="token builtin">Array</span> <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>     <span class="token comment"># output: true</span><span class="token builtin">Integer</span> <span class="token operator">===</span> <span class="token number">2</span>           <span class="token comment"># output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>当左侧是范围，右侧是某个值时，如果该值落在左侧的范围中，则表达式会返回true，否则返回false。此时，<code>===</code> 相当于<code>include?</code>。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token punctuation">(</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token number">.5</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">2</span>           <span class="token comment"># output: true</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token operator">...</span><span class="token string-literal"><span class="token string">"g"</span></span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string-literal"><span class="token string">"c"</span></span>     <span class="token comment"># output: true </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li><li><p>当左侧是正则表达式，右侧是某个字符串对象时，如果该字符串能够匹配上左侧的正则表达式，则会返回true，否则返回false。此时，<code>===</code>相当于 <code>=~</code>。<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">[</span><span class="token constant">A</span><span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token operator">*</span>$<span class="token operator">/</span> <span class="token operator">===</span> <span class="token string-literal"><span class="token string">"HELLO"</span></span>  <span class="token comment"># output：true</span><span class="token operator">/</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">/</span> <span class="token operator">===</span> <span class="token string-literal"><span class="token string">"12"</span></span>       <span class="token comment"># output：true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li></ul><h2 id="内在联系">内在联系</h2><p>以上各个用法看上去不尽相同，但它们之间实际上是有一定联系的。在StackOverflow上有人这样描述[1]——</p><blockquote><p>The best way to describe a === b is "if I have a drawer labeled a,does it make sense to put b in it?"</p></blockquote><p>也就是说，我们可以<code>===</code>的左边看做一个容器，如果<code>===</code>右边的对象放在该容器中有意义，那么整个表达式的返回值就是true,否则就返回false。</p><p><strong>对于两个不同的对象来说，这种判断方式是很显然的。</strong>以<code>String === "hyggge"</code>为例，<code>"hyggge"</code>是一个字符串对象，是<code>String</code>类的一个实例，如果我们把<code>===</code>左边的<code>String</code>看做所有字符串对象组成的集合，<code>"hyggge"</code>放在这个集合中显然是有意义的，因此返回值是true。再以<code>(1..5) === 3</code>为例，<code>3</code>是一个整数，而范围<code>(1..5)</code>可以看做一个集合<span class="math inline">\(\{1,2,3,4,5\}\)</span>，很显然<code>1</code>在这个集合中。</p><p><strong>对于两个相同的对象来说，这种判断方式仍然是成立的。</strong>以<code>[1, 2, 3] === [1, 2, 3]</code>为例，<code>===</code>两边都是数组对象，但此时我们仍可以将<code>===</code>左边看成一个集合，只不过这个集合只有一个元素，即<span class="math inline">\(\{[1, 2, 3]\}\)</span>,<code>===</code>右边的<code>[1, 2, 3]</code>显然也是在这个集合中的，因此返回true也就不足为奇了。</p><p>[1]参考http://stackoverflow.com/a/3422349/1772</p><h2 id="与-casewhen语句">=== 与 case/when语句</h2><p>===运算符也被用在case/when语句的底层实现中，这也是它最为常见的用途。以下面的case/when语句为例<br></p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">case</span> input    <span class="token keyword">when</span> <span class="token number">1</span>          <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"1"</span></span>    <span class="token keyword">when</span> <span class="token string-literal"><span class="token string">"hyggge"</span></span>   <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"\"hyggge\""</span></span>    <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token number">10.</span><span class="token number">.20</span><span class="token punctuation">)</span>   <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"10..20"</span></span>    <span class="token keyword">when</span> <span class="token builtin">Array</span>      <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"Array"</span></span>    <span class="token keyword">when</span> <span class="token operator">/</span>regex<span class="token operator">/</span>    <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"/regex/"</span></span>    <span class="token keyword">else</span> puts <span class="token string-literal"><span class="token string">"other"</span></span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上述代码等价于——<br><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">if</span>           <span class="token number">1</span> <span class="token operator">===</span> input <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"1"</span></span><span class="token keyword">elsif</span> <span class="token string-literal"><span class="token string">"hyggge"</span></span> <span class="token operator">===</span> input <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"\"hyggge\""</span></span><span class="token keyword">elsif</span> <span class="token punctuation">(</span><span class="token number">10.</span><span class="token number">.20</span><span class="token punctuation">)</span> <span class="token operator">===</span> input <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"10..20"</span></span><span class="token keyword">elsif</span>    <span class="token builtin">Array</span> <span class="token operator">===</span> input <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"Array"</span></span><span class="token keyword">elsif</span>  <span class="token operator">/</span>regex<span class="token operator">/</span> <span class="token operator">===</span> input <span class="token keyword">then</span> puts <span class="token string-literal"><span class="token string">"/regex/"</span></span><span class="token keyword">else</span> puts <span class="token string-literal"><span class="token string">"other"</span></span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」 Shell中的特殊符号</title>
      <link href="/2022/07/25/linux/shell-bash-zhong-de-te-shu-fu-hao/"/>
      <url>/2022/07/25/linux/shell-bash-zhong-de-te-shu-fu-hao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Shell中有一系列诸如<code>${ }</code>,<code>$[ ]</code>,<code>$( )</code>,<code>[[ ]]</code>这样的特殊符号，它们长相相似但用法却大相径庭，非常容易混淆。笔者在写Shell脚本时也经常将它们的用法弄混，因此特地整理在此，以便日后查阅。</p><h2 id="的用法">$ 的用法</h2><p>在写Shell脚本时，我们经常会定义一些变量。如果想要获取变量的值，则需要使用<code>${变量名}</code>。当然，<code>$变量名</code>也是可以的，不过${}能够明确变量的边界，可以防止在字符串拼接时出现问题。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">var2</span><span class="token operator">=</span><span class="token number">200</span><span class="token builtin class-name">echo</span> <span class="token variable">${var1}</span><span class="token builtin class-name">echo</span> <span class="token variable">$var2</span>------------------------ 运行结果 ------------------------<span class="token number">100</span><span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="和">$( ) 和 ` `</h2><p><code>$( )</code>和<code>&lt;code&gt;</code>``<code>&lt;/code&gt;</code>都用做<strong>命令替换</strong>，能够返回某个命令的运行结果。当我们使用这两个符号运行某个命令时，实际上就是在当前Shell中fork出一个子Shell，并在子Shell中运行命令，并将结果返回给父Shell。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>------------------------ 运行结果 ------------------------<span class="token number">2022</span>年 07月 <span class="token number">25</span>日 星期一 <span class="token number">22</span>:06:03 CST<span class="token number">2022</span>年 07月 <span class="token number">25</span>日 星期一 <span class="token number">22</span>:06:03 CST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="和-1">( ) 和 { }</h2><p><code>( )</code>和<code>{ }</code>作用相似，都是将括号中的所有命令作为一个命令组来顺序执行（括号中不同命令之间需要用分号<code>;</code>来分隔）。但是，二者又有下面几点区别——</p><ul><li><code>( )</code>内部各个命令和左右括号之间不必有空格，而<code>{ }</code>中第一个命令和左括号之间必须要有一个空格。</li><li><code>( )</code>最后一条指令后面可以没有 <code>;</code>，而<code>{ }</code>最后一条指令后面必须有 <code>;</code></li><li><code>( )</code>中的命令会在新开的一个Shell中运行，而<code>{ }</code>的命令是在当前Shell中运行。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token punctuation">(</span>echo <span class="token parameter variable">-n</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">" Hyggge"</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">"World"</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>------------------------ 运行结果 ------------------------Hello HygggeHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="和-test">[ ] 和 test</h2><p><code>[ ]</code>和<code>test</code>命令用法相同，都是用来测试“某个条件是否成立”。<strong>如果成立则返回0（真），否则返回非0值（假）</strong>。<code>test</code>命令的语法格式为<code>test &lt;条件&gt;</code>，若使用 <code>[ ]</code>则应该写做<code>[&lt;条件&gt;]</code>。两者通常需要结合<code>if</code>一起使用</p><p>“测试条件”中支持以下几种表示判断或者关系的运算符——</p><ul><li><strong>测试文件</strong>： -e, -f, -d, -r, -w, -x等</li><li><strong>字符串比较</strong>： =, !=, -z, -n, $</li><li><strong>数值比较</strong>： ==, ！=, -eq, -ne, -gt, -lt, -ge,-le</li><li><strong>布尔运算</strong>： !, -o, -a</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">200</span><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$a</span> <span class="token parameter variable">-lt</span> <span class="token variable">$b</span><span class="token punctuation">;</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"a &lt; b!"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$b</span> <span class="token parameter variable">-gt</span> <span class="token variable">$a</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"b &gt; a!"</span><span class="token keyword">fi</span>------------------------ 运行结果 ------------------------a <span class="token operator">&lt;</span> b<span class="token operator">!</span>b <span class="token operator">&gt;</span> a<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>需要注意的是</strong>，在使用<code>[ ]</code>时，左右括号和条件之间必须留有空格。</p></blockquote><h2 id="的用法-1">[[ ]] 的用法</h2><p><code>[[ ]]</code>可以看做增强版的<code>[ ]</code>，除了可以使用上面提到的运算符，还可以使用<code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>,<code>&gt;</code>，更加符合我们使用C语言的习惯。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token number">4</span> <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"yes!"</span><span class="token keyword">fi</span>------------------------ 运行结果 ------------------------yes<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="let-和-expr">$(( )), $[ ], let 和 expr</h2><p><code>$(( ))</code>, <code>$[ ]</code>, <code>let</code>,<code>expr</code>都可以用于数值的运算。</p><ul><li><p><code>$(( ))</code>的括号中可以使用任何符合C语言语法的表达式，如果括号中的是数值运算表达式，则返回运算结果；如果括号中是逻辑判断表达式，则返回1或者0（1表示真，0表示假，与退出状态码相反）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">200</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>a <span class="token operator">+</span> b<span class="token variable">))</span></span> <span class="token comment"># c=$(($a + $b))</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>a <span class="token operator">+</span> b <span class="token operator">==</span> c<span class="token variable">))</span></span>------------------------ 运行结果 ------------------------<span class="token number">300</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果<code>(( ))</code>单独使用，则只能用于括号内表达式的运算，而不能将表达式的运算结果返回。此外，<code>(( ))</code>也经常在<code>for</code>循环中使用，用于循环控制，类似C语言。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">200</span><span class="token variable"><span class="token punctuation">((</span>c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">))</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token function">sum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token variable"><span class="token punctuation">((</span>sum <span class="token operator">+=</span> i<span class="token punctuation">))</span></span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token variable">$sum</span>------------------------ 运行结果 ------------------------<span class="token number">300</span><span class="token number">4950</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>$[ ]</code>用法和<code>$(( ))</code>基本相同，同样支持任何符合C语言语法的表达式。</p></li><li><p><code>expr</code>命令只能用于"数值运算"（例如<code>expr b + c</code>），不能用作"变量赋值"（例如<code>expr a = b + c</code>）。该命令除了能够进行数学运算时，还可与进行字符串比较、字符串匹配、字符串提取、字符串长度计算等功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">200</span><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span>------------------------ 运行结果 ------------------------<span class="token number">300</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>let</code>命令可以和<code>(( ))</code>进行互换，同样只能进行表达式的运算，而不能将运算结果返回。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">100</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">200</span><span class="token builtin class-name">let</span> <span class="token assign-left variable">c</span><span class="token operator">=</span>a+b<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token builtin class-name">let</span> <span class="token string">"c = a - b"</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span>------------------------ 运行结果 ------------------------<span class="token number">300</span><span class="token parameter variable">-100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>需要特别注意以下几点：</strong></p><ul><li>在使用 <code>$(( ))</code>、<code>$[ ]</code>和<code>let</code>时，直接通过变量名即可获得变量所代表的值，不需要使用<code>${ }</code>。</li><li>在使用 <code>$(( ))</code>和<code>$[ ]</code>时，括号中表达式的任意位置都可以有空格；对于<code>expr</code>命令，运算符两边必须有空格；对于<code>let</code>命令，表达式必须紧凑，不能含有空格，但是如果非要在表达式中加空格，则必须将整个表达式用引号引起来。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Git」Little Tips</title>
      <link href="/2022/07/06/git/git-little-tips/"/>
      <url>/2022/07/06/git/git-little-tips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Git中还有很多实用并且常用的小技巧，适当的使用可以提高我们的工作效率。但因为这些Tips比较琐碎，没法将它们归档到特定的主题下，于是我便整理到这里了——</strong></p><hr><h3 id="git-commit-选项">git commit 选项</h3><ul><li><code>git commit -a</code>指令可以自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code> 步骤。</li></ul><hr><h3 id="git-status-选项">git status 选项</h3><ul><li><code>git status</code>命令的输出十分详细，但其用语有些繁琐。但是如果使用 <code>git status -s</code> 命令或<code>git status --short</code>命令，我们将得到一种格式更为紧凑的输出</li></ul><hr><h3 id="git-log-选项">git log 选项</h3><ul><li><code>git log --patch</code>：也可以简写成<code>-p</code>，它会显示每次提交所引入的差异（按补丁 的格式输出）。 我们也可以限制显示的日志条目数量，例如使用<code>-2</code> 选项来只显示最近的两次提交。</li><li><code>git log --stat</code>：显示每次提交的简略统计信息，包括有几个文件修改、有几个文件删除等等。</li><li><code>git log --pretty</code>：这个选项可以使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用，比如<code>git log --pretty=oneline</code>会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有<code>short</code>，<code>full</code> 和 <code>fuller</code>选项，它们展示信息的格式基本一致，但是详尽程度不一。</li><li><code>git log --graph</code>：可以在日志旁以 ASCII图形显示分支与合并历史</li><li><code>git log --no-merges</code>：过滤掉"合并提交"的记录</li><li><code>git log --merges</code>：之查看合并提交记录</li></ul><hr><h3 id="git-别名">git 别名</h3><p>如果不想每次都输入完整的 Git 命令，可以通过 git config文件来轻松地为每一个命令设置一个别名。格式如下<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.<span class="token operator">&lt;</span>别名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>原名<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>例如，在团队开发时我们经常要查看<strong>分支图</strong>，查看分支图的命令为<code>git log --oneline --graph --all</code>，但是每次都输入这么长的指令实在是太麻烦了，因此我们可以为其取一个别名——<p></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.graph <span class="token string">'log --oneline --graph --all'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样我们只需要输入<code>git graph</code>就可以查看分支图了。</p><hr><h3 id="查看已经合并">查看已经合并</h3><ul><li><code>git branch --merged</code>：查看哪些分支已经合并到当前分支</li><li><code>git branch --no-merged</code>：查看所有包含未合并工作的分支</li><li><code>git branch --merged master</code>：查看尚未合并到 master的分支</li></ul><hr><h3 id="公共祖先">公共祖先</h3><p>在决定是否将两个分支合并前，我们可能需要先寻找两个分支的共同祖先，然后比较这个共同祖先和某一个分支的difference，最后在决定是否合并。</p><p>为进行这样的比较，我们可以采用下面三种方式——</p><ul><li>先通过命令<code>git merge-base &lt;branch1&gt; &lt;branch2&gt;</code>获得commit_id，再使用<code>git diff &lt;commit_id&gt;</code></li><li>直接使用<code>git diff $(git merge-base &lt;branch1&gt; &lt;branch2&gt;)</code></li><li>使用三点语法——<code>git diff &lt;branch1&gt;...&lt;branch2&gt;</code>，结果是<strong><code>branch2</code>的最新提交</strong> 和<strong>公共祖先</strong> 之间差异。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Git」stash命令</title>
      <link href="/2022/07/06/git/git-stash-ming-ling/"/>
      <url>/2022/07/06/git/git-stash-ming-ling/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="stash命令">stash命令</h2><p>假设我们正在分支<code>dev</code>上工作，干着干着突然被要求在<code>master</code>分支上解决一个问题。但是此时我们在<code>dev</code>上的工作还没完成，没法commit到本地版本库，如果所以我们现在应该怎么做呢？</p><p>这就需要<code>stash</code>出场了——<strong><code>stash</code>可以把当前<code>dev</code>的工作现场保存起来</strong>，等到解决完<code>master</code>分支上的问题后，在回到<code>dev</code>分支恢复现场。此时会涉及到以下和stash相关的指令——</p><ul><li><strong><code>git stash</code>：将工作现场储藏起来（使用该命令后工作区就被清空了）。</strong></li><li><strong><code>git stash list</code>：查看被储藏起来的内容。</strong></li><li><strong><code>git stash pop</code>：将最近保存的工作现场恢复。</strong></li></ul><p>当然我们可以多次用<code>stash</code>将工作区的修改储藏起来，如果想要恢复指定的一次，则先使用<code>git stash list</code>查看暂存记录找到对应的id，然后使用<code>git stash apply stash@{&lt;id&gt;}</code>恢复。</p><p>需要注意的是，<code>git stash apply</code>不会把stash中的内容删除，若要删除还需要<code>git stash drop stash@{&lt;id&gt;}</code>。换句话说，一条<code>git stash pop</code>指令相当于<code>git stash apply</code>和<code>git stash drop</code>这两条指令</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab4 Challenge：线程和信号量</title>
      <link href="/2022/07/04/os/os-lab4-tiao-zhan-xing-ren-wu-she-ji/"/>
      <url>/2022/07/04/os/os-lab4-tiao-zhan-xing-ren-wu-she-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&gt;&gt;&gt; <a href="Lab4%20挑战性任务-2022.pdf">指导书链接</a><br>&gt;&gt;&gt; <a href="OS-LAB4-挑战性任务设计/OS答辩.pptx">答辩PPT链接</a></p><h2 id="任务简介">任务简介</h2><p>Lab4的挑战性任务要求我们对MOS中以进程为单位的调度方式进行修改，实现线程相关机制，将作业调度的粒度缩小到线程，提高MOS的并发能力。此外，同一进程中的所有线程都共享进程中的资源，因此难免会出现资源竞争的现象。为了更好的控制线程之间的同步互斥关系，我们还需要实现信号量机制，从而保证各个线程能够按照我们的预期运行。</p><p>最终，我在任务中实现了以下用户态函数，并成功通过了自己的测试样例，达到了预期效果。</p><ul><li><strong>线程相关函数</strong><ul><li><strong>pthread_create</strong></li><li><strong>pthread_exit</strong></li><li><strong>pthread_cancel</strong></li><li><strong>pthread_join</strong></li><li><strong>pthread_testcancel</strong></li><li><strong>pthread_self</strong></li><li><strong>pthread_detach</strong></li><li><strong>pthread_setcanceltype</strong><br> </li></ul></li><li><strong>信号量相关函数</strong><ul><li><strong>sem_init</strong></li><li><strong>sem_destroy</strong></li><li><strong>sem_wait</strong></li><li><strong>sem_trywait</strong></li><li><strong>sem_post</strong></li><li><strong>sem_getvalue</strong></li></ul></li></ul><h2 id="线程相关机制">线程相关机制</h2><h3 id="数据结构">数据结构</h3><h4 id="线程控制块的设置">线程控制块的设置</h4><p>首先，我们需要引入记录线程相关状态的数据结构，从而实现对线程的控制。这个数据结构就是线程控制块——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    u_int thread_id<span class="token punctuation">;</span>            u_int thread_pri<span class="token punctuation">;</span>           u_int thread_tag<span class="token punctuation">;</span>           u_int thread_status<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> thread_tf<span class="token punctuation">;</span>    <span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span> thread_sched_link<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> thread_retval<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> thread_retval_ptr<span class="token punctuation">;</span>    u_int thread_join_caller<span class="token punctuation">;</span>    u_int thread_cancel_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li><code>thread_id</code>是线程的<code>id</code>。<code>thread_id</code>包括两部分，0-4位表示该线程是所属进程中的第几号线程（每个进程中最多同时运行32个线程），4-31位记录线程所属进程的<code>envid</code>；</li><li><code>thread_pri</code>是线程的优先级。线程通过优先级来确定时间片的大小，属于同一进程的所有线程优先级相同。</li><li><code>thread_tag</code>是线程的标志位集合。这里采用状态压缩的方式，每一位分别表示不同的标志位。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_TAG_CANCELED</span>    <span class="token expression"><span class="token number">1</span>    </span><span class="token comment">// bit0为1表示线程已经被cancel</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_TAG_JOINED</span>      <span class="token expression"><span class="token number">2</span>    </span><span class="token comment">// bit1为1表示线程已经被joined</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_TAG_EXITED</span>      <span class="token expression"><span class="token number">4</span>    </span><span class="token comment">// bit2为1表示线程已经调用过pthread_exit函数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_TAG_DETACHED</span>    <span class="token expression"><span class="token number">8</span>    </span><span class="token comment">// bit3为1表示线程已经是分离状态</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>thread_status</code>表示线程的运行状态，可取值有<code>THREAD_FREE</code>，<code>THREAD_RUNNABLE</code>，<code>THREAD_NOT_RUNNABLE</code>。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_FREE</span>            <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_RUNNABLE</span>    <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_NOT_RUNNABLE</span>    <span class="token expression"><span class="token number">2</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>thread_tf</code>是用来存储寄存器现场的数据结构。在线程调出时，内核会将上下文存入其中，等到线程重新获得处理机资源时再恢复。</li><li><code>thread_retval</code>用来保存线程返回值。</li><li><code>thread_retval_ptr</code>是指向线程返回值的指针。该指针的拥有者是"调用join的线程"，指针指向的是"被join作用的线程的返回值"。</li><li><code>thread_join_caller</code>保存的是"调用join的线程"，而拥有这个变量的是"join作用的线程"。当某个线程结束时，如果它本身是被join的，则会将自身返回值<code>thread_retval</code>存储到<code>*(caller-&gt;thread_retval_ptr)</code>中。</li><li><code>thread_cancel_type</code>表示线程的撤销类型，可以取<code>THREAD_CANCEL_DEFREERD</code>和<code>THREAD_CANCEL_ASYNCHRONOUS</code>两个值。如果是前者，则表示被cancel作用后不立刻结束，需等待取消点的到来；如果是后者，则被cancel作用后会立即结束。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_CANCEL_DEFERRED</span>          <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_CANCEL_ASYNCHRONOUS</span><span class="token expression"><span class="token number">1</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="进程控制块的修改">进程控制块的修改</h4><p>引入线程之后，进程的作用和地位就发生了改变，进程只作为系统资源的分配单元。因此，原来进程控制块中与调度相关的数据就不再需要了，例如<code>env_pop_tf</code>和<code>env_status</code>，取而代之的是和线程控制相关的数据。更改之后的进程控制块如下<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token punctuation">{</span>    <span class="token comment">// struct Trapframe env_tf;         // Saved registers</span>    <span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Env<span class="token punctuation">)</span> env_link<span class="token punctuation">;</span>           <span class="token comment">// Free list</span>    u_int env_id<span class="token punctuation">;</span>                       <span class="token comment">// Unique environment identifier</span>    u_int env_parent_id<span class="token punctuation">;</span>                <span class="token comment">// env_id of this env's parent</span>    <span class="token comment">// u_int env_status;                // Status of the environment</span>    Pde  <span class="token operator">*</span>env_pgdir<span class="token punctuation">;</span>                    <span class="token comment">// Kernel virtual address of page dir</span>    u_int env_cr3<span class="token punctuation">;</span>    u_int env_pri<span class="token punctuation">;</span>    <span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Env<span class="token punctuation">)</span> env_sched_link<span class="token punctuation">;</span>    <span class="token comment">// Lab 4 IPC</span>    u_int env_ipc_value<span class="token punctuation">;</span>                <span class="token comment">// data value sent to us </span>    u_int env_ipc_from<span class="token punctuation">;</span>                 <span class="token comment">// envid of the sender  </span>    u_int env_ipc_recving<span class="token punctuation">;</span>              <span class="token comment">// env is blocked receiving</span>    u_int env_ipc_dstva<span class="token punctuation">;</span><span class="token comment">// va at which to map received page</span>    u_int env_ipc_perm<span class="token punctuation">;</span>        <span class="token comment">// perm of page mapping received</span>    u_int env_ipc_dst_thread<span class="token punctuation">;</span>    <span class="token comment">// Lab 4 fault handling</span>    u_int env_pgfault_handler<span class="token punctuation">;</span>          <span class="token comment">// page fault state</span>    u_int env_xstacktop<span class="token punctuation">;</span>                <span class="token comment">// top of exception stack</span>    <span class="token comment">// Lab 6 scheduler counts</span>    u_int env_runs<span class="token punctuation">;</span><span class="token comment">// number of times been env_run'ed</span>    u_int env_nop<span class="token punctuation">;</span>                      <span class="token comment">// align to avoid mul instruction</span>    <span class="token comment">// Lab 4 challenge</span>    u_int env_thread_bitmap<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> env_threads<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以发现，删除<code>env_pop_tf</code>和<code>env_status</code>后，我们又新增了三个数据——<code>env_ipc_dst_thread</code>，<code>env_thread_bitmap</code>和<code>env_therads</code>。<p></p><ul><li><code>env_ipc_dst_thread</code>保存IPC交互过程中"读线程"的id。</li><li><code>env_thread_bitmap</code>是用来记录线程使用状态的位图。一个进程中最多有32个线程，正好对应整数的32个位。1表示线程已经被分配出去，状态可能是<code>RUNNABLE</code>或者<code>NOT_RUNNABLE</code>；0表示线程仍然是<code>FREE</code>状态，可以被申请。</li><li><code>env_threads</code>中存储被该进程管理的32个线程的线程控制块。</li></ul><h3 id="线程的创建和销毁">线程的创建和销毁</h3><p>每个进程的0号线程是该进程的主线程，主线程的PC初始值是用户程序镜像中的<code>entry point</code>，从而保证线程运行时直接执行用户程序中的<code>main</code>函数。每当创建一个新的进程时，该进程的主线程也随之被分配出去了。为了保证进程及其主线程同时创建、以及主线程能够从正确的PC开始运行，我们需要对原来的<code>env_alloc</code>、<code>env_create_priority</code>、<code>load_icode</code>等函数进行修改。</p><p>进程中的1-31号线程都是通过<code>pthread_create</code>函数创建出来的，我们姑且把这些线程称为子线程。子线程的运行入口是某个由用户创建的"线程运行函数"（相当于Java中的<code>run</code>方法），而并非是<code>main</code>函数，这是子线程和主线程的根本区别。</p><p>不论是子线程和主线程，在运行时都需要一定的栈空间。为了保证每个线程都拥有独立的栈空间，同时尽量避免不同线程的栈之间发生冲突，我从<code>USTACKTOP</code>开始为0-31号线程依次划分了4MB大小的空间，<code>USTACKTOP</code>是0号线程的栈顶，<code>USTACKTOP+4M</code>是1号线程的栈顶...以此类推。</p><p><img src="stack.png"></p><p>接下来我们就可以编写进程的创建函数，从进程控制块中申请一个线程控制块，并对这个线程可控制块进行初始化。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">thread_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    u_int thread_id<span class="token punctuation">;</span>    <span class="token comment">// 申请一个线程控制块</span>    thread_id <span class="token operator">=</span> <span class="token function">mkthreadid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">//申请一个新的id</span>    t <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//根据id从进程控制块中获取新的线程控制块</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;33;40m&gt;&gt;&gt; thread %d is alloced ... (threads[%d] of env %d) &lt;&lt;&lt;\033[0m\n"</span><span class="token punctuation">,</span>                 thread_id<span class="token punctuation">,</span> <span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">THREAD2ENVID</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 进程控制初始化</span>    t<span class="token operator">-&gt;</span>thread_id <span class="token operator">=</span> thread_id<span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_pri <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_RUNNABLE<span class="token punctuation">;</span>             <span class="token comment">//将线程的状态设置为runnable</span>    t<span class="token operator">-&gt;</span>thread_retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_retval_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_join_caller <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_cancel_type <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>cp0_status <span class="token operator">=</span> <span class="token number">0x1000100c</span><span class="token punctuation">;</span>     t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> USTACKTOP <span class="token operator">-</span> <span class="token number">1024</span> <span class="token operator">*</span> BY2PG <span class="token operator">*</span> <span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 栈空间分配  </span>    <span class="token operator">*</span><span class="token keyword">new</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在线程运行函数正常结束，或者线程自己调用<code>pthread_exit</code>退出，或者线程被<code>join</code>作用时，需要释放相应的线程控制块，我们通过<code>thread_free</code>和<code>thread_destroy</code>函数实现。前者主要是将线程控制块标记成<code>FREE</code>，并在修改对应进程控制块的位图。后者在调用前者的基础上，判断进程中所有的线程是否都已经结束，如果是，则顺便调用<code>env_free</code>将进程也释放掉，随后直接<code>sched_yield</code>进行切换。<p></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">thread_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>    e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">THREAD2ENVID</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_index_free</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_FREE<span class="token punctuation">;</span>    <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">THREAD2ENVID</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">thread_free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curthread <span class="token operator">==</span> t<span class="token punctuation">)</span> curthread <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">bcopy</span><span class="token punctuation">(</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TIMESTACK <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;35;40m&gt;&gt;&gt; thread %d is killed ... (threads[%d] of env %d) &lt;&lt;&lt;\033[0m\n"</span><span class="token punctuation">,</span>                 t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">,</span> <span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">THREAD2ENVID</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 随后判断进程中所用的线程是不是已经结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_thread_bitmap <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">env_free</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;35;40m&gt;&gt;&gt; env %d is killed ...  &lt;&lt;&lt;\033[0m\n"</span><span class="token punctuation">,</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sched_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的调度">线程的调度</h3><p>线程创建出来后，还需要对其进行调度。线程的调度完全仿照进程的调度方法：<strong>采用两个队列（<code>thread_shced_list[2]</code>），用来存放可以被调度的线程的控制块。每创建出一个新的线程，我们就将该线程加入第一个队列的队首。在需要进行调度时，我们把当前已经用完时间片的线程放入另一个队列的队尾，并从当前队列的队首获取一个状态为<code>THREAD_RUNNABLE</code>的线程，让这个线程占用处理机资源。</strong></p><p>为了实现线程调度机制，我们需要对<code>sched_yield</code>函数进行修改。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// sched.c</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">Thread</span><span class="token operator">*</span> curthread<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">Thread_list</span> thread_sched_list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sched_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t <span class="token operator">=</span> curthread<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> t <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> t<span class="token operator">-&gt;</span>thread_status <span class="token operator">!=</span> THREAD_RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_sched_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LIST_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                point <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        t <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_sched_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        count <span class="token operator">=</span> t<span class="token operator">-&gt;</span>thread_pri<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">thread_run</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>对应的，我们仿照<code>env_run</code>函数编写一个<code>thread_run</code>函数。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// thread.c</span><span class="token keyword">void</span> <span class="token function">thread_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>    e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">THREAD2ENVID</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curthread <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>old<span class="token punctuation">;</span>        old <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>TIMESTACK <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bcopy</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>curthread<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curthread<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> old<span class="token operator">-&gt;</span>cp0_epc<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curenv <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        curenv <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">lcontext</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 和curenv类似，我们设置一个全局变量curthread来指向当前运行的线程的线程控制块</span>    curthread <span class="token operator">=</span> t<span class="token punctuation">;</span>       <span class="token function">env_pop_tf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">,</span> <span class="token function">GET_ENV_ASID</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>有一个细节需要注意，如果换出的线程和换入的线程同属于一个进程，那我们不需要使用<code>lcontext</code>更换页表，这也就是线程切换比进程间的原因（线程很长一段时间被称作轻量级进程）。我们的MOS是运行在gxemul模拟器上的，虚实地址的转换也是采用软件模拟的（并没有采用硬件MMU）。当发生tlb中断时，模拟器会根据全局变量<code>context</code>中存储的页表地址来找到页表，并找到对应的页表项。因此，进程间切换时只需要把新进程页表的物理地址传给<code>context</code>变量即可，开销看上去也不大。<strong>但是如果运行在真正的硬件上，进程间切换时还涉及到进程页表从主存和内存之间的换入和换出，以及MMU的相关调整，时间开销就会比较大</strong>。<p></p><h3 id="相关系统调用">相关系统调用</h3><p>为了便于用户态函数的实现，我们需要设置一些系统调用函数提供内核服务——包括<strong>申请新的线程控制块、销毁线程控制块、获得当前运行线程的id、将线程加入或移出调度队列</strong>等等。线程操作相关的系统调用包括——</p><ul><li><p><strong>syscall_thread_alloc</strong>：该函数用于申请新的线程控制块，直接调用<code>thread_alloc</code>函数即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_thread_alloc</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">thread_alloc</span><span class="token punctuation">(</span>curenv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>syscall_thread_destroy</strong>：该函数在线程运行函数正常结束、线程自己调用exit退出、线程被join作用时被调用，释放线程占用的资源。需要注意的是，如果被结束的线程拥有<code>THREAD_TAG_CANCELED</code>这一标志位，还需要将自身的返回值"告知"join函数的调用者。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_thread_destroy</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int threadid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">id2thread</span><span class="token punctuation">(</span>threadid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_JOINED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        u_int caller_id <span class="token operator">=</span> t<span class="token operator">-&gt;</span>thread_join_caller<span class="token punctuation">;</span>             <span class="token comment">// 找到join函数的调用线程   </span>        <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span> caller <span class="token operator">=</span> <span class="token operator">&amp;</span>curenv<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>caller_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>caller<span class="token operator">-&gt;</span>thread_retval_ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment">// 将自身的返回值"告知"join函数的调用者     </span>            <span class="token operator">*</span><span class="token punctuation">(</span>caller<span class="token operator">-&gt;</span>thread_retval_ptr<span class="token punctuation">)</span> <span class="token operator">=</span> t<span class="token operator">-&gt;</span>thread_retval<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        caller<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_RUNNABLE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token function">thread_destroy</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用thread_destory函数来释放其他的内容</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><code>syscall_set_thread_status</code>：设置线程的运行状态，同时根据状态的改变将线程控制块加入或者移出调度队列。具体实现和<code>syscall_set_env_status</code>完全一样，照葫芦画瓢即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_set_thread_status</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int threadid<span class="token punctuation">,</span> u_int status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> THREAD_RUNNABLE <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> THREAD_FREE <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> THREAD_NOT_RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ret <span class="token operator">=</span> <span class="token function">id2thread</span><span class="token punctuation">(</span>threadid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> THREAD_RUNNABLE <span class="token operator">&amp;&amp;</span> t<span class="token operator">-&gt;</span>thread_status <span class="token operator">!=</span> THREAD_RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">LIST_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_sched_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> THREAD_RUNNABLE <span class="token operator">&amp;&amp;</span> t<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><code>syscall_get_thread_id</code>：获取当前运行的线程的id，直接调用从<code>curthread</code>指向的线程控制块中找即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_get_thread_id</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> curthread<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h3 id="用户接口的实现">用户接口的实现</h3><p>编写好系统调用之后，我们就可以利用它们实现用户态的接口函数。</p><ul><li><p><strong>pthread_create</strong>：通过<code>syscall_thread_alloc</code>申请一个线程，然后对<code>pc</code>、<code>a0</code>、<code>sp</code>、<code>ra</code>等寄存器进行赋值，保证新创建的子线程能够正确的进入线程运行函数，并最终进入<code>exit</code>函数结束。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span>                     <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>start_rountine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    u_int thread_id<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>        thread_id <span class="token operator">=</span> <span class="token function">syscall_thread_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread_id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>thread <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> thread_id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> start_rountine<span class="token punctuation">;</span>   <span class="token comment">// 保证子线程能够进入线程运行函数</span>    t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>         <span class="token comment">// 传递参数</span>    t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">4</span><span class="token punctuation">;</span>         <span class="token comment">// 在栈上预留空间，符合MIPS函数调用的规范</span>    t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> exit<span class="token punctuation">;</span>       <span class="token comment">// 保证子线程退出线程运行函数后，能够进入exit函数释放进程控制块。</span>    <span class="token function">syscall_set_thread_status</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">,</span> THREAD_RUNNABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>thread <span class="token operator">=</span> thread_id<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>pthread_exit</strong>：调用这个函数会把线程本身中止，如果需要返回某个值，只需要将返回值作为参数传给该函数即可。这个函数首先获得当前运行的线程的线程控制块，然后把返回值复制给<code>thread_retval</code>，并标记上<code>THREAD_TAG_EXITED</code>，最后直接调用<code>exit</code>返回即可。当某个线程调用了join函数，而且join的目标时该进程，则它会从该线程的<code>thread_retval</code>中获得（在系统调用<code>sys_thread_destroy</code>中有这个机制）。<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void pthread_exit(void *retval) {    u_int thread_id;    struct Thread *cur;    thread_id = syscall_get_thread_id();    cur = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];        cur-&gt;thread_retval = retval;    cur-&gt;thread_tag |= THREAD_TAG_EXITED;    exit();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>pthread_cancel</strong>：该函数可以将指定的线程撤销，不过还需要对目标线程的标志位进行检查。对于处于<code>FREE</code>状态的线程、处于分离状态的线程、已经被撤销过的线程、已经调用<code>pthread_exit</code>自杀的线程（自杀但是没来的及destroy），我们不能通过该函数取消它们。else里的内容才是正常情况下做出的操作——</p><ul><li>将目标线程标记为THREAD_TAG_CANCELED</li><li>将PTHREAD_CANCELED设置为返回值（笔者将其设置为666）</li><li>如果目标线程的撤销类型时THREAD_CANCEL_ASYNCHRONOUS，我们需要让目标线程在下一次被调度时直接进入exit函数。</li></ul><p></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    t <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_id <span class="token operator">!=</span> thread <span class="token operator">||</span> t<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_NOT_FOUND<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_DETACHED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_DETACHED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_CANCELED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_CANCELED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_EXITED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_EXITED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        t<span class="token operator">-&gt;</span>thread_tag <span class="token operator">|=</span> THREAD_TAG_CANCELED<span class="token punctuation">;</span>       <span class="token comment">// 将目标线程标记为THREAD_TAG_CANCELED</span>        t<span class="token operator">-&gt;</span>thread_retval <span class="token operator">=</span> PTHREAD_CANCELED<span class="token punctuation">;</span>        <span class="token comment">// 将PTHREAD_CANCELED设置为返回值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>thread_cancel_type <span class="token operator">==</span> THREAD_CANCEL_ASYNCHRONOUS<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">==</span> <span class="token function">syscall_get_thread_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> t<span class="token operator">-&gt;</span>thread_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> exit<span class="token punctuation">;</span>            <span class="token comment">// 结束该进程 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>pthread_join</strong>：调用该函数后，会将当前线程阻塞至目标线程结束。</p><ul><li>对于已经处于分离状态、或者已经被join的线程，我们无法对其调用join。</li><li>对于已经处于<code>FREE</code>状态、已经结束了的线程，我们不需要将join调用者阻塞，直接从目标线程的<code>thread_retval</code>中获取返回值即可。</li><li>对于其他线程，我们可以对其调用join，但是调用线程必须等待。注意<code>curthread-&gt;thread_retval_ptr = retval_ptr</code>这步比较关键——将指针<code>retval_ptr</code>赋值给调用者的<code>thread_retval_ptr</code>，当目标进程结束后，会直接将返回值写入<code>*(调用者-&gt;thread_retval_ptr)</code>，这和写入<code>*retval_ptr</code>是等价的（在<code>sys_thread_destroy</code>中有相关机制）。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>dst<span class="token punctuation">;</span>    dst <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_id <span class="token operator">!=</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_NOT_FOUND<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_DETACHED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_DETACHED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_JOINED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_JOINED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval_ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token operator">*</span>retval_ptr <span class="token operator">=</span> dst<span class="token operator">-&gt;</span>thread_retval<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">|=</span> THREAD_TAG_JOINED<span class="token punctuation">;</span>               <span class="token comment">// 将目标线程标记上THREAD_TAG_JOINED</span>    dst<span class="token operator">-&gt;</span>thread_join_caller <span class="token operator">=</span> curthread<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">;</span>     <span class="token comment">// 把调用者的id记录在目标线程的线程控制块中</span>    curthread<span class="token operator">-&gt;</span>thread_retval_ptr <span class="token operator">=</span> retval_ptr<span class="token punctuation">;</span>          <span class="token comment">// 将传入的指针retval_ptr赋值给thread_retval_ptr</span>    curthread<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_NOT_RUNNABLE<span class="token punctuation">;</span>     <span class="token comment">// 将当前线程阻塞</span>    <span class="token function">syscall_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 切换线程</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>pthread_detach</strong>：将目标线程设置为分离状态，对于处于分离状态的线程，其他线程无法对其使用join、detach、cancel等函数。此外，我们不能对已经是<code>FREE</code>状态的、或者已经处于分离状态、或者已经被join的线程使用该函数。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>dst<span class="token punctuation">;</span>    dst <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_id <span class="token operator">!=</span> thread  <span class="token operator">||</span> dst<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_NOT_FOUND<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_DETACHED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_DETACHED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_JOINED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_JOINED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">|=</span> THREAD_TAG_DETACHED<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>pthread_setcanceltype</strong>：默认情况下，线程的canceltype都是<code>THREAD_CANCEL_DEFERRED</code>，而该函数修改进程的<code>cancel type</code>，并通过<code>oldtype</code>获得原值。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>oldtype<span class="token punctuation">)</span> <span class="token punctuation">{</span>    u_int thread_id <span class="token operator">=</span> <span class="token function">syscall_get_thread_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldtype<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>oldtype <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>thread_cancel_type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cur<span class="token operator">-&gt;</span>thread_cancel_type <span class="token operator">=</span> type<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>pthread_teatcancel</strong>：对于<code>cancel type</code>是<code>THREAD_CANCEL_DEFERRED</code>的线程来说，被cancel函数作用后并不会立刻结束，而是到达某一个"取消点"才会结束自己。而这个函数可以帮助手动设置取消点，当某一个线程运行到该函数时，如果满足条件就直接进入exit函数退出。必须满足条件有两个——</p><ul><li>当前进程必须join函数作用过，即存在<code>THREAD_CANCEL_DEFERRED</code>标记。</li><li>当前进程的<code>cancel type</code>必须是<code>THREAD_CANCEL_DEFERRED</code>，即默认状态。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    u_int thread_id<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span>    thread_id <span class="token operator">=</span> <span class="token function">syscall_get_thread_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cur <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_CANCELED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            cur<span class="token operator">-&gt;</span>thread_cancel_type <span class="token operator">==</span> THREAD_CANCEL_DEFERRED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>pthread_self</strong>：该函数可以让线程获得自己的id，只需要调用<code>syscall_get_thread_id</code>即可。<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pthread_t pthread_self() {    return syscall_get_thread_id();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h3 id="其他细节">其他细节</h3><h4 id="exit">exit</h4><p>所有正常或者非正常结束的线程最后都会进入<code>exit</code>函数，而这个函数也有很多细节需要注意。笔者改写的<code>exit</code>函数如下图所示<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//writef("enter exit!");</span><span class="token comment">//close_all();</span><span class="token keyword">void</span> <span class="token operator">*</span>retval <span class="token operator">=</span> <span class="token function">get_retval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> thread_id <span class="token operator">=</span> <span class="token function">syscall_get_thread_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>cur_thread <span class="token operator">=</span> <span class="token operator">&amp;</span>env<span class="token operator">-&gt;</span>env_threads<span class="token punctuation">[</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// THREAD2INDEX(thread_id)表示"该线程是所属进程的第几号线程</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">THREAD2INDEX</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cur_thread<span class="token operator">-&gt;</span>thread_retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">syscall_thread_destroy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur_thread<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_CANCELED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">syscall_thread_destroy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur_thread<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_EXITED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">{</span>cur_thread<span class="token operator">-&gt;</span>thread_retval <span class="token operator">=</span> retval<span class="token punctuation">;</span><span class="token function">syscall_thread_destroy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>对于0号线程，也就是主线程，它先执行<code>umain</code>函数然后再进入<code>exit</code>，由于<code>umain</code>函数是没有返回值的，因此我们需要手动将<code>0</code>作为主线程返回值。但是实际上，一般不会出现"子线程获取主线程的返回值"，所以这里可有可无。</li><li>对于标志位有<code>THREAD_TAG_CANCELED</code>或者<code>THREAD_TAG_EXITED</code>的子线程，这些线程都是通过exit或者cancel函数非正常结束的，而且在这两个函数中都已经把"返回值"赋值给<code>thread_retval</code>，所以在这里只需要调用<code>syscall_thread_destroy</code>释放线程资源即可。</li><li>对于正常结束的子线程，尽管是有返回值，但是由于执行完"线程运行函数"后直接跳转到了<code>exit</code>，"线程运行函数"的返回值我们无法直接获取。为此，笔者特地写了一个汇编函数<code>get_retval</code>来获得"线程运行函数"的返回值。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">LEAF</span><span class="token punctuation">(</span>get_retval<span class="token punctuation">)</span> j ra<span class="token function">END</span><span class="token punctuation">(</span>get_retval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>我们把<code>get_retval</code>作为<code>exit</code>中运行的第一个函数，由于<code>get_retval</code>没有修改<code>v0寄</code>存器，因此它的返回值和"线程运行函数"的返回值一致。</li></ul><h4 id="pthread_join的线程安全">pthread_join的线程安全</h4><p>上面介绍的<code>pthread_join</code>函数的实现是在用户态中实现的，但是笔者在测试中发现，由于线程执行顺序的随机性会带来一些线程安全问题。</p><p>假设线程A调用join函数，并作用于线程B。</p><ul><li>当线程A执行<code>if (dst-&gt;thread_status == THREAD_FREE)</code>时，发现线程B并不是FREE状态，接着发生时钟中断，切换到了线程B。</li><li>线程B执行完并正常退出，状态变成了<code>FREE</code>，然后切换到了线程A。</li><li>线程A由于此前判断出"线程B不是<code>FREE</code>状态"，因此跳过了if，执行后续操作（被阻塞）。</li><li>线程A被阻塞了，但是线程B早就执行完<code>syscall_thread_destroy</code>恢复清白之身了，无法唤醒线程A</li></ul><p>为了解决这个问题，笔者将<code>pthread_join</code>函数中的操作封装成了系统调用——</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token function">syscall_thread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> retval_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 新增系统调用函数</span><span class="token keyword">int</span> <span class="token function">sys_thread_join</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int thread_id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>dst<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">id2thread</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_id <span class="token operator">!=</span> thread_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_NOT_FOUND<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_DETACHED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_DETACHED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">&amp;</span> THREAD_TAG_JOINED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_THREAD_JOINED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dst<span class="token operator">-&gt;</span>thread_status <span class="token operator">==</span> THREAD_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval_ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token operator">*</span>retval_ptr <span class="token operator">=</span> dst<span class="token operator">-&gt;</span>thread_retval<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dst<span class="token operator">-&gt;</span>thread_tag <span class="token operator">|=</span> THREAD_TAG_JOINED<span class="token punctuation">;</span>    dst<span class="token operator">-&gt;</span>thread_join_caller <span class="token operator">=</span> curthread<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">;</span>    curthread<span class="token operator">-&gt;</span>thread_retval_ptr <span class="token operator">=</span> retval_ptr<span class="token punctuation">;</span>    curthread<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_NOT_RUNNABLE<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 设置返回值为0</span>    <span class="token function">sys_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="信号量机制">信号量机制</h2><h3 id="数据结构-1">数据结构</h3><p>信号量机制的实现同样离不开一定的数据结构。笔者编写了<code>Semaphore</code>这一结构体，并将其作为信号量的类型(sem_t)。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Semaphore</span> <span class="token punctuation">{</span>    u_int sem_perm<span class="token punctuation">;</span>    <span class="token keyword">int</span> sem_value<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span><span class="token operator">*</span> sem_wait_queue<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    u_int sem_queue_head<span class="token punctuation">;</span>    u_int sem_queue_tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li><code>sem_perm</code>是信号量的标志位集合，同样采用了状态压缩的方式，<code>bit0</code>是信号量的"有效位"，<code>bit1</code>是信号量的"共享位"。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_PERM_VALID</span>          <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_PERM_SHARE</span>          <span class="token expression"><span class="token number">2</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><code>sem_value</code>是信号量的当前值。</li><li><code>sem_wait_queue</code>是存储被阻塞线程的环形队列，因为进程最多只能同时运行32个线程，因此唤醒队列的长度也是32</li><li><code>sem_queue_head</code>是环形队列的队首下标</li><li><code>sem_queue_tail</code>是环形队列的队尾下标</li></ul><h3 id="用户接口函数的实现">用户接口函数的实现</h3><p>信号量的使用是为了解决线程高并发带来的同步互斥问题，因此信号量本身的各种操作也必须是原子的。为了保证原子性，笔者为每一个用户接口函数设置了对应的系统调用函数。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sem_init</span> <span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_init</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> pshared<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sem_destroy</span> <span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_destroy</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sem_wait</span> <span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_trywait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sem_post</span> <span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sem_getvalue</span> <span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>valp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">syscall_sem_getvalue</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> valp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>各个系统调用的实现如下——</p><ul><li><p><strong>sys_sem_init</strong>：这个函数主要是对信号量进行初始化，需要将参数赋值给<code>sem_value</code>，设置标志位，并将其他数据成员的值设为0。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_init</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_NOT_FOUND<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sem<span class="token operator">-&gt;</span>sem_value <span class="token operator">=</span> value<span class="token punctuation">;</span>    sem<span class="token operator">-&gt;</span>sem_queue_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     sem<span class="token operator">-&gt;</span>sem_queue_tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">|=</span> SEM_PERM_VALID<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pshared<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">|=</span> SEM_PERM_SHARE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sem<span class="token operator">-&gt;</span>sem_wait_queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>sys_sem_destroy</strong>：该函数需要销毁信号量，只需要将信号量的<code>VALID</code>标志位设置位0即可。但是需要注意的是，如果目前还有阻塞在信号量上的线程，则信号量无法被销毁。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_destroy</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;</span> SEM_PERM_VALID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 无法销毁无效的信号量</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_queue_head <span class="token operator">!=</span> sem<span class="token operator">-&gt;</span>sem_queue_tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_DESTROY_FAIL<span class="token punctuation">;</span>             <span class="token punctuation">}</span>    sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;=</span> <span class="token operator">~</span>SEM_PERM_VALID<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>sys_sem_wait</strong>：调用该函数后，<code>sem_value</code>会自减。如果自减之后<code>sem_value</code>的值小于0，则会将调用者加入信号量的阻塞队列中，并将该线程状态设置为<code>THREAD_NOT_RUNNABLE</code>，实现阻塞。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_wait</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;</span> SEM_PERM_VALID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        sem<span class="token operator">-&gt;</span>sem_value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_value <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// if sem_value &lt; 0 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_value <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_WAIT_MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// must wait</span>    sem<span class="token operator">-&gt;</span>sem_wait_queue<span class="token punctuation">[</span>sem<span class="token operator">-&gt;</span>sem_queue_tail<span class="token punctuation">]</span> <span class="token operator">=</span> curthread<span class="token punctuation">;</span>    sem<span class="token operator">-&gt;</span>sem_queue_tail <span class="token operator">=</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_queue_tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>    curthread<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_NOT_RUNNABLE<span class="token punctuation">;</span>     <span class="token comment">//阻塞线程</span>        <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf <span class="token operator">=</span>         <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 将返回值设置为0</span>    <span class="token function">sys_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>sys_sem_trywait</strong>：调用该函数后，<code>sem_value</code>会自减。如果自减之后<code>sem_value</code>的值小于0，则会返回错误码，不会对调用者产生任何阻塞效果。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_trywait</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;</span> SEM_PERM_VALID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        sem<span class="token operator">-&gt;</span>sem_value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_value <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_TRYWAIT_FAIL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>sys_sem_post</strong>：调用该函数后，<code>sem_value</code>会自增。如果自增之后<code>sem_value</code>的值是小于等于0，则说明当前有阻塞在该信号量上的线程，我们需要从队首获得一个线程并将其唤醒。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_post</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;</span> SEM_PERM_VALID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        sem<span class="token operator">-&gt;</span>sem_value<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t <span class="token operator">=</span> sem<span class="token operator">-&gt;</span>sem_wait_queue<span class="token punctuation">[</span>sem<span class="token operator">-&gt;</span>sem_queue_head<span class="token punctuation">]</span><span class="token punctuation">;</span>        sem<span class="token operator">-&gt;</span>sem_queue_head <span class="token operator">=</span> <span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_queue_head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>        t<span class="token operator">-&gt;</span>thread_status <span class="token operator">=</span> THREAD_RUNNABLE<span class="token punctuation">;</span>  <span class="token comment">// 唤醒线程</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>sys_sem_getvalue</strong>：该函数可以返回目标信号量的当前值，直接返回<code>sem_value</code>即可。对于没有被初始化的信号量，也就是<code>VALID</code>位是0的信号量，直接返回错误码<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sys_sem_getvalue</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>valp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_perm <span class="token operator">&amp;</span> SEM_PERM_VALID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_SEM_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>valp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>valp <span class="token operator">=</span> sem<span class="token operator">-&gt;</span>sem_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h2 id="关于测试">关于测试</h2><h3 id="线程创建等待返回值测试">线程创建、等待、返回值测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">print_message_function</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d received : '%s' \033[0m\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>message1 <span class="token operator">=</span> <span class="token string">"I love BUAA!"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>message2 <span class="token operator">=</span> <span class="token string">"I love CS!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  ret1<span class="token punctuation">,</span> ret2<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> print_message_function<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> message1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> print_message_function<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> message2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span> t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span> t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d returns: %d \033[0m\n"</span><span class="token punctuation">,</span> t1<span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d returns: %d \033[0m\n"</span><span class="token punctuation">,</span> t2<span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="线程创建基本函数.jpg"></p><h3 id="pthread_exit测试">pthread_exit测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">print_message_function</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d received : '%s' \033[0m\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m before `pthread_exit` ...\033[0m\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m after `pthread_exit` ...\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>message1 <span class="token operator">=</span> <span class="token string">"I love BUAA!"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>message2 <span class="token operator">=</span> <span class="token string">"I love CS!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  ret1<span class="token punctuation">,</span> ret2<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> print_message_function<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> message1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> print_message_function<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> message2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span> t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span> t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d returns: %d \033[0m\n"</span><span class="token punctuation">,</span> t1<span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d returns: %d \033[0m\n"</span><span class="token punctuation">,</span> t2<span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="exit测试.jpg"></p><h3 id="cancel测试">cancel测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span>pthread_t t3<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">499999</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">12345</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">10088</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">3381</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>temp_1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>temp_2<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>temp_3<span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40mthread 1 is finished!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40mthread 2 return the ptr of: %s\033[0m\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>temp_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp_3 <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40mthread 3 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40mthread 3 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="测试cancel.jpg"></p><h3 id="cancel返回值测试">cancel返回值测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40mreciving '%s'\033[0m\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m %d \033[0m\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m fun1 end !!!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t1 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m t1 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m t1 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="cancel返回值测试.jpg"></p><h3 id="cancel-point测试">cancel point测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40mreciving '%s'\033[0m\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m %d \033[0m\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m fun1 end !!!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t1 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t2 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret1 <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m t1 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m t1 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret2 <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m t2 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m t2 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="cancel%20point%20测试.jpg"></p><h3 id="asynchronous-cancel测试-1">asynchronous cancel测试 1</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40mreciving '%s'\033[0m\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> oldtype<span class="token punctuation">;</span>        <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span>THREAD_CANCEL_ASYNCHRONOUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40mthread %d old_cancel_ype is '%d', new_cancel_type is '%d'\033[0m\n"</span><span class="token punctuation">,</span>                     <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> oldtype<span class="token punctuation">,</span> THREAD_CANCEL_ASYNCHRONOUS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m %d \033[0m\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m fun1 end !!!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t1 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t2 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret1 <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m t1 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m t1 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret2 <span class="token operator">==</span> PTHREAD_CANCELED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m t2 was canceled successfully!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m t2 return with wrong value!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="asys%20cancel测试1.jpg"></p><h3 id="asynchronous-cancel测试-2">asynchronous cancel测试 2</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40mthread %d reciving '%s'\033[0m\n"</span><span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span>THREAD_CANCEL_ASYNCHRONOUS<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m %d \033[0m\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m fun1 end !!!\033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40mthread %d reciving '%s'\033[0m\n"</span><span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">syscall_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun1<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> fun2<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t1 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m t2 return the value of: %d\033[0m\n"</span><span class="token punctuation">,</span> ret2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong></p><p><img src="asys%20cancel测试2.jpg"></p><h3 id="信号量创建取值销毁测试">信号量创建、取值、销毁测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">;</span>pthread_t t2<span class="token punctuation">;</span>pthread_t t3<span class="token punctuation">;</span>sem_t s1<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">=</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sem_getvalue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m thread %d call the `sem_trywait`, retval is %d, s1's value is %d\033[0m\n"</span><span class="token punctuation">,</span>                 <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> msg <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m after init, s1 perm is %d\033[0m\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span>sem_perm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span>sem_perm <span class="token operator">==</span> SEM_PERM_VALID<span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span>"        \<span class="token number">033</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">34</span><span class="token punctuation">;</span><span class="token number">40</span>m s1 is valid<span class="token operator">!</span> \<span class="token number">033</span><span class="token punctuation">[</span><span class="token number">0</span>m\n"<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_getvalue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m s1 value is %d\033[0m\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span>sem_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> func<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> func<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// wait for t1</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m s1 after destroy, perm is %d\033[0m\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span>sem_perm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span>sem_perm <span class="token operator">!=</span> SEM_PERM_VALID<span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;34;40m s1 is invalid! \033[0m\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>测试结果</strong><p></p><p><img src="sem基础测试.jpg"></p><h3 id="生产者消费者模型测试">生产者消费者模型测试</h3><p><strong>测试例程</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib.h"</span></span>pthread_t t1<span class="token punctuation">,</span> t2<span class="token punctuation">;</span>sem_t mutex<span class="token punctuation">,</span> empty<span class="token punctuation">,</span> full<span class="token punctuation">;</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">prodecer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;32;40m produce successfully, no count is %d \033[0m\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[0;31;40m consume successfully, no count is %d \033[0m\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">umain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> prodecer<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consumer<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>测试结果</strong><br><img src="生产者消费者.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab6：管道和shell</title>
      <link href="/2022/06/26/os/os-lab6-shi-yan-bao-gao/"/>
      <url>/2022/06/26/os/os-lab6-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-6.1">Thinking 6.1</h3><p><strong>Q：</strong><strong>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</strong><br><strong>A：</strong> 只需要调换父子进程操作的内容即可——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">0</span> <span class="token operator">:</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Read end is unused */</span>            <span class="token function">write</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Hello world\n"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Write data on pipe */</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Child will see EOF */</span>            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token operator">:</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Write end is unused */</span>            <span class="token function">read</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Get data from pipe */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child-process read:%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Print the data */</span>            <span class="token function">close</span><span class="token punctuation">(</span>fildes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Finished with pipe */</span>            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-6.2">Thinking 6.2</h3><p><strong>Q：</strong> <strong>上面这种不同步修改 pp_ref而导致的进程竞争问题在 user/fd.c 中的 dup函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup函数中为什么会出现预想之外的情况？</strong><br><strong>A：</strong><code>dup</code>函数的作用时将<code>oldfdnum</code>所代表的文件描述符的指向的数据完全复制给<code>newfdnum</code>文件描述符，一共包含两个过程——</p><ul><li>将<code>newfd</code>所在的虚拟页映射到<code>oldfd</code>所在的物理页</li><li>将<code>newfd</code>的数据所在的虚拟页映射到<code>oldfd</code>的数据所在的物理页</li></ul><p>考虑如下代码段<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 子进程</span>    <span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 父进程    </span>    <span class="token function">dup</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>分析过程如下：<p></p><ul><li>fork结束后，子进程先进行。但是在<code>read</code>之前发生了时钟中断，此时父进程开始进行进行。</li><li>父进程在<code>dup(p[0])</code>中，已经完成了对<code>p[0</code>]的映射，这个时候发生了中断，还没有来得及完成对<code>pipe</code>的映射。</li><li>此时回到子进程，进入<code>read</code>函数，结果发现<code>ref(p[0]) == ref(pipe) == 2</code>,认为此时写进程关闭。</li></ul><h3 id="thinking-6.3">Thinking 6.3</h3><p><strong>Q：</strong><strong>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。</strong><br><strong>A：</strong> 在 <code>syscall</code> 对应的异常处理程序<code>handle_sys</code> 中，我们使用了汇编宏 <code>CLI</code>来禁用全局中断，因此系统调用时不会被中断，是原子操作。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">NESTED</span><span class="token punctuation">(</span>handle_sys<span class="token punctuation">,</span>TF_SIZE<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>    SAVE_ALL                            <span class="token comment">// Macro used to save trapframe</span>    CLI                                 <span class="token comment">// Clean Interrupt Mask</span>    nop    <span class="token punctuation">.</span>set at                             <span class="token comment">// Resume use of $at</span>    <span class="token comment">// ...</span><span class="token function">END</span><span class="token punctuation">(</span>handle_sys<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-6.4">Thinking 6.4</h3><p><strong>Q：</strong><strong>仔细阅读上面这段话，并思考下列问题</strong></p><ul><li><strong>按照上述说法控制 pipeclose 中 fd 和 pipe unmap的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</strong></li><li><strong>我们只分析了 close 时的情形，在 fd.c 中有一个 dup函数，用于复制文件内容。试想，如果要复制的是一个管道，那么是否会出现与close 类似的问题？请模仿上述材料写写你的理解。</strong></li></ul><p><strong>A：</strong> 分析如下</p><ul><li>可以解决。由于<code>ref(p[0])</code>始终小于<code>ref(pipe)</code>,因此如果先解除<code>p[0]</code>的映射，则<code>ref(p[0])</code>更要小于<code>ref(pipe)</code>，永远不会出现<code>ref(p[0]) == ref(pipe)</code>。</li><li><code>dup</code>函数也会出现与<code>close</code>类似的问题，<code>pipe</code>的引用次数总比<code>fd</code>要高。当管道的<code>dup</code>进行到一半时，若先映射<code>fd</code>，再映射 <code>pipe</code>，就会使得<code>fd</code>的引用次数的+1先于<code>pipe</code>。这就导致在两个<code>map</code>的间隙，会出现<code>pageref(pipe) == pageref(fd)</code>的情况。这个问题也可以通过调换两个map的顺序来解决。</li></ul><h3 id="thinking-6.5">Thinking 6.5</h3><p><strong>Q：</strong> <strong>bss 在 ELF 中并不占空间，但 ELF加载进内存后， bss 段的数据占据了空间，并且初始值都是0。请回答你设计的函数是如何实现上面这点的？</strong><br><strong>A：</strong>对于bss段中和text&amp;data段共同占据一个页面的部分，就使用<code>user_bzero</code>将这一部分置零；对于bss段其它部分，仅使用<code>syscall_mem_malloc</code>分配页面而不映射到任何内容。</p><h3 id="thinking-6.6">Thinking 6.6</h3><p><strong>Q：为什么我们的 *.b 的 text段偏移值都是一样的，为固定值？</strong><br><strong>A：</strong>因为在<code>user.lds</code>文件中将所有.b文件的text段偏移量都设置为0x00400000。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">0x00400000</span><span class="token punctuation">;</span>_text <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">/* Text and read-only data */</span><span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>fixup<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>gnu<span class="token punctuation">.</span>warning<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-6.7">Thinking 6.7</h3><p><strong>Q：</strong> <strong>在 shell中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork一个子 shell，如 Linux 系统中的 cd 指令。在执行外部命令时 shell需要 fork一个子 shell，然后子 shell 去执行这条命令。据此判断，在 MOS 中我们用到的shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd指令是内部指令而不是外部指令？</strong><br><strong>A：</strong> 分析如下</p><ul><li>shell命令是外部命令，因为在执行shell命令时，当前进程通过<code>fork</code>产生一个子进程，也就是子shell，然后这个子shell来运行该命令所对应的可执行文件。</li><li>linux中的内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。因为<code>cd</code>指令非常简单，将其作为内部命令写在bashy源码里面的，可以避免每次执行都需要fork并加载程序，提高执行效率。</li></ul><h3 id="thinking-6.8">Thinking 6.8</h3><p><strong>Q：</strong> <strong>在哪步， 0 和 1 被 “安排”为标准输入和标准输出？请分析代码执行流程，给出答案。</strong><br><strong>A：</strong>在<code>init.c</code>的<code>umain</code>函数中将0和1分别被设置为了标准输入和标准输出。相关代码如下<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将0关闭，随后使用opencons函数打开的文件描述符编号就被设置为零为0</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">opencons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"opencons: %e"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"first opencons used fd %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 然后通过dup函数把1设置为标准输出</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"dup: %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-6.9">Thinking 6.9</h3><p><strong>Q：</strong> <strong>在你的 shell 中输入指令 ls.b | cat.b&gt; motd。</strong></p><ul><li><strong>请问你可以在你的 shell 中观察到几次spawn？分别对应哪个进程？</strong></li><li><strong>请问你可以在你的 shell中观察到几次进程销毁？分别对应哪个进程？</strong></li></ul><p><strong>A：</strong> 通过增加调试信息可以看出</p><ul><li>shell中进行了2次<code>spawn</code>，这两次生成的子进程分别用于执行<code>ls.b</code>和<code>cat.b</code></li><li>shell中进行了2次进程销毁，这2个进程分别是shell执行<code>ls.b</code>和<code>cat.b</code>时通过<code>spawn</code>生成的子进程。</li></ul><h2 id="实验难点图示">实验难点图示</h2><p>我认为该实验的难点主要包含两个难点——和管道相关的内存分配、spawn函数的处理流程</p><h3 id="和管道相关的内存分配">和管道相关的内存分配</h3><p>子进程和父进程的内存空间中都分为写端fd和读端fd分配了一个虚拟页，但是子进程和父进程的读端所在的虚拟页映射到了同一个物理页，同样他们的写端所在的虚拟也也都映射到了同一个物理页。</p><p>此外，父子进程中这四个fd所对应的文件数据都位于同一个物理页。所以，一个管道实际上只需要占用3个物理页。图示如下——<br><img src="mm.svg"></p><h3 id="spawn函数的处理流程">spawn函数的处理流程</h3><p><code>spawn</code>函数的处理流程如下图所示<br><img src="spwan.svg"></p><h2 id="体会与感想">体会与感想</h2><p>Lab6要求我们完成pipe机制和实现一个简单的shell，实验任务比较简单，但是与之相关的很多函数理解起来还是有点困难。不过，OS实验课总算是告一段落了，通过自己动手实现一个简单的操作系统，不仅让我们收获了很多成就感，同时也让我们对理论课知识有了更深刻的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OO」第四单元：UML建模语言</title>
      <link href="/2022/06/26/oo/oo-di-si-dan-yuan-zong-jie/"/>
      <url>/2022/06/26/oo/oo-di-si-dan-yuan-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>在学习这一单元之前，我们仅仅是将UML当作一种"画图工具"，仅仅知道它能帮助我们画出各种各样的类图、顺序图、状态图等等。但是，这样我们只是看到了UML的表象，却没有深刻理解其“统一建模语言”的本质。<strong>既然UML是一种语言，那它就应该既有"词汇"，又有"语法"</strong>。通过理论课的学习我们已经知道，UML中的"词汇"就是一个个元模型（例如UMLClass、UMLRegion等等），而“语法”就是各个UML元模型之间的层次关系和组合关系。而本单元的三次作业，就是围绕着UML的"词汇"和"语法"进行展开，要求我们准确理解类图、顺序图和状态图中各个元模型和它们之间的关系，并在此基础上进行建模，实现一个功能较为完备的UML解析器。</p><hr><h2 id="作业架构分析">作业架构分析</h2><h3 id="自建myelement类">自建MyElement类</h3><p>本单元的三次作业都是要求我们实现官方包<code>UserApi</code>接口中的方法，但是这并不意味着我们只需要写一个<code>MyImplementation</code>类就可以了（毕竟课程组怎么可能会这么温柔呢bushi）。尽管官方包已经将输入的json字符串解析并封装成了<code>UMLClass</code>、<code>UMLInterface</code>等类，但是这些类中的信息仅仅是从json中迁移过来，对于完成作业来说还是远远不够的。</p><p>由此，我们可以自己新建<code>MyClass</code>、<code>MyInterface</code>等类，里面不仅包含<code>UMLClass</code>、<code>UMLInterface</code>等类的内容，还可以根据需要添加新的信息。例如，<code>MyClass</code>可以添加"继承的所有类的集合"、"实现的所有接口的集合"，"所有成员变量的集合"，"所有成员方法的集合","继承深度"等等；<code>MyRegion</code>中可以添加"拥有的所有状态的集合"；<code>MyLifeline</code>中可以添加"所有发出的lostmessage的集合"，"所有收到的foundmessage的集合"等等。为了让自建类可以包含官方包已经封装好的类中的内容，我们可以通过"组合"的方式实现——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> depth<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">UmlClass</span> umlClass<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fatherSet<span class="token punctuation">;</span>          <span class="token comment">//继承的所有类</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sonSet<span class="token punctuation">;</span>             <span class="token comment">//被继承的所有类</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> interfaceSet<span class="token punctuation">;</span>       <span class="token comment">//实现所有接口</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> attributeSet<span class="token punctuation">;</span>       <span class="token comment">//所有成员变量</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> operationSet<span class="token punctuation">;</span>       <span class="token comment">//所有成员方法</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> associationEndSet<span class="token punctuation">;</span>  <span class="token comment">//所有拥有的</span>    <span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> allClasses<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> allInterfaces<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> allAttributes<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="层次化建模">层次化建模</h3><p>因为输入的json字符串的顺序无法得到保证，所以可能出现<code>UMLGeneration</code>和<code>UMLInterfaceRealization</code>等元模型的出现时间要早于<code>UMLClass</code>和<code>UMLInterface</code>和其他类似的情况，这给我们封装自建类带来的困难。一个比较好的解决办法是多次遍历<code>elements</code>，根据不同元模型之间的依赖关系来先后解析不同的<code>UMLElement</code>、并封装成<code>MyElement</code>。</p><p>经过三次作业的迭代，我们最终可以通过5次遍历来解析所有的元模型——</p><ul><li><strong>Loop1:UMLClass、UMLInterface、UMLStateMachine、UMLCollaboration</strong></li><li><strong>Loop2:UMLOperation、UMLAttribute、UMLGeneralization、UMLInterfaceRealization、UMLAssociation、UMLInteraction、UMLRegion</strong></li><li><strong>Loop3:UMLParameter、UMLAssociationEnd、UMLLifeline、UMLEndpoint、UMLState、UMLPseudostate、UMLFinalState</strong></li><li><strong>Loop4: UMLMessage、UMLTransition</strong></li><li><strong>Loop5: UMLEvent、UMLOpaqueBehavior</strong></li></ul><p>这5次遍历可以直接在<code>MyImplementation</code>里进行。而为了防止因为行数过长而被StyleChecker制裁，我单独设置了一个<code>Loop</code>类来封装所有的遍历过程。·<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">MyImplementation</span><span class="token punctuation">(</span><span class="token class-name">UmlElement</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Dict</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Loop</span><span class="token punctuation">.</span><span class="token function">loop1</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Loop</span><span class="token punctuation">.</span><span class="token function">loop2</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Loop</span><span class="token punctuation">.</span><span class="token function">loop3</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Loop</span><span class="token punctuation">.</span><span class="token function">loop4</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Loop</span><span class="token punctuation">.</span><span class="token function">loop5</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="字典类">字典类</h3><p>可以发现，MyClass中<code>fatherSet</code>、<code>sonSet</code>等容器类存放的都是<code>String</code>类型的对象，很显然这些字符串都是表示元模型的id。因为每个元模型的id都是不同的，所以这样做既有操作上的便利性，也有实现上的可行性和安全性。<strong>但是——我们怎么通过id来找到对应的<code>MyElement</code>或者<code>UMLElement</code>呢？</strong>（有些UMLElement实际上不需要添加心得内容，因此不需要新建对应的MyElement）</p><p>为了解决这个问题，我新建了一个字典类——<code>Dict</code>，这个类中存放着所有的MyElement或者UMLElement。同时为了实现"根据id查找"和"根据name进行查找"，我使用了HashMap作为容器来存放。</p><p>此外，Dict实际相当于全局的"recorder"和"seacher"，为了保证在整个项目中只有一个实例，我还在Dict类中应用了单例模式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dict</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Dict</span> <span class="token constant">DICT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Class Diagram</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyClass</span><span class="token punctuation">&gt;</span></span> classMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyInterface</span><span class="token punctuation">&gt;</span></span> interfaceMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyOperation</span><span class="token punctuation">&gt;</span></span> operationMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyAttribute</span><span class="token punctuation">&gt;</span></span> attributeMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyParameter</span><span class="token punctuation">&gt;</span></span> parameterMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyAssociation</span><span class="token punctuation">&gt;</span></span> associationMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">UmlAssociationEnd</span><span class="token punctuation">&gt;</span></span> associationEndMap<span class="token punctuation">;</span>    <span class="token comment">// Sequence Diagram</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyInteraction</span><span class="token punctuation">&gt;</span></span> interactionMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyLifeline</span><span class="token punctuation">&gt;</span></span> lifelineMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">UmlEndpoint</span><span class="token punctuation">&gt;</span></span> endpointMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">UmlMessage</span><span class="token punctuation">&gt;</span></span> messageMap<span class="token punctuation">;</span>    <span class="token comment">// State Diagrame</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyStateMachine</span><span class="token punctuation">&gt;</span></span> stateMachineMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyRegion</span><span class="token punctuation">&gt;</span></span> regionMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyState</span><span class="token punctuation">&gt;</span></span> stateMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyPseudoState</span><span class="token punctuation">&gt;</span></span> pseudoStateMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyFinalState</span><span class="token punctuation">&gt;</span></span> finalStateMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyTransition</span><span class="token punctuation">&gt;</span></span> transitionMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">UmlEvent</span><span class="token punctuation">&gt;</span></span> triggerMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">UmlOpaqueBehavior</span><span class="token punctuation">&gt;</span></span> effectMap<span class="token punctuation">;</span>    <span class="token comment">// map for ’searching by name‘</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">&lt;</span><span class="token class-name">MyClass</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> classNameMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">&lt;</span><span class="token class-name">MyInteraction</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> interactionNameMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">&lt;</span><span class="token class-name">MyStateMachine</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> stateMachineNameMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Dict</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">DICT</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// functions for add</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addClass</span><span class="token punctuation">(</span><span class="token class-name">UmlClass</span> umlClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterface</span><span class="token punctuation">(</span><span class="token class-name">UmlInterface</span> umlInterface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLifeline</span><span class="token punctuation">(</span><span class="token class-name">UmlLifeline</span> umlLifeline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// functions for searching by id</span>    <span class="token keyword">public</span> <span class="token class-name">MyClass</span> <span class="token function">getClassById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyInterface</span> <span class="token function">getInterfaceById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyLifeline</span> <span class="token function">getLifelineById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// functions for searching by name</span>    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyClass</span><span class="token punctuation">&gt;</span></span> <span class="token function">getClassByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyInteraction</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInteractionByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyStateMachine</span><span class="token punctuation">&gt;</span></span> <span class="token function">getStateMachineByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行<code>elements</code>的五次遍历时，我们可以将遍历到的<code>UMLElement</code>通过<code>Dict</code>类的add方法加入到对应的容器中。需要注意的是，对于那些需要扩展的<code>UMLElement</code>，<code>Dict</code>会先调用自建类的构造方法将其转化成<code>MyElement</code>，然后再加入对应的容器。</p><h2 id="架构设计思维和oo方法理解的演进">架构设计思维和OO方法理解的演进</h2><ul><li><p><strong>第一单元的主题是"表达式展开"</strong>，主要是想让我们初步接触面向对象的思想，感受OO方法的魅力。OO的世界观就是"一切皆是对象"，但是要真正理解这句话，还需要学会如何从一个具体问题中抽象出若干对象。第一个单元恰好给我们提供了一个具体情境——表达式展开问题，需要我们从中抽象出一系列对象来帮助我们解决问题。从全局来看，表达式本身可以看作对象；站在表达式的角度，表达式由一个个项通过+ 或者 - 来连接，因此项也能看作对象；站在项的角度，项是由一个个因子通过*来链接，因此因子也是对象。这个单元的训练让我们深刻体会到了面向对象编程的优势——通过从问题中抽象出一系列对象，我们可以建立一个层次化、模块化的结构，从而降低了问题的复杂度。</p></li><li><p><strong>第二单元的主题是"电梯调度"</strong>，要求我们将关注点从"对象的行为"转移到"对象的交互"。所有的对象都不是孤立存在的，只有和其他的对象建立联系、进行交互，才可以实现一个更大的功能。但是在多线程的场景下，对象之间的交互时机、交互结果都具有了不确定性，带来了很大的安全隐患。因此，我们需要结合实际场景对线程安全问题进行分析和解决——哪些对象之间的交互存在着安全隐患？如何合理的加锁既能防止死锁，又能保证效率?只有解决了线程安全问题，才能保证对象之间的交互"乱中有序"、符合预期。</p></li><li><p><strong>第三单元的主题是"JML规格"</strong>，要求我们能够理解JML规格语言，并能基于规格进行代码实现。但是我相信课程组开设这一单元的主要目的并不是要让我们学会使用JML（毕竟JML是真的冷门），而是想让我们在"面向规格编程"的过程中感受到“契约式编程”的魅力——高可靠性、高复用性、便于测试。此外这个单元的三次作业也让我体会到——契约仅仅是对程序的功能做出了限制，在不违背契约的前提下，还需要重点关注如何高效的实现契约，这就很考验我们设计算法的能力了。</p></li><li><p><strong>第四单元的主题是"UML建模语言"</strong>，要求我们深入理解UML语言中各个元模型和它们之间的关系，据此为每一个元模型建立对象，并使所有对象形成一个层次化结构，最终实现对UML的解析。这个单元使我们进一步感受到UML语言的"面向对象"本质，进一步加深对面向对象思想的理解。</p></li></ul><h2 id="测试的理解和实践">测试的理解和实践</h2><p>在这四个单元中我都是采用了<strong>"单元测试+随机测试+边缘数据测试"</strong> 的测试流程。</p><ul><li><p><strong>单元测试主要是在 "coding" 阶段进行的。</strong>每当写完一个(或几个)可以实现特定功能的类后，我会先在test文件夹下新建一个测试类，然后使用junit对这个（或这些）类的各个方法进行测试。如果测试没有问题，再去实现其他功能。这是以前用SprintBoot开发后端时养成的习惯，这样做可以尽早将一些不必要的bug定位出来，减轻后期整体测试时的工作量。</p></li><li><p><strong>当我们将整个项目写完后，需要对其进行完整、系统的测试，以确定我们的设计是否符合要求，输出是否合法。</strong>我主要采用了自动化随机测试的方法进行整体测试，而这就需要评测机来发挥作用了。整个评测机主要包含两个部分——数据生成器和正确性检查，这样进行分离可以使得评测机拥有很好的可扩展性，降低迭代时的复杂度。<br> <br><strong>在第一单元，我仍然是按照作业中"递归下降"的思想来生成数据，并设置变量对递归次数、系数大小进行控制，从而保证可以生成不同复杂度的数据，提高覆盖率。</strong>因为有了Python中 sympy库的加持，我们可以直接对代码输出进行正确性判断，提高了测试的可靠性。但是后面几个单元都没有了标准答案可供参考，因此只能通过对拍的方式进行评测。<br> <br><strong>在第二单元</strong>，我也是采是用随机数的方式来生成乘客请求，但是请求不能任其随机分布，还需要对某楼层或者某楼座进行压力测试，即只针对一楼层（座）生成大量请求。另外，我们可能还需要仅对横向电梯测试或者仅对纵向电梯测试。<strong>为了满足多样性的需求，我为数据生成器增加了许多“模式”可以选择。这样可以检查在不同情境下代码的性能表现和运行结果，更好的排查死锁和电梯灵异现象。</strong>当然在设计数据生成器时还需要注意指导书上的一些"数据规范"，我们可以通过设置常量进行限制，如果直接将数据限制在代码里写死，将不利于评测机的修改和迭代。本单元的正确性检查主要采用对拍的方式，但由于代码需要模拟电梯运行的时间延迟，每次跑一个数据可能会耗时一两分钟，如果所有对拍的代码都采用串行的方式运行，测试效率将会受到极大的限制，因此我们可以使用python的subprocess函数创建多个子进程，实现对不同测试者的代码"同时"进行测试，充分利用并发的优势，提高测试效率。<br> <br><strong>在第三单元</strong>，作业内容涉及到了图的建立，<strong>如果完全随机生成数据的话，图的复杂度可能会非常低（例如图中大多数都是孤立结点）。为了提高数据的强度，我在数据生成器里设置一些数据结构</strong>，用来存储"所有group、person、message的id"，"group和person之间的关联关系"、"当前生成的图的状态（如连通性）"等等。每当需要生成一个指令，我们都需要参考数据结构，根据数据状态进行生成。此外，JML规格中已经描述了每个方法可能出现的各种正常、异常情况，我们在生成每个方法对应的指令时，一定要为每种情况设置一定的出现概率，而这也需要数据结构来保证。<br> <br><strong>在第四单元</strong>涉及到了不同元模型之间的复杂关系，我们同样可以通过设置数据结构来保证数据的强度。<strong>但是，由于和作业相关的元模型数量很多，关系也错综复杂，如何仍然采用面向过程来设计数据生成器，将会使复杂度变得不可控，同时也会影响生成数据的正确性和强度。因此，本单元我主要采用了面向对象的思维来设计数据生成器。</strong>尽管代码行数显著增多（迭代到第三次作业时已经达到1300余行），但是设计和实现的过程并不复杂，同时还能在coding 的过程中加深对UML元模型及其关系的理解。<br> </p></li><li><p><strong>边缘化数据测试是整个测试过程中最关键、也是最容易发现bug的阶段。</strong>受限于随机数的偶然性和数据生成器的生成算法，自动化随机测试不能够保证能够覆盖到所有的情况。对于一些特殊的情况，我们还是需要采取"手撸"的方式构造一些有针对性的、刁钻的数据，从而弥补随机测试的短板，提高测试的全面性。</p></li></ul><h2 id="课程收获">课程收获</h2><ul><li>学会了Java语言，初步建立了面向对象的思想，并且掌握了很多基本的设计模式，感受到了设计方法论的魅力。</li><li>学习了很多测试方法（junit单元测试、基于JML规格的测试），同时也提高了写数据生成器和测评机的能力，并且在此过程中学会了很多python、shell技能。</li><li>在做作业的过程中逐渐养成了"先充分设计再动手实现"的习惯，不再像大一时那样拿过题目就直接coding。</li><li>在架构讨论和对拍测试的过程中认识了很多新朋友，也充分感受到了团队合作的力量。</li></ul><h2 id="改进建议">改进建议</h2><ul><li>希望在预习课程或者第一单元博客周增设"多线程系统学习栏目"，让同学们尽早地接触多线程的基本思想和基本方法，以减轻第二单元的压力。</li><li>希望互测和公测的数据限制保持一致（本地能够用公测数据hack人，但是却交不上去的感觉真的很难受），同时希望在提交了不合法数据时，评测机提供一些错误信息，以便提交者对数据进行修改。</li><li>希望在实验课中增加提交反馈或者在课后公布答案，让同学们清楚在实验课中暴露出的问题，以便在课后及时弥补。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab5：文件系统</title>
      <link href="/2022/06/04/os/os-lab5-shi-yan-bao-gao/"/>
      <url>/2022/06/04/os/os-lab5-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-5.1">Thinking 5.1</h3><p><strong>Q：</strong> <strong>查阅资料，了解 Linux/Unix 的 /proc文件系统是什么？有什么作用？ Windows操作系统又是如何实现这些功能的？proc文件系统这样的设计有什么好处和可以改进的地方？</strong></p><p><strong>A：</strong><code>/proc</code>是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，<strong>用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态</strong>。</p><p>这样设计可以让用户以访问文件的方式访问进程信息，方便了用户的使用。此外，它只存在内存当中，而不占用外存空间，省去了访问一般文件时将数据从外存加载入内存的时间开销，访问速度非常快。但是正因如此，它会占用很多的内存空间。</p><p><strong>Windows系统是通过使用<code>WMI</code>来实现相似功能的</strong>——<code>WMI</code>是可伸缩的系统管理结构，该规范采用⼀个统一、基于标准且可扩展的面向对象接口。它提供与系统管理员信息和基础<code>WMI API</code>交互的标准方法，主要由系统管理应用程序开发⼈员和系统管理员⽤来访问和操作系统管理信息；它可用来生成组织和管理系统信息的工具，使系统管理⼈员能够更密切的监视系统活动。</p><h3 id="thinking-5.2">Thinking 5.2</h3><p><strong>Q：</strong> <strong>如果我们通过 kseg0读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。</strong></p><p><strong>A：</strong>当外部设备自身更新数据时，如果此时CPU写入外设的数据还只在缓存中，<strong>则缓存的那部分数据就只能在外设自身更新后再写入外设</strong>（只有缓存块将要被新进入的数据取代时，缓存数据才会被写入内存），这样就会发生错误的行为。</p><p>串口设备读写频繁，而IDE磁盘读写频率相对较小，因此串口设备发生错误的概率要远大于IDE磁盘。</p><h3 id="thinking-5.3">Thinking 5.3</h3><p><strong>Q：</strong> <strong>比较 MOS 操作系统的文件控制块和Unix/Linux 操作系统的 inode及相关概念，试述二者的不同之处。</strong></p><p><strong>A：</strong>文件控制块和inode都是记录已打开文件的相关信息，但是两者又有很多不同。</p><ul><li><strong>存储内容不同</strong>,文件控制块中的内容有——<ul><li>文件名</li><li>文件大小</li><li>文件类型</li><li>文件数据块的直接指针列表</li><li>储存文件数据块指针的间接磁盘块指针</li><li>文件所在目录的指针</li></ul>而inode中的内容包括——<ul><li>文件的字节数，块数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li><li>链接数，即有多少文件名指向这个inode</li><li>文件数据block的位置</li><li>inode编号</li></ul></li><li>文件控制块顺次排列在目录文件中，而在Linux系统中，目录文件是由一系列目录项组成，每个目录项由文件名和指向inode的指针组成，占用空间远远小于文件控制块，查找操作的系统开销也大大减小。</li><li>MOS中的文件控制块仅支持一级间接指针域，也只有一个；而Linux中的inode支持多级间接指针域，可以存储更大的文件。</li></ul><h3 id="thinking-5.4">Thinking 5.4</h3><p><strong>Q：</strong><strong>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</strong></p><p><strong>A：</strong>通过查看文件控制块的定义，我们可以发现，每个文件控制块都被数组<code>f_pad</code>强制对齐为<strong>256B</strong>。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token punctuation">{</span>u_char f_name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>u_int f_size<span class="token punctuation">;</span>u_int f_type<span class="token punctuation">;</span>u_int f_direct<span class="token punctuation">[</span>NDIRECT<span class="token punctuation">]</span><span class="token punctuation">;</span>u_int f_indirect<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f_dir<span class="token punctuation">;</span>    <span class="token comment">//BY2FILE = 256</span>u_char f_pad<span class="token punctuation">[</span>BY2FILE <span class="token operator">-</span> MAXNAMELEN <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> NDIRECT <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>一个磁盘块的容量为4KB，因此最多可以容纳16个文件控制块。</li><li>一个目录文件最多可以使用1024个磁盘块存储数据，因此一个目录下最多1024*16= 16384个文件。</li><li>一个文件最多可以使用1024个磁盘块存储数据，因此一个文件最大容量为1024*4KB= 4MB。</li></ul><h3 id="thinking-5.5">Thinking 5.5</h3><p><strong>Q：</strong><strong>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</strong><br><strong>A：</strong>块缓存所在的地址空间为<code>[0x10000000, 0x50000000)</code>,因此我们的内核能够支持的磁盘大小为<code>0x40000000</code>,也就是1GB。</p><h3 id="thinking-5.6">Thinking 5.6</h3><p><strong>Q：</strong> <strong>如果将 DISKMAX 改成 0xC0000000,超过用户空间，我们的文件系统还能正常工作吗？为什么？</strong><br><strong>A：</strong>不可以正常工作。如果<code>DISHMAX</code>值为<code>0xC0000000</code>，则有一部分块缓存会在内核空间中。而我们的文件系统属于文件用户态进程，无法访问内核空间的数据（访问内核空间数据时会出现<code>TOO LOW</code>报错）。</p><h3 id="thinking-5.7">Thinking 5.7</h3><p><strong>Q：</strong> <strong>在 lab5 中，fs/fs.h、include/fs.h等文件中出现了许多结构体和宏定义，写出你认为比较重要或难以理解的部分，并进行解释。</strong><br><strong>A：</strong>文件控制块（<code>File</code>）定位文件数据的方式比较重要，需要特别关注。每个文件的数据分布在不相邻的一系列磁盘块中，我们可以将其称为文件数据块，每个文件对应的文件控制块里都记录了所有文件数据块的指针（即下标）。文件控制块有<code>10</code>个直接指针，保存在数组<code>f_direct[10]</code>中，另外还有<code>1014</code>个间接指针（前10个保留不用），这些指针储存在<code>f_indirect</code>所指向的磁盘块中。示意图可见”实验难点图示“部分。</p><h3 id="thinking-5.8">Thinking 5.8</h3><p><strong>Q：</strong> <strong>阅读user/file.c，你会发现很多函数中都会将一个 struct Fd* 型的 指针转换为struct Filefd* 型的指针，请解释为什么这样的转换可行。</strong><br><strong>A：</strong> 首先，每个文件描述符fd都独占一页的，远大于structFd和<code>struct Filefd</code>的大小，因此将<code>struct Fd*</code>强制转换为<code>struct Filefd*</code>不会访问其他不相关的数据。<br>其次，每个<code>strcut Filefd</code>的开头都包含一个<code>struct File</code>，将<code>struct Fd*</code>强制转换为<code>struct Filefd*</code>后，同样可以通过<code>p-&gt;f_fd</code>来访问原先<code>struct Fd</code>中数据。这和面向对象中基类和派生类的关系十分相似，如果将<code>struct Fd</code>想象成基类，<code>struct File</code>想象成派生类，将基类的指针"向下转型"到派生类的指针是没有任何问题的。</p><h3 id="thinking-5.9">Thinking 5.9</h3><p><strong>Q：</strong> <strong>在lab4 的实验中我们实现了极为重要的fork函数。那么fork前后的父子进程是否会共享文件描述符和定位指针呢？请在完成练习5.8和5.9的基础上编写一个程序进行验证。</strong><br><strong>A：</strong>一个进程所有的文件描述符都存储在<code>[FDTABLE, FILEBASE)</code>这一地址空间中。在<code>fork</code>函数执行时，会将这父进程页表中映射一部分地址的页表项拷贝到子进程的页表中，因此<code>fork</code>前后的父子进程会共享文件描述符和定位指针。</p><h3 id="thinking-5.10">Thinking 5.10</h3><p><strong>Q：</strong> <strong>请解释Fd, Filefd, Open结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</strong><br><strong>A：</strong></p><ul><li><p><strong>Fd结构体定义及各个域的作用如下所示</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token punctuation">{</span>u_int fd_dev_id<span class="token punctuation">;</span>    <span class="token comment">//文件对应的设备id</span>u_int fd_offset<span class="token punctuation">;</span>    <span class="token comment">//文件指针所指向的位置</span>u_int fd_omode<span class="token punctuation">;</span>     <span class="token comment">//文件打开模式</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该结构体主要用于记录已打开文件的状态，便于用户直接使用文件描述符对文件进行操作、申请服务等等。由于文件描述符主要是为用户所使用，因此它对应的是磁盘映射到内存中的数据。<p></p></li><li><p><strong>Filefd的结构体定义及各个域的作用如下所示</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> f_fd<span class="token punctuation">;</span>     <span class="token comment">//文件描述符结构体</span>u_int f_fileid<span class="token punctuation">;</span>     <span class="token comment">//文件id，表示该文件在opentab中的位置</span><span class="token keyword">struct</span> <span class="token class-name">File</span> f_file<span class="token punctuation">;</span> <span class="token comment">//文件控制块</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>文件描述符中存储的数据毕竟是有限的，有的时候我们需要将<code>Fd*</code>强制转换为<code>Filefd*</code>从而获取到文件控制块，从而获得更多文件信息，比如文件大小等等。<p></p></li><li><p><strong>Open结构体定义及各个域的作用如下所示</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Open</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>o_file<span class="token punctuation">;</span><span class="token comment">// 文件控制块指针</span>u_int o_fileid<span class="token punctuation">;</span>    <span class="token comment">// 文件id</span><span class="token keyword">int</span> o_mode<span class="token punctuation">;</span>        <span class="token comment">// 文件打开方式</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>o_ff<span class="token punctuation">;</span><span class="token comment">// Filefd结构体</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这个结构体主要被文件系统服务进程使用，用于记录所有进程中被打开的文件。每个被打开的文件都对应一个<code>Open</code>结构体，所有的结构体依次排列在数组<code>opentab[MAXOPEN]</code>，每次我们只需要通过<code>file_id</code>来查找即可。<p></p></li></ul><h3 id="thinking-5.11">Thinking 5.11</h3><p><strong>Q：</strong><strong>UML时序图中有多种不同形式的箭头，请结合UML时序图的规范，解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</strong></p><p><strong>A：</strong> UML时序图中有以下几种箭头——</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">消息类型</th><th style="text-align: center;">表示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>同步消息</strong></td><td style="text-align: center;">用黑三角箭头搭配黑实线表示</td></tr><tr class="even"><td style="text-align: center;"><strong>异步消息</strong></td><td style="text-align: center;">用两条小线的开箭头和黑色实线表示</td></tr><tr class="odd"><td style="text-align: center;"><strong>返回消息</strong></td><td style="text-align: center;">用黑三角箭头搭配黑色虚线表示</td></tr><tr class="even"><td style="text-align: center;"><strong>创建消息</strong></td><td style="text-align: center;">用开三角箭头搭配黑实线表示，其下面特别注明<code>&lt;&lt;create&gt;&gt;</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>摧毁消息</strong></td><td style="text-align: center;">用黑三角箭头搭配黑实线表示，其下面特别注明<code>&lt;&lt;destroy&gt;&gt;</code></td></tr><tr class="even"><td style="text-align: center;"><strong>Lost and FoundMessage</strong></td><td style="text-align: center;">用一个黑色实心的点和黑色实心三角箭头黑实线表示</td></tr></tbody></table><p>我们的操作系统是通过IPC来实现进程间通信的，这种方式传递的信息本质上是一种同步消息。具体流程是：发送方先调用<code>ipc_send</code>函数，该函数通过一个死循环来不断向接收方信息。当接收方成功接收到消息时，<code>ipc_send</code>函数跳出循环并结束，这时发送方再调用<code>ipc_recv</code>函数主动放弃CPU，等待接收返回信息。</p><p>整个流程在函数<code>fsipc</code>里得到体现<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fsipc</span><span class="token punctuation">(</span>u_int type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>fsreq<span class="token punctuation">,</span> u_int dstva<span class="token punctuation">,</span> u_int <span class="token operator">*</span>perm<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int whom<span class="token punctuation">;</span><span class="token function">ipc_send</span><span class="token punctuation">(</span>envs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>env_id<span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>fsreq<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">ipc_recv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>whom<span class="token punctuation">,</span> dstva<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-5.12">Thinking 5.12</h3><p><strong>Q：</strong><strong>阅读serv.c/serve函数的代码，我们注意到函数中包含了一个死循环<code>for (;;) {...}</code>，为什么这段代码不会导致整个内核进入panic状态？</strong><br><strong>A：</strong>这个死循环并不会导致CPU的轮询，原因是每次循环会调用<code>ipc_recv</code>函数。在这个函数被调用后，文件系统服务进程就会主动让出CPU（进程状态被标记为<code>NOT_RANNABLE</code>），直到用户进程向该进程申请服务（调用<code>ipc_send</code>）时才会被唤醒，进而为用户进程提供服务。因此，循环的次数始终等于文件系统服务进程提供服务的次数，并不会导致内核进入<code>panic</code>状态。</p><h2 id="实验难点图示">实验难点图示</h2><p>我认为本次实验主要包含以下难点——</p><ul><li><strong>文件数据块的定位方式</strong></li><li><strong>fsformat.c中函数的调用关系</strong></li><li><strong>文件系统的地址空间布局</strong></li><li><strong>用户进程和文件系统服务进程的交互</strong></li></ul><h3 id="文件数据块的定位方式">文件数据块的定位方式</h3><p>每个文件的数据分布在不相邻的一系列磁盘块中，我们可以将其称为文件数据块，每个文件对应的文件控制块里都记录了所有文件数据块的指针（即下标）。文件控制块中有10个直接指针，保存在数组<code>f_direct[10]</code>中，另外还有<code>1014</code>个间接指针（前10个保留不用），这些指针储存在<code>f_indirect</code>所指向的磁盘块中。</p><p>假设某文件是一个目录文件，则其定位数据块的方式如下图所示<br><img src="file_data.drawio.svg"></p><h3 id="fsformat.c中函数的调用关系">fsformat.c中函数的调用关系</h3><p>在本次实验中，我们需要通过<code>fsformat.c</code>文件创建磁盘镜像<code>gxemul/fs.img</code>，这个磁盘镜像可以模拟与真实的磁盘文件设备之间的交互。<br><code>fsformat.c</code>中函数的调用关系如下所示——</p><p><img src="fsformat.drawio.svg"></p><h3 id="文件系统的地址空间布局">文件系统的地址空间布局</h3><p>文件系统的正常工作也需要占用一定的内存空间。</p><ul><li><p>文件服务进程需要占用<code>[0x10000000, 0x50000000)</code>这一1GB空间作为块缓存。</p></li><li><p>用户进程还需要占用<code>[0x5fc00000, 0x600000000)</code>这一4MB空间来储存文件描述符。</p><blockquote><p>因为用户进程最多只能开32个文件描述符，每个文件描述符占用一页，因此实际上这一空间是无法占满的，最多占用32*4KB=128KB。</p></blockquote></li><li><p>用户进程需要占用<code>[0x60000000, 0x680000000)</code>这一128MB空间作为文件内容缓存区。缓存区的每个页面都和文件服务进程中的对应块缓存映射到同一个物理页，并标记为<code>PTE_LIBARAY</code>。</p><blockquote><p>因为用户进程最多只能有32个文件描述符，因此只能同时打开32个文件，每个文件最多占用4MB空间，因此用户进程缓存区大小为32*4MB=128MB。</p></blockquote></li></ul><p>地址空间布局如下所示<br><img src="map.drawio.svg"></p><h3 id="用户进程和文件系统服务进程的交互">用户进程和文件系统服务进程的交互</h3><p>用户进程通过文件系统的用户接口申请服务，该请求会通过IPC机制告知文件系统服务进程（<code>fsipc.c</code>），然后由文件系统服务进程提供服务（<code>serve.c</code>）。不同用户接口及其服务的流程如下所示——<br><img src="process.drawio.svg"></p><h2 id="体会与感想">体会与感想</h2><p>本次实验的代码填写比较简单，根据代码注释和指导书的提示就可以轻松完成，评测拿到满分并不困难。</p><p>尽管实验任务比较简单，但是这次实验涉及的代码文件更多，新增代码多达千余行，新增结构体也有十几个，给代码的理解带来了很多困难。因此，要想真正理解每个函数的作用、函数之间的调用关系以及用户申请文件系统服务的流程，还需要下一番功夫。</p><hr><p>附录：<a href="">Lab 5 函数解读</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OO」第三单元:规格化设计</title>
      <link href="/2022/06/04/oo/oo-di-san-dan-yuan-zong-jie/"/>
      <url>/2022/06/04/oo/oo-di-san-dan-yuan-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>第三单元的主题是“规格化设计”，要求我们学会理解JML规格语言，并能基于规格进行代码实现。总的来说，本单元的三次作业都比较简单，只需要根据课程组提供给的规格进行编程即可。但是，<strong>规格仅仅是一种契约</strong>，针对一种特定的规格可能会有很多实现方法，因此我们在编程时还需要特别注意代码运行的效率（否则很容易TLE）。</p><p>我相信课程组开设这一单元的主要目的并不是要让我们学会使用JML这一语言（毕竟JML是真的冷门），而是想让我们在“面向规格编程”的过程中感受到“契约式编程”的魅力——<strong>高可靠性、高可复用性、便于测试...</strong></p><h2 id="第一次作业分析">第一次作业分析</h2><p><a href="面向对象第三单元第一次作业指导书.pdf">题目链接</a><br>第一次作业比较简单，只需要根据官方提供的Group、NetWork和Person这三个接口进行代码设计，实现简单社交关系的模拟和查询。</p><h3 id="uml类图">UML类图</h3><p><img src="1.svg"></p><h3 id="代码架构分析">代码架构分析</h3><p>这次作业我把重心放在代码效率的优化上，重点关注以下几个问题——</p><ul><li><strong>容器的选择</strong></li><li><strong>计算类函数的优化</strong></li><li><strong>并查集的优化</strong></li></ul><h4 id="容器的选择">容器的选择</h4><p>本次作业绝大多数指令都是通过<code>id</code>来寻找对应的<code>Group</code>或者<code>Person</code>。以<code>Person</code>为例，如果把所有的<code>Person</code>都放在一个<code>List</code>容器里，那么我们每次查找都需要遍历一遍容器，算法复杂度为<span class="math inline">\(O(n)\)</span>，很容易出现TLE。</p><p>最终，我选择了<code>HashMap</code>作为存储<code>Group</code>和<code>Person</code>的容器，将<code>id</code>作为键值，这样可以保证每次查询都能以<span class="math inline">\(O(1)\)</span>的复杂度完成，大大降低超时的概率。</p><h4 id="计算类函数的优化">计算类函数的优化</h4><p>本次作业有三个计算类函数——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*@ ensures \result == (\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length;   @          (\sum int j; 0 &lt;= j &amp;&amp; j &lt; people.length &amp;&amp;   @           people[i].isLinked(people[j]); people[i].queryValue(people[j])));  @*/</span><span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span> <span class="token keyword">int</span> <span class="token function">getValueSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*@ ensures \result == (people.length == 0? 0:  @          ((\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getAge()) / people.length));  @*/</span><span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span> <span class="token keyword">int</span> <span class="token function">getAgeMean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*@ ensures \result == (people.length == 0? 0 : ((\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length;   @          (people[i].getAge() - getAgeMean()) * (people[i].getAge() - getAgeMean())) /   @           people.length));  @*/</span><span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span> <span class="token keyword">int</span> <span class="token function">getAgeVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>为了进一步提高代码效率，我对这几个函数中需要计算的数据进行了维护。以getAgeMean()为例，我设置了一个<code>ageSum</code>用来表示group中所有人年龄总和，每次向<code>group</code>中加人时维护<code>ageSum</code>，在<code>getAgeMean</code>直接返回<code>ageSum/people.size()</code>即可。<p></p><p>在函数<code>getAgeVar()</code>中还隐藏着一个坑——因为<code>getAgeMean()</code>的返回值已经被向下取整了，因此<span class="math inline">\(\frac{\sum_{i = 1}^n(age_i -ageMean)^2}{n}\)</span> 不恒等于 <span class="math inline">\(\frac{(\sum_{i=1}^nage_i^2) - n\timesageMean^2}{n}\)</span>。正确的做法是将其拆解为 <span class="math inline">\(\frac{(\sum_{i=1}^nage_i^2) - 2\times ageMean\times(\sum_{i=1}^nage_i)+ n\timesageMean^2}{n}\)</span>，同时，我们还需要设置一个<code>agePowSum</code>变量表示年龄平方和，也是每次在加人的时候维护。这样在调用<code>getAgeVar()</code>函数时，我们只需要将<code>ageSum</code>和<code>agePowSum</code>代入即可，同样可以保证计算复杂度为<span class="math inline">\(O(1)\)</span>。</p><h4 id="并查集的优化">并查集的优化</h4><p>本次作业中的<code>isLinked()</code>函数要求查询两个<code>Person</code>之间的连通性，对于这个问题，我们当然可以用<strong>dfs</strong>递归查询，复杂度并不算高，但也不算优秀。所以有没有有比dfs复杂度更低的方法呢？答案当然是有，<strong>我们可以采用并查集算法进行优化</strong>。（对于并查集算法的原理，<a href="http://oo.buaa.edu.cn/assignment/344/discussion/1182">讨论区的教学帖</a>已经讲得很清楚了，此处不再赘述。）</p><p>为了更好的符合“面向对象”的设计思想，我们可以将并查集封装成类，在类中用<code>HashMap</code>来存储结点的父子关系，用<code>find()</code>、<code>merge()</code>、<code>add()</code>等方法封装并查集的相关操作。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DisjointSet</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> pre<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> rank<span class="token punctuation">;</span>     <span class="token comment">// 在“按秩合并”里用到</span>    <span class="token keyword">public</span> <span class="token class-name">DisjointSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>            rank<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此外，为了进一步减小复杂度，我对并查集做了两种优化——<p></p><ul><li><p><strong>路径压缩:</strong></p><p>当我们查找一个元素所在集合的代表元时，可以将查找路径上所有元素的直接上级设为代表元。<br><img src="路径压缩.png"></p><p>我们可以直接在<code>find</code>函数里实现这个优化<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> rep <span class="token operator">=</span> id<span class="token punctuation">;</span> <span class="token comment">//representation element</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rep <span class="token operator">!=</span> pre<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        rep <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> now <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>now <span class="token operator">!=</span> rep<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fa <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> rep<span class="token punctuation">)</span><span class="token punctuation">;</span>        now <span class="token operator">=</span> fa<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rep<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>注意：不能使用递归的方法来寻找代表元，否则很可能会爆栈。</p></blockquote></li><li><p><strong>按秩合并:</strong></p><p>由于我们在找出一个元素所在集合的代表元时需要递归地找出它所在的树的根结点，所以为了减短查找路径，在合并两棵树时要尽量使合并后的树的高度降低，所以要将高度低的树指向高度更高的那棵。我们将树的高度称为秩，合并时将<strong>“小秩”集合的代表元</strong>的直接上级设为<strong>“大秩”集合的代表元</strong>。<br><img src="按秩合并.png"></p><p>我们需要在<code>merge</code>函数里实现这个优化<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> fa1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fa2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fa1 <span class="token operator">==</span> fa2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> rank1 <span class="token operator">=</span> rank<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fa1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rank2 <span class="token operator">=</span> rank<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fa2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rank1 <span class="token operator">&lt;</span> rank2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>fa1<span class="token punctuation">,</span> fa2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank1 <span class="token operator">==</span> rank2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rank<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>fa1<span class="token punctuation">,</span> rank1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>fa2<span class="token punctuation">,</span> fa1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h2 id="第二次作业分析">第二次作业分析</h2><p><a href="面向对象第三单元第二次作业指导书.pdf">题目链接</a><br>第二次作业新增了message类，要求我们根据规格进一步实现消息增加、消息发送等功能。</p><h3 id="uml类图-1">UML类图</h3><p><img src="2.svg"></p><h3 id="代码架构分析-1">代码架构分析</h3><p>这次作业又增加了几个查询指令，可以直接用第一次作业的方法来减小复杂度（选择map、设置变量维护等等）。除此之外，我们还需要特别关注<code>query_least_connection</code>这个指令。</p><p>这个指令的JML描述实在是太冗长了，不过核心思想很简单，就是要求我们得到<strong>person_id所在联通分支的最小生成树</strong>，并算出最小生成树里所有边的权重和。一般来说，最小生成树的计算方法有两种——<strong>Kurskal算法和Prim算法</strong>，因为我在第一次作业已经封装好了并查集类<code>DisjointSet</code>，自然使用<strong>Kurskal算法</strong>会更方便一点。</p><p>选择好了算法，我们还需要关注两个问题——</p><ul><li>如何获得<code>person_id</code>所在的连通分支？（只需获得连通分支里所有点和边即可）</li><li>如何对算法进行优化？</li></ul><h4 id="联通分支的获取">联通分支的获取</h4><p>在第一次作业中，我们已经实现了并查集，并且将<code>Network</code>里所有的点都加入到这个并查集里（我们姑且将这个并查集称为<strong>"全局并查集"</strong>，把Kruskal算法实现里的并查集称为<strong>"临时并查集"</strong>）。这样，我们就可以遍历所有的边，<strong>只要边的某个端点和person_id在一个连通分支里，那么这个边和它的两个端点都属于person_id所在的连通分支</strong>。具体遍历过程如下——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">queryLeastConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span> <span class="token punctuation">{</span>    <span class="token comment">//tempSet为临时并查集，存储联通分支里所有的点</span>    <span class="token class-name">DisjointSet</span> tempSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//tempedges为临时点集，存储连通分支里所有的边</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> tempEdges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//遍历所有的点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> id1 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id2 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>disjointSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span> <span class="token operator">==</span> disjointSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempEdges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便，我将边单独封装成类（<code>Edge</code>），类中记录<code>Edge</code>的两端点id和边的权重，并在<code>Network</code>里设置<code>edges</code>来储存所有的<code>Edge</code>。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> id1<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> id2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="kruskal算法优化">Kruskal算法优化</h4><p>标准Kruskal算法需要先对连通分支里所有的边进行排序，然后遍历所有的边，每次选择一个权重最小的边加入生成树。对于这个过程，我们可以采用<strong>优先队列</strong>进行优化。只需要将前面维护的<code>tempSet</code>传入<code>PriorityQueue类</code>的构造方法里，就可以得到一个由边组成的优先队列，这样每次就可以从队首获取一个最小边。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">queryLeastConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>people<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyPersonIdNotFoundException</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">DisjointSet</span> tempSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> tempEdges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> id1 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id2 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>disjointSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span> <span class="token operator">==</span> disjointSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempEdges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> times <span class="token operator">=</span> tempSet<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//构造优先队列</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>tempEdges<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//遍历优先队列，每次从队首获取最小边</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>priorityQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> times <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Edge</span> edge <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id1 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id2 <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token function">getId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tempSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span> <span class="token operator">!=</span> tempSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempSet<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>id1<span class="token punctuation">,</span> id2<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> edge<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">--</span>times<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="第三次作业分析">第三次作业分析</h2><p><a href="面向对象第三单元第三次作业指导书.pdf">题目链接</a><br>第三次作业将第二次作业中的<code>Message</code>进行了泛化，增加了继承自Message的许多新消息类型——<code>red_envelope_message</code>、<code>notice_message</code>和<code>emoji_message</code>。这些消息的增加和传递方式有所变化，只需要对照JML对代码稍作修改即可</p><h3 id="uml类图-2">UML类图</h3><p><img src="3.svg"></p><h3 id="代码架构分析-2">代码架构分析</h3><h4 id="迭代器删除">迭代器删除</h4><p>本次作业中的<code>delete_code_emoji</code>指令涉及到了对容器内容进行删除，如果直接在遍历时删除，很可能会出现意想不到RE错误。但是，使用迭代器对容器内容进行遍历和删除操作则不会出现问题。</p><p>在前几次作业里，我只用迭代器删除过<code>List</code>和<code>Set</code>里的元素。然而在这次作业里，为了减少时间复杂度我使用了<code>Map</code>作为容器，<strong>Map中键值对的删除操作与List、Set稍有不同</strong>——</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteColdEmoji</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Iterator</span> it<span class="token punctuation">;</span>    it <span class="token operator">=</span> emojis<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> entry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>            it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最短路径的求解">最短路径的求解</h4><p>前两次作业中都有和图论算法相关的问题，第三次作业作为压轴，自然也少不了。这次作业中<code>sendIndirectMessage</code>就是要求我们找一个最短路径，并将消息沿着该路径发送给指定的人，本质上就是一个<strong>单源最短路径问题</strong>。</p><p>谈到最短路径，我们首先想到的自然是<strong>以"松弛"为特色的Dijkstra算法</strong>。不过标准Dijstra算法的复杂度其实是<span class="math inline">\(O(n^2)\)</span>，当图的规模比较大、查询指令比较多的时候很容易出现TLE。因此，我们还需要<strong>使用堆进行优化</strong>。</p><p>我单独设置了一个函数来封装Dijstra算法的实现过程，该函数返回一个HashMap，key为person的id，value是出发点到person之间最短路径的长度。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 记录出发点到各个节点之间的距离</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> dis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录某个节点是否被访问过</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> vis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 创建优先队列</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// dis和vis的初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span> people<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dis<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dis<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 算法核心流程</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curId <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">getTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vis<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>curId<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MyPerson</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> people<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> friendId <span class="token operator">:</span> person<span class="token punctuation">.</span><span class="token function">getFriends</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">queryValueById</span><span class="token punctuation">(</span>friendId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>friendId<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> dis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curId<span class="token punctuation">)</span> <span class="token operator">+</span> w <span class="token operator">&lt;</span> dis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>friendId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dis<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>friendId<span class="token punctuation">,</span> dis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curId<span class="token punctuation">)</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>                heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>friendId<span class="token punctuation">,</span> dis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>friendId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dis<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>上述代码中，优先队列中存储的是我封装好的<code>Node</code>类，<code>Node</code>类中存储dis容器中的键值对，同时还需要重写<code>compareTo</code>方法，以便于优先队列的创建和维护。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Node</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">-</span> o<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">to</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处还有一个优化思路，我们的<code>dijkstra()</code>函数返回的是一个存储“开始节点到所有节点的最短距离”的HashMap，然而我们在查询的时候仅访问了这个HashMap中的一个<strong>键值对</strong>，很显然是比较浪费的。因此，我们可以在全局维护一个<strong>存储若干HashMap的容器</strong>（当然这个容器也可以是HashMap），每次调用<code>dijkstra()</code>都将得到的结果存放这个容器里，以便重复使用。需要注意的是，每次在图里增添节点（即person）后，该容器里所有的HashMap都失效了，可以设置一个<code>dirty</code>变量来记录。</p><h2 id="个人bug分析">个人bug分析</h2><p>在三次作业的强测和互测中均没有出现bug。</p><h2 id="关于测试">关于测试</h2><p>本单元还是延续自动化测试的传统。</p><p>因为对于每个指令都有唯一正确的输出，所以我们可以通过<strong>"对拍+文本比较"</strong>的方式对正确性进行验证。但是，如何编写数据生成器来生成高强度的数据呢？</p><p>数据生成器这个东西，写起来说容易也容易，说难也难——容易在我们可以直接对照着数据指令的格式，使用随机数的方法无脑造数据，但是<strong>难在无法保证数据的强度</strong>。尤其是这一单元涉及到了图的建立，如果完全随机生成数据的话，图的复杂度可能会非常低（例如图中大多数都是孤立结点）。</p><p>因此，我们不能完全依靠随机数生成指令。</p><h3 id="采用数据结构存储状态">采用数据结构存储状态</h3><p>为了提高数据的强度，我在数据生成器里设置一些数据结构，存储<strong>"所有group、person、message的id"，"group和person之间的关联关系"、"当前生成的图的状态（如连通性）"</strong>等等。每当需要生成一个指令，我们都需要参考数据结构，根据数据状态进行生成。此外，在生成指令时，我们还需要对相关数据结构进行维护。</p><p>我的数据生成器里设置了如下几个数据结构——<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 各个id的集合</span>person_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>group_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>msg_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>emoji_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>money_msg_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>emoji_msg_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>notice_msg_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>link_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>           <span class="token comment"># 记录person之间的联通关系</span>group_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>          <span class="token comment"># 记录每个group下所有person的id</span>msg_info_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment"># 记录每个message的相关信息</span>emoji_heat_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token comment"># 记录所有emoji </span>max_heat <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 记录emoji的最大热度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="面向jml生成数据">面向JML生成数据</h3><p>JML规格中已经描述了每个方法可能出现的各种正常、异常情况，我们在生成每个方法对应的指令时，一定要为每种情况设置一定的出现概率，而这也需要数据结构来保证。</p><p>举个非常简单的例子，<code>add_person</code>方法要求我们向<code>Network</code>里加入一个<code>Person</code>，JML规格如下所示——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*@ public normal_behavior     @ requires !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].equals(person));     @ assignable people;     @ ensures people.length == \old(people.length) + 1;     @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(people.length);     @          (\exists int j; 0 &lt;= j &amp;&amp; j &lt; people.length; people[j] == (\old(people[i]))));     @ ensures (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i] == person);     @ also     @ public exceptional_behavior     @ signals (EqualPersonIdException e) (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length;     @                                     people[i].equals(person));     @*/</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPerson</span><span class="token punctuation">(</span><span class="token comment">/*@ non_null @*/</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">EqualPersonIdException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>通过JML规格可以看出，这个方法在执行时可能出现两种情况——<strong>"Person以前不在Network里"</strong> 和<strong>"Person本来就在Network里"</strong>。我们生成的数据需要涵盖这两种情况，而且要保证每种情况都有较大的出现概率（可以给每一情况分配0.5的概率）<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_unexist_id</span><span class="token punctuation">(</span>id_set<span class="token punctuation">)</span> <span class="token punctuation">:</span>            <span class="token comment"># 封装成函数，可以在生成其他指令时使用</span>    <span class="token builtin">id</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token builtin">id</span> <span class="token keyword">in</span> id_set<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token builtin">id</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_exist_id</span><span class="token punctuation">(</span>id_set<span class="token punctuation">)</span> <span class="token punctuation">:</span>              <span class="token comment"># 封装成函数，可以在在生成其他指令时使用</span>    <span class="token builtin">id</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>id_set<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add_person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    prob <span class="token operator">=</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 50%的概率person在Network里</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prob <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token keyword">and</span> person_id_set<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token builtin">id</span> <span class="token operator">=</span> get_exist_id<span class="token punctuation">(</span>person_id_set<span class="token punctuation">)</span>        <span class="token comment"># 维护数据结构</span>        person_id_set<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span>        link_map<span class="token punctuation">[</span><span class="token builtin">id</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        disjoint_set<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span>    <span class="token comment"># 50%的概率person不在Network里</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        <span class="token builtin">id</span> <span class="token operator">=</span> get_unexist_id<span class="token punctuation">(</span>person_id_set<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">"ap "</span> <span class="token operator">+</span> <span class="token builtin">id</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> get_name<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> get_age<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>当然，有些方法涉及到的情况比较复杂。例如add_relation、add_to_group等许多方法需要获得<strong>"两个person的id"</strong> 或者是<strong>"一个person和一个group的id"</strong>，并根据两个id之间的关系进入不同的情况分支。</p><p>为了更好的实现代码复用，我在数据生成器里设置了<code>get_double_person_id</code>和<code>get_person_group_id</code>两个函数来分别生成<strong>"两个person的id"</strong> 或者是<strong>"一个person和一个group的id"</strong>。</p><p><code>get_double_person_id</code>中生成的两个personId的关系有以下四种</p><ul><li>person1和person2都不存在</li><li>person1和person2只有一个存在</li><li>person1和person2都存在，且两个person不邻接</li><li>person1和person2都存在，且两个person邻接</li></ul><p><code>get_person_group_id</code>中生成的personId和groupId的关系有以下五种</p><ul><li>person不存在，group不存在</li><li>person不存在，group存在</li><li>person存在，group不存在</li><li>person存在，group存在，person在group里面</li><li>person存在，group存在，person不在在group里面</li></ul><p>我们可以通过查询数据结构来生成不同关系的id，但同样也需要设置概率来保证每一种关系的两个id都有可能被生成。</p><h4 id="数据生成器整体架构">数据生成器整体架构</h4><p>数据生成器的整体架构如下所示——<br></p><pre class="line-numbers language-none"><code class="language-none">instr_list = ['ap', 'ar', 'qv', 'qps', 'qci', 'qbs', 'ag', 'atg', 'dfg',                 'qgps', 'qgvs', 'qgav', 'am', 'sm', 'qsv', 'qrm', 'qlc',                 'arem', 'anm', 'cn', 'aem', 'sei', 'qp', 'qm', 'sim', 'dce']def add_message()def add_relationship() ... ...def get_instr(instr) :    if (instr == 'ap') :        return add_person()    elif (instr == 'ar') :        return add_relation()    elif (instr == 'qv') :        return query_value()    elif (instr == 'qps') :        return query_people_sum()    elif (instr == 'qci') :        return query_circle()    elif (instr == 'qbs') :        return query_block_sum()    elif (instr == 'ag') :        return add_group()    elif (instr == 'atg') :        return add_to_group()    elif (instr == 'dfg') :        return del_from_group()    elif (instr == 'qgps') :        return query_group_people_sum()    elif (instr == 'qgvs') :        return query_group_value_sum()    elif (instr == 'qgav') :        return query_group_age_var()     elif (instr == 'am') :        return add_message()    elif (instr == 'sm') :        return send_message()     elif (instr == 'qsv') :        return query_social_value()    elif (instr == 'qrm') :        return query_received_messages()    elif (instr == 'qlc') :        return query_least_connection()    elif (instr == 'arem') :        return add_red_envelope_messages()    elif (instr == 'anm') :        return add_notice_messages()    elif (instr == 'cn') :        return clean_notices()    elif (instr == 'aem') :        return add_emoji_messages()    elif (instr == 'sei') :        return store_emoji_id()    elif (instr == 'qp') :        return query_popularity()    elif (instr == 'dce') :        return delete_cold_emoji()    elif (instr == 'qm') :        return query_money()    elif (instr == 'sim') :        return send_indirect_message()if __name__ == '__main__':    # f = open("data.txt", "w")    # sys.stdout = f    n = 4999    for i in range(n) :        instr_type = random.choice(instr_list)        instr = get_instr(instr_type)        print(instr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面展示的仅仅是一个框架，在真正实现时还有很多细节需要注意。<p></p><h2 id="network扩展">Network扩展</h2><p>假设出现了几种不同的Person</p><ul><li><strong>Advertiser</strong>：持续向外发送产品广告</li><li><strong>Producer</strong>：产品生产商，通过Advertiser来销售产品</li><li><strong>Customer</strong>：消费者，会关注广告并选择和自己偏好匹配的产品来购买-- 所谓购买，就是直接通过Advertiser给相应Producer发一个购买消息</li><li><strong>Person</strong>：吃瓜群众，不发广告，不买东西，不卖东西</li></ul><p>如此Network可以支持市场营销，并能查询某种商品的销售额和销售路径等请讨论如何对Network扩展，给出相关接口方法，并选择3个核心业务功能的接口方法撰写JML规格（借鉴所总结的JML规格模式）</p><p>基于面向对象的思想，我们需要对Advertiser、Producer和Customer分别建类，并且这些类继承自Person。通过分析这几种Person的职责，我们可以发现他们之间有着很强的关联关系，如下所示——</p><ul><li>Advertiser可以向Customer发送广告消息，考虑到Advertiser可能和很多的Customer关联（即作为成员变量），我们可以采用观察者模式将信息传递出去。Customer接收到消息后，只需要将这个Advertiser作为自己成员变量即可。</li><li>Customer想要购买某个商品时，需要把购买信息传递给Advertiser。在此之前，我们已经将Advertiser作为customer的成员变量了，那么只需调用Advertiser成员的相关方法来完成购买信息的传递。</li><li>Advertiser在收到来自于Customer的购买消息时，需要立刻将这些消息传递给Producer。同样，我们可以提前将雇佣Advertiser的Producer作为Advertiser的成员变量，即建立关联关系，这样Advertiser只需要调用Producer的某个方法即可实现消息传递。</li><li>Producer收到购买消息后，销售额需要减1</li></ul><blockquote><p>在此我们假定：一个Producer只生产一种产品；一个Advertiser只为一个Producer做广告，但是可以向多个Custormer宣传。</p></blockquote><p>下面我对三个核心业务功能的接口方法编写JML规格——</p><ul><li><p>查询Producer的销售额——querySale<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* @ public normal_behavior @ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Producer); @ assignable \nothing; @ ensures  (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; \results = people[i].sale); @ also @ public exceptional_behavior @ signals (PersonIdNotFoundException e) !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Producer) */</span> <span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span> <span class="token keyword">int</span> <span class="token function">querySale</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>发送广告——sendAllAd<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* @ public normal_behavior @ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser &amp;&amp;             (\forall int j; 0 &lt;= j &amp;&amp; j &lt; people.length; people[j].getId() == id &amp;&amp; people[j] instanceof Customer &amp;&amp;             (\forall int k; 0 &lt;= k &amp;&amp; k &lt; people[j].ads.length; people[j].ads[k].getId() != people[i].getAdId()))) ;  @ assignable people[*]; @ ensures  (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser &amp;&amp;             (\forall int j; 0 &lt;= j &amp;&amp; j &lt; people.length; people[j].getId() == id &amp;&amp; people[j] instanceof Customer &amp;&amp;             (\exists int k; 0 &lt;= k &amp;&amp; k &lt; people[j].ads.length; people[j].ads[k].getId() == people[i].getAdId()))) ; @ also @ public exceptional_behavior @ signals (PersonIdNotFoundException e) !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Producer); @ also @ public exceptional_behavior @ signals (AdIdNotFoundException e) (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser &amp;&amp;                                      (\forall int j; 0 &lt;= j &amp;&amp; j &lt; people.length; people[j].getId() == id &amp;&amp; people[j] instanceof Customer &amp;&amp;                                      (\exists int k; 0 &lt;= k &amp;&amp; k &lt; people[j].ads.length; people[j].ads[k].getId() == people[i].getAdId()))) ; */</span> <span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span>  <span class="token function">sendAd</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">AdIdNotFoundException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>获得某个消费者收到的所有广告——queryAllAds<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* @ public normal_behavior @ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser); @ assignable \nothing; @ ensures  (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser &amp;&amp;            (\result.size() == people[i].ads.length) &amp;&amp;              (\forall int j; 0 &lt;= j &amp;&amp; j &lt; people[i].ads.length; people[i].ads[j] == \result.get(j)); */</span> <span class="token keyword">public</span> <span class="token comment">/*@ pure @*/</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Ad</span><span class="token punctuation">&gt;</span></span> <span class="token function">queryAllAds</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h2 id="心得体会">心得体会</h2><ul><li>在本单元，我学会了理解和书写JML规格，并初次接触到了<strong>"契约式编程"</strong>，感受到了按照契约编程的诸多优势——<strong>高可靠性、高可复用性、便于测试</strong>。不过，三次作业能够囊括的知识毕竟很少，我对"契约式编程"也只是浅尝辄止的程度，以后还要多多探索和使用。</li><li>本单元的三次作业帮助我复习了很多图论算法——<strong>并查集、最小生成树、单源最短路径</strong>等等。此外，作业的性能要求也push我学会了很多优化方法，让我进一步体会到了算法的魅力。</li><li>本单元同样也锻炼了我写数据生成器的能力。为了提高数据的强度，我需要一边看JML规格，一边编写数据生成器，而这个过程也让我加深了对JML的理解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab5函数解读</title>
      <link href="/2022/05/30/os/os-lab5-han-shu-jie-du/"/>
      <url>/2022/05/30/os/os-lab5-han-shu-jie-du/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ide磁盘镜像">IDE磁盘镜像</h2><p>在这一部分，我们主要依赖fsformat.c文件创建磁盘镜像文件gxemul/fs.img，这个磁盘镜像可以模拟与真实的磁盘文件设备之间的交互。</p><h3 id="fsfsformat.c">fs/fsformat.c</h3><p>函数之间的调用关系如下所示——<br><img src="fsformat.drawio.svg"></p><h4 id="reverse">reverse</h4><p>将指针p所指向的32位无符号数进行大小端转换。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">uint8_t</span> <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> p<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> y <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>    x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> y <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>    x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>    x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>    x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&gt;&gt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="reverse_block">reverse_block</h4><p>将指针b所指向磁盘块的所有内容，按字依次进行大小端转换（需要循环调用reverse函数）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverse_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Block</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Super</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token operator">*</span>ff<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> <span class="token operator">*</span>u<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> BLOCK_FREE<span class="token operator">:</span>    <span class="token keyword">case</span> BLOCK_BOOT<span class="token operator">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// do nothing.</span>    <span class="token keyword">case</span> BLOCK_SUPER<span class="token operator">:</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Super</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_magic<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">)</span><span class="token punctuation">;</span>        ff <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_root<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NDIRECT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_direct<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> BLOCK_FILE<span class="token operator">:</span>        f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> FILE2BLK<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ff <span class="token operator">=</span> f <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ff<span class="token operator">-&gt;</span>f_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_size<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_type<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> NDIRECT<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_direct<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ff<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> BLOCK_INDEX<span class="token operator">:</span>    <span class="token keyword">case</span> BLOCK_BMAP<span class="token operator">:</span>        u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BY2BLK<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>u<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="init_disk">init_disk</h4><p>对磁盘进行初始化，把disk[0]作为引导扇区和分区表所在的磁盘块，把disk[1]作为超级块。此外，还要根据磁盘块总个数（NBLOCK）为位图分配空间（分配nbitblock个磁盘块）。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init_disk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> r<span class="token punctuation">,</span> diff<span class="token punctuation">;</span>    <span class="token comment">// Step 1: Mark boot sector block.</span>    disk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">=</span> BLOCK_BOOT<span class="token punctuation">;</span>    <span class="token comment">// Step 2: Initialize boundary.</span>    nbitblock <span class="token operator">=</span> <span class="token punctuation">(</span>NBLOCK <span class="token operator">+</span> BIT2BLK <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> BIT2BLK<span class="token punctuation">;</span>    nextbno <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> nbitblock<span class="token punctuation">;</span>    <span class="token comment">// Step 2: Initialize bitmap blocks.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nbitblock<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        disk<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">=</span> BLOCK_BMAP<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nbitblock<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">,</span> BY2BLK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>NBLOCK <span class="token operator">!=</span> nbitblock <span class="token operator">*</span> BIT2BLK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        diff <span class="token operator">=</span> NBLOCK <span class="token operator">%</span> BIT2BLK <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span><span class="token punctuation">(</span>nbitblock<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">+</span>diff<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> BY2BLK <span class="token operator">-</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Step 3: Initialize super block.</span>    disk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">=</span> BLOCK_SUPER<span class="token punctuation">;</span>    super<span class="token punctuation">.</span>s_magic <span class="token operator">=</span> FS_MAGIC<span class="token punctuation">;</span>    super<span class="token punctuation">.</span>s_nblocks <span class="token operator">=</span> NBLOCK<span class="token punctuation">;</span>    super<span class="token punctuation">.</span>s_root<span class="token punctuation">.</span>f_type <span class="token operator">=</span> FTYPE_DIR<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>super<span class="token punctuation">.</span>s_root<span class="token punctuation">.</span>f_name<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="next_block">next_block</h4><p>在磁盘中顺次获取一个新的磁盘块，并将该磁盘块的类型标记为type</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">next_block</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    disk<span class="token punctuation">[</span>nextbno<span class="token punctuation">]</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>    <span class="token keyword">return</span> nextbno<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="flush_bitmap">flush_bitmap</h4><p>将所有已经使用的磁盘块在位图中标记为0，表示磁盘块正在被占用。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">flush_bitmap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// update bitmap, mark all bit where corresponding block is used.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextbno<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>disk<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">+</span>i<span class="token operator">/</span>BIT2BLK<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">%</span>BIT2BLK<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="finish_fs">finish_fs</h4><p>将磁盘块中的所有内容拷贝到名为name的文件中,在拷贝前需要对每个磁盘块的内容进行大小端转换（调用reverse_block函数）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">finish_fs</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> r<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">// Prepare super block.</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>super<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>super<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Dump data in `disk` to target image file.</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> O_RDWR<span class="token operator">|</span>O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">reverse_block</span><span class="token punctuation">(</span>disk<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> disk<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> BY2BLK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Finish.</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="save_block_link">save_block_link</h4><p>将文件f第nblk个内容块所在的磁盘块设置为disk[bno]，也就是将f的第nblk个文件指针设置为bno。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">save_block_link</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">int</span> nblk<span class="token punctuation">,</span> <span class="token keyword">int</span> bno<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>nblk <span class="token operator">&lt;</span> NINDIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if not, file is too large !</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nblk <span class="token operator">&lt;</span> NDIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        f<span class="token operator">-&gt;</span>f_direct<span class="token punctuation">[</span>nblk<span class="token punctuation">]</span> <span class="token operator">=</span> bno<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_indirect <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// create new indirect block.</span>            f<span class="token operator">-&gt;</span>f_indirect <span class="token operator">=</span> <span class="token function">next_block</span><span class="token punctuation">(</span>BLOCK_INDEX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span>f<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>nblk<span class="token punctuation">]</span> <span class="token operator">=</span> bno<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="make_link_block">make_link_block</h4><p>获取一个新的磁盘块（调用next_block函数），块号为bno，并将f的第nblk个文件指针设置为bno（调用save_block_link函数）。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">make_link_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">,</span> <span class="token keyword">int</span> nblk<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> bno <span class="token operator">=</span> <span class="token function">next_block</span><span class="token punctuation">(</span>BLOCK_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">save_block_link</span><span class="token punctuation">(</span>dirf<span class="token punctuation">,</span> nblk<span class="token punctuation">,</span> bno<span class="token punctuation">)</span><span class="token punctuation">;</span>    dirf<span class="token operator">-&gt;</span>f_size <span class="token operator">+=</span> BY2BLK<span class="token punctuation">;</span>    <span class="token keyword">return</span> bno<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="create_file">create_file</h4><p>在目录dirf中找到一个空闲的文件控制块（空闲的标志为f-&gt;f_name[0] =='\0'）,用于控制和记录一个新的文件，最后将这个文件控制块返回。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token function">create_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirblk<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> bno<span class="token punctuation">;</span>    <span class="token keyword">int</span> nblk <span class="token operator">=</span> dirf<span class="token operator">-&gt;</span>f_size <span class="token operator">/</span> BY2BLK<span class="token punctuation">;</span>        <span class="token comment">// Step1: According to different range of nblk, make classified discussion to</span>    <span class="token comment">//        calculate the correct block number.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nblk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bno <span class="token operator">=</span> <span class="token function">make_link_block</span><span class="token punctuation">(</span>dirf<span class="token punctuation">,</span> nblk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span>bno<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nblk <span class="token operator">&lt;=</span> NDIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        bno <span class="token operator">=</span> dirf<span class="token operator">-&gt;</span>f_direct<span class="token punctuation">[</span>nblk <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        bno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_int <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span>dirf<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>nblk <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dirblk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span>bno<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Step2: Find an unused pointer</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> FILE2BLK<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dirblk<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>f_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> dirblk <span class="token operator">+</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//if not found</span>    bno <span class="token operator">=</span> <span class="token function">make_link_block</span><span class="token punctuation">(</span>dirf<span class="token punctuation">,</span> nblk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span>bno<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="write_file">write_file</h4><p>在dirf中创建一个新的文件（调用create_file），本质上是获得一个新的文件控制块，并进行初始化（f_name,f_size,f_type）。然后将path所定位的文件的内容复制在磁盘中，同时在文件控制块中记录相关磁盘块的索引。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">write_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dirf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> iblk <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>disk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> buffer<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>dist<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>target <span class="token operator">=</span> <span class="token function">create_file</span><span class="token punctuation">(</span>dirf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* in case `create_file` is't filled */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Get file name with no path prefix.</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span>        fname<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        fname <span class="token operator">=</span> path<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>target<span class="token operator">-&gt;</span>f_name<span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">;</span>     target<span class="token operator">-&gt;</span>f_size <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    target<span class="token operator">-&gt;</span>f_type <span class="token operator">=</span> FTYPE_REG<span class="token punctuation">;</span>     <span class="token comment">// Start reading file.</span>    <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> disk<span class="token punctuation">[</span>nextbno<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">save_block_link</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> iblk<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token function">next_block</span><span class="token punctuation">(</span>BLOCK_DATA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Close file descriptor.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="文件系统服务">文件系统服务</h2><p>文件系统服务进程主要是用来为其他用户进程提供相关服务，fs目录下fs.c、ide.c、serve.c三个文件都是用于文件系统服务进程。</p><p>由于fs.c和ide.c的文件结构都比较简单，函数理解的难度不大，因此我们在这里只分析fs.c中的函数。</p><p><img src="fs.drawio.svg"></p><h3 id="fsfs.c">fs/fs.c</h3><p>fs.c中的函数多达33个，函数之间的调用关系也十分复杂，完整的画出函数调用链几乎不可能。为了便于理解，我将这33个函数按其调用层次划分为三类——block类、block-file类、file类，只有同一类和相邻类中的函数才可以相互调用。</p><h4 id="diskaddr">diskaddr</h4><p>计算指定磁盘块（下标为blockno）对应的块缓存虚拟地址。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">diskaddr</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>blockno <span class="token operator">&gt;=</span> DISKMAX <span class="token operator">/</span> BY2BLK<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"In diskaddr: non-existent block %08x\n"</span><span class="token punctuation">,</span> blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> DISKMAP <span class="token operator">+</span> blockno <span class="token operator">*</span> BY2BLK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="va_is_mapped">va_is_mapped</h4><p>检查va所表示的虚拟地址是否被进程页表映射，需要同时检查页目录和二级页表。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">va_is_mapped</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpd<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="block_is_mapped">block_is_mapped</h4><p>检查指定磁盘块（下标为blockno）对应的块缓存虚拟地址是否被进程页表映射（需要调用diskaddr()和va_is_mapped()）。如果被进程页表映射了，说明改磁盘块的数据已经被加载到了内存中。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">block_is_mapped</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">va_is_mapped</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> va<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="va_is_dirty">va_is_dirty</h4><p>检查虚拟地址va所对应的物理内存的数据是否被修改（检查页表项的dirty位即可）。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int<span class="token function">va_is_dirty</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span> vpt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_D<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="block_is_dirty">block_is_dirty</h4><p>首先找到指定磁盘块（下标为blockno）在内存中对应的块缓存地址，然后检查该虚拟地址对应的物理内存的数据是否被修改。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">block_is_dirty</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">va_is_mapped</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">va_is_dirty</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="map_block">map_block</h4><p>将指定磁盘块（下标为blockno）映射到内存中（作为块缓存），同时需要为块缓存分配物理内存。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">map_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va<span class="token punctuation">;</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">// Step 1: Decide whether this block has already mapped to a page of physical memory.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_mapped</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// Step 2: Alloc a page of memory for this block via syscall.</span>va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="unmap_block">unmap_block</h4><p>取消指定磁盘块（下标为blockno）在内存中的映射，也就是将块缓存对应的页表项清空。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">unmap_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va<span class="token punctuation">;</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">// Step 1: check if this block is mapped.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_mapped</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// Step 2: use block_is_free，block_is_dirty to check block,</span><span class="token comment">// if this block is used(not free) and dirty, it needs to be synced to disk: write_block</span><span class="token comment">// can't be unmap directly.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_free</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_dirty</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">write_block</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: use 'syscall_mem_unmap' to unmap corresponding virtual memory.</span>va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"In unmap_block: unmap error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 4: validate result of this unmap operation.</span><span class="token function">user_assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_mapped</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="read_block">read_block</h4><p>确保指定的磁盘块（下标位blockno）映射到内存中（块缓存），并将*blk赋值为对应的块缓存的首地址。如果指定磁盘块没有实现缓存映射，则首先应该调用map_block完成映射，然后将磁盘块中的数据复制到块缓存中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>blk<span class="token punctuation">,</span> u_int <span class="token operator">*</span>isnew<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va<span class="token punctuation">;</span><span class="token comment">// Step 1: validate blockno. Make file the block to read is within the disk.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>super <span class="token operator">&amp;&amp;</span> blockno <span class="token operator">&gt;=</span> super<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"reading non-existent block %08x\n"</span><span class="token punctuation">,</span> blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: validate this block is used, not free.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bitmap <span class="token operator">&amp;&amp;</span> <span class="token function">block_is_free</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"reading free block %08x\n"</span><span class="token punctuation">,</span> blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: transform block number to corresponding virtual address.</span>va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Step 4: read disk and set *isnew.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_mapped</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// the block is in memory</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isnew<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>isnew <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// the block is not in memory</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isnew<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>isnew <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ide_read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> blockno <span class="token operator">*</span> SECT2BLK<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> SECT2BLK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 5: if blk != NULL, set `va` to *blk.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>blk<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>blk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="write_block">write_block</h4><p>将块缓存（下标为blockno）中的数据写回到对应的磁盘块中。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">write_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va<span class="token punctuation">;</span><span class="token comment">// Step 1: detect is this block is mapped, if not, can't write it's data to disk.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_mapped</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"write unmapped block %08x"</span><span class="token punctuation">,</span> blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step2: write data to IDE disk. (using ide_write, and the diskno is 0)</span>va <span class="token operator">=</span> <span class="token function">diskaddr</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ide_write</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> blockno <span class="token operator">*</span> SECT2BLK<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> SECT2BLK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token punctuation">(</span>PTE_V <span class="token operator">|</span> PTE_R <span class="token operator">|</span> PTE_LIBRARY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="block_is_free">block_is_free</h4><p>检查指定的磁盘块（下标为blockno）是否为空闲，只需要检查位图的对应位是否为1即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">block_is_free</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>super <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> blockno <span class="token operator">&gt;=</span> super<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bitmap<span class="token punctuation">[</span>blockno <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>blockno <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="free_block">free_block</h4><p>将指定的磁盘块（下标为blockno）设为空闲块，只需要将位图的对应位置为1即可<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">free_block</span><span class="token punctuation">(</span>u_int blockno<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// Step 1: Check if the parameter `blockno` is valid (`blockno` can't be zero).</span><span class="token keyword">if</span> <span class="token punctuation">(</span>blockno <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>super <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> blockno <span class="token operator">&gt;=</span> super<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: Update the flag bit in bitmap.</span><span class="token comment">// you can use bit operation to update flags, such as  a |= (1 &lt;&lt; n) .</span>bitmap<span class="token punctuation">[</span>blockno <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>blockno <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="alloc_block_num">alloc_block_num</h4><p>从位图中找到一个空闲的磁盘块，并将其分配出去（位图对应为置位0）。此时，位图所在的块缓存被修改，需要及时写回到磁盘中。最后，函数返回新分配的磁盘块的块号。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">alloc_block_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> blockno<span class="token punctuation">;</span><span class="token comment">// walk through this bitmap, find a free one and mark it as used, then sync</span><span class="token comment">// this block to IDE disk (using `write_block`) from memory.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>blockno <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> blockno <span class="token operator">&lt;</span> super<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">;</span> blockno<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bitmap<span class="token punctuation">[</span>blockno <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>blockno <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// the block is free</span>bitmap<span class="token punctuation">[</span>blockno <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>blockno <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>writ            <span class="token function">e_block</span><span class="token punctuation">(</span>blockno <span class="token operator">/</span> BIT2BLK <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// write to disk.</span><span class="token keyword">return</span> blockno<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// no free blocks.</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_DISK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="alloc_block">alloc_block</h4><p>创建一个新的磁盘块，并完成块缓存映射。这个函数包括两个步骤：首先使用alloc_block_num()获得一个新的磁盘块的块号，然后使用map_block()函数将其映射到内存中。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">alloc_block</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> bno<span class="token punctuation">;</span><span class="token comment">// Step 1: find a free block.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">alloc_block_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// failed.</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>bno <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token comment">// Step 2: map this block into memory.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_block</span><span class="token punctuation">(</span>bno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">free_block</span><span class="token punctuation">(</span>bno<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bacome free again</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: return block number.</span>    <span class="token keyword">return</span> bno<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="read_super">read_super</h4><p>读取超级块，并验证超级快是否有效。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">read_super</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk<span class="token punctuation">;</span><span class="token comment">// Step 1: read super block.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">read_block</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"cannot read superblock: %e"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>super <span class="token operator">=</span> blk<span class="token punctuation">;</span><span class="token comment">// Step 2: Check fs magic nunber.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>super<span class="token operator">-&gt;</span>s_magic <span class="token operator">!=</span> FS_MAGIC<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"bad file system magic number %x %x"</span><span class="token punctuation">,</span> super<span class="token operator">-&gt;</span>s_magic<span class="token punctuation">,</span> FS_MAGIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: validate disk size.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>super<span class="token operator">-&gt;</span>s_nblocks <span class="token operator">&gt;</span> DISKMAX <span class="token operator">/</span> BY2BLK<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"file system is too large"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"superblock is good\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="read_bitmap">read_bitmap</h4><p>首先读取bitmap所在的磁盘块，并将其映射到内存中，然后再检查引导扇区和分区表所在块、超级块、bitmap所在块的有效性，如果有一个为空闲则应报错。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">read_bitmap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>u_int i<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">// Step 1: calculate this number of bitmap blocks, and read all bitmap blocks to memory.</span>nbitmap <span class="token operator">=</span> super<span class="token operator">-&gt;</span>s_nblocks <span class="token operator">/</span> BIT2BLK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nbitmap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">read_block</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> blk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bitmap <span class="token operator">=</span> <span class="token punctuation">(</span>u_int <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">diskaddr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Step 2: Make sure the reserved and root blocks are marked in-use.</span><span class="token comment">// Hint: use `block_is_free`</span><span class="token function">user_assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_free</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">user_assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_free</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Step 3: Make sure all bitmap blocks are marked in-use.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nbitmap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">block_is_free</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"read_bitmap is good\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fs_init">fs_init</h4><p>这个函数很简单，实际上就是依次调用read_super()、check_write_block()、read_bitmap()，实现文件系统的初始化，检查缓存映射机制能否正常执行<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fs_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">read_super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">check_write_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read_bitmap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_block_walk">file_block_walk</h4><p>寻找文件f的第filebno个文件数据块，并将*ppdiskbno赋值为<strong>该文件数据块的块号的地址</strong>。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_block_walk</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int filebno<span class="token punctuation">,</span> u_int <span class="token operator">*</span><span class="token operator">*</span>ppdiskbno<span class="token punctuation">,</span> u_int alloc<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>filebno <span class="token operator">&lt;</span> NDIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Step 1: if the target block is corresponded to a direct pointer, just return the</span><span class="token comment">// disk block number.</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>f<span class="token operator">-&gt;</span>f_direct<span class="token punctuation">[</span>filebno<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>filebno <span class="token operator">&lt;</span> NINDIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Step 2: if the target block is corresponded to the indirect block, but there's no</span><span class="token comment">//indirect block and `alloc` is set, create the indirect block.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_indirect <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>alloc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NOT_FOUND<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">alloc_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>f<span class="token operator">-&gt;</span>f_indirect <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: read the new indirect block to memory.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">read_block</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span>u_int <span class="token operator">*</span><span class="token punctuation">)</span>blk <span class="token operator">+</span> filebno<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 4: store the result into *ppdiskbno, and return 0.</span><span class="token operator">*</span>ppdiskbno <span class="token operator">=</span> ptr<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_map_blcok">file_map_blcok</h4><p>寻找文件f的第filebno个文件数据块，并将*diskbno赋值为<strong>该文件数据块的块号</strong>。在实现时，该函数需要先调用file_block_walk函数获得指向该文件数据块的块号的指针ptr，然后通过<code>*ptr</code>获得该文件数据块的块号。如果<code>*ptr</code>的值为0，说明我们还没有在磁盘中为该文件数据块分配真正的磁盘块，此时我们需要分配一个新的磁盘块作为该文件数据块（只有alloc值为1的时候才会分配）。</p><blockquote><p>文件数据块本质上就是磁盘块。一个文件由n个文件数据块组成，而这n个文件数据块由n个不连续的磁盘块来充当。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_map_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int filebno<span class="token punctuation">,</span> u_int <span class="token operator">*</span>diskbno<span class="token punctuation">,</span> u_int alloc<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">// Step 1: find the pointer for the target block.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_block_walk</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> filebno<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> alloc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: if the block not exists, and create is set, alloc one.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>alloc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NOT_FOUND<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">alloc_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>ptr <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: set the pointer to the block in *diskbno and return 0.</span><span class="token operator">*</span>diskbno <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_clear_block">file_clear_block</h4><p>删除文件f中的第filebno个文件数据块。在实现时需要先调用file_block_walk函数获得指向该文件数据块的块号的指针ptr，然后通过*ptr获得该磁盘块的块号，并使用free_block将该磁盘块变为空闲块。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_clear_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int filebno<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_block_walk</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> filebno<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">free_block</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_get_block">file_get_block</h4><p>将文件f中第filebno个文件数据块的数据从磁盘复制到块缓存中（调用read_block函数）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_get_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int filebno<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>blk<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int diskbno<span class="token punctuation">;</span>u_int isnew<span class="token punctuation">;</span><span class="token comment">// Step 1: find the disk block number is `f` using `file_map_block`.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_map_block</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> filebno<span class="token punctuation">,</span> <span class="token operator">&amp;</span>diskbno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: read the data in this disk to blk.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">read_block</span><span class="token punctuation">(</span>diskbno<span class="token punctuation">,</span> blk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>isnew<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_dirty">file_dirty</h4><p>将偏移offset所在的文件数据块标记为dirty，只需对块缓存进行写操作即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_dirty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int offset<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_get_block</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> offset <span class="token operator">/</span> BY2BLK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>blk <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>blk<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dir_lookup">dir_lookup</h4><p>在目录dir中寻找名为name的文件数据块，如果找到了，就将该文件数据块的地址赋值给*file。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dir_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span>u_int i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> nblock<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>file_list<span class="token punctuation">;</span><span class="token comment">// Step 1: Calculate nblock: how many blocks are there in this dir？</span>nblock <span class="token operator">=</span> dir<span class="token operator">-&gt;</span>f_size <span class="token operator">/</span> BY2BLK<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nblock<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Step 2: Read the i'th block of the dir.</span><span class="token comment">// Hint: Use file_get_block.</span>ret <span class="token operator">=</span> <span class="token function">file_get_block</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>file_list <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token punctuation">)</span>blk<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> FILE2BLK<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>f <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>file_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_name<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>f<span class="token operator">-&gt;</span>f_dir <span class="token operator">=</span> dir<span class="token punctuation">;</span><span class="token operator">*</span>file <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Step 3: Find target file by file name in all files on this block.</span><span class="token comment">// If we find the target file, set the result to *file and set f_dir field.</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NOT_FOUND<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dir_alloc_file">dir_alloc_file</h4><p>在目录dir中找到一个空的文件控制块（标志为f_name[0] ='\0'），最后将该文件控制块的地址赋值给*file。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dir_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int nblock<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>blk<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>nblock <span class="token operator">=</span> dir<span class="token operator">-&gt;</span>f_size <span class="token operator">/</span> BY2BLK<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nblock<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// read the block.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_get_block</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>f <span class="token operator">=</span> blk<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> FILE2BLK<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>f_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// found free File structure.</span><span class="token operator">*</span>file <span class="token operator">=</span> <span class="token operator">&amp;</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// no free File structure in exists data block.</span><span class="token comment">// new data block need to be created.</span>dir<span class="token operator">-&gt;</span>f_size <span class="token operator">+=</span> BY2BLK<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_get_block</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>blk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>f <span class="token operator">=</span> blk<span class="token punctuation">;</span><span class="token operator">*</span>file <span class="token operator">=</span> <span class="token operator">&amp;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="skip_slash">skip_slash</h4><p>如果p指向的字符是<code>'\'</code>，则指针自加，将其跳过，直到遇到一个非<code>'\'</code>的字符。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">skip_slash</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="walk_path">walk_path</h4><p>从根目录开始查找路径为path的文件（也可能是目录文件）。如果查到了，则<em>pdir指向是文件所在的最后一级目录，</em>pfile指向找到的文件；如果没有查到，<code>*pdir</code>指向的是<strong>可以与path相匹配</strong>的最后一级目录，<code>*pfile</code>的值为0，lastelem指向的是目标文件名。</p><blockquote><p>如果中间某一级目录的查找出现了错误，则lastelem指向的数据不会被改变。例如，当前查找的路径为“/root/file/buaa/os/code.c”,如果，目录buaa下没有os这一子目录，则不会对lastelem所指向的内容做任何的修改；只有当os目录存在，而os目录下没有code.c文件时，lastelem才会被指向字符串“code.c”</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">walk_path</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>pdir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>pfile<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>lastelem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token operator">*</span>file<span class="token punctuation">;</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token comment">// start at the root.</span>path <span class="token operator">=</span> <span class="token function">skip_slash</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>file <span class="token operator">=</span> <span class="token operator">&amp;</span>super<span class="token operator">-&gt;</span>s_root<span class="token punctuation">;</span>dir <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pdir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>pdir <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>pfile <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// find the target file by name recursively.</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>path <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>dir <span class="token operator">=</span> file<span class="token punctuation">;</span>p <span class="token operator">=</span> path<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>path <span class="token operator">!=</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>path <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>path<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>path <span class="token operator">-</span> p <span class="token operator">&gt;=</span> MAXNAMELEN<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_BAD_PATH<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">user_bcopy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> name<span class="token punctuation">,</span> path <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>name<span class="token punctuation">[</span>path <span class="token operator">-</span> p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>path <span class="token operator">=</span> <span class="token function">skip_slash</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token operator">-&gt;</span>f_type <span class="token operator">!=</span> FTYPE_DIR<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NOT_FOUND<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dir_lookup</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span>E_NOT_FOUND <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>path <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pdir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>pdir <span class="token operator">=</span> dir<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lastelem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">strcpy</span><span class="token punctuation">(</span>lastelem<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>pfile <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pdir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>pdir <span class="token operator">=</span> dir<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>pfile <span class="token operator">=</span> file<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_open">file_open</h4><p>将path所代表的文件控制块的地址赋值给*file，只需调用walk_path函数即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_open</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">walk_path</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_create">file_create</h4><p>根据path指定的位置生成文件，并将*file赋值为新文件控制块的地址。必须保证path中目标文件所在的最后一级目录存在，否在函数无法正常执行。<br>&gt;例如，如过path指向的是“/root/file/buaa/os/code.c”，则必须保证目录os存在。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_create</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span><span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">walk_path</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_FILE_EXISTS<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span>E_NOT_FOUND <span class="token operator">||</span> dir <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dir_alloc_file</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>f<span class="token operator">-&gt;</span>f_name<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>file <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_truncate">file_truncate</h4><p>将文件f截断，使得文件只保留大小为newsize的数据，将其余数据所在的磁盘块设为空闲。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">file_truncate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int newsize<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int bno<span class="token punctuation">,</span> old_nblocks<span class="token punctuation">,</span> new_nblocks<span class="token punctuation">;</span>old_nblocks <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_size <span class="token operator">/</span> BY2BLK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>new_nblocks <span class="token operator">=</span> newsize <span class="token operator">/</span> BY2BLK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newsize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>new_nblocks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new_nblocks <span class="token operator">&lt;=</span> NDIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>bno <span class="token operator">=</span> new_nblocks<span class="token punctuation">;</span> bno <span class="token operator">&lt;</span> old_nblocks<span class="token punctuation">;</span> bno<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_clear_block</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> bno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">free_block</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_indirect<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token operator">-&gt;</span>f_indirect <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>bno <span class="token operator">=</span> new_nblocks<span class="token punctuation">;</span> bno <span class="token operator">&lt;</span> old_nblocks<span class="token punctuation">;</span> bno<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_clear_block</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> bno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>f<span class="token operator">-&gt;</span>f_size <span class="token operator">=</span> newsize<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_set_size">file_set_size</h4><p>将文件f的大小设置为newsize，只需要调用file_truncate函数即可实现。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_set_size</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> u_int newsize<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_size <span class="token operator">&gt;</span> newsize<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_truncate</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> newsize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>f<span class="token operator">-&gt;</span>f_size <span class="token operator">=</span> newsize<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_flush</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_flush">file_flush</h4><p>将文件f的所有数据从块缓存重写回磁盘，保证块缓存数据和磁盘数据的一致性。实际上，只有被标记为dirty的块缓存才会被写回磁盘。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">file_flush</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// Your code here</span>u_int nblocks<span class="token punctuation">;</span>u_int bno<span class="token punctuation">;</span>u_int diskno<span class="token punctuation">;</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>nblocks <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_size <span class="token operator">/</span> BY2BLK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>bno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> bno <span class="token operator">&lt;</span> nblocks<span class="token punctuation">;</span> bno<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">file_map_block</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> bno<span class="token punctuation">,</span> <span class="token operator">&amp;</span>diskno<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_dirty</span><span class="token punctuation">(</span>diskno<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">write_block</span><span class="token punctuation">(</span>diskno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fs_sync">fs_sync</h4><p>将所有块缓存的“脏”数据重写回磁盘，保证块缓存数据和磁盘数据的一致性。实际上，只有被标记为dirty的块缓存才会被写回磁盘。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fs_sync</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> super<span class="token operator">-&gt;</span>s_nblocks<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">block_is_dirty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">write_block</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_close">file_close</h4><p>将文件f的所有“脏”数据从块缓存重写回磁盘，如果该文件在某一个目录文件中，则也对该目录文件做同样的操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// Flush the file itself, if f's f_dir is set, flush it's f_dir.</span><span class="token function">file_flush</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_flush</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_remove">file_remove</h4><p>将path所代表的目标文件从它所在的最后一级目录中删除。包括4个步骤——</p><ul><li>首先调用walk_path函数找到path所代表的目标文件的文件控制块。</li><li>将文件的内容清空，并将文件控制块中f_name清空，表示文件已经不存在。</li><li>将目标文件的所有数据从块缓存重写回磁盘（貌似这一步并没有什么用，因为此时文件的size== 0）</li><li>将目标文件所在的最后一级目录文件的所有数据从块缓存重写回磁盘（这一步比较关键，因为我们已经对目标文件的文件控制块进行了修改）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token function">file_remove</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token comment">// Step 1: find the file on the disk.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">walk_path</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: truncate it's size to zero.</span><span class="token function">file_truncate</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Step 3: clear it's name.</span>f<span class="token operator">-&gt;</span>f_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token comment">// Step 4: flush the file.</span><span class="token function">file_flush</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">file_flush</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件系统的用户接口">文件系统的用户接口</h2><p>文件系统在建立之后，还需要向用户提供相关的接口使用。在fd.c、file.c、fsipc.c这三个文件中，我们为用户进程提供了申请文件系统服务的函数接口，而这些函数最终会通过ipc机制调用文件系统服务进程的相关函数。</p><p><img src="process.drawio.svg"></p><h3 id="userfd.c">user/fd.c</h3><h4 id="dev_lookup">dev_lookup</h4><p>在设备列表devtab中寻找id为dev_id的设备，并将设备控制块的地址赋值给*dev。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dev_lookup</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev_id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Dev</span> <span class="token operator">*</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> devtab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>devtab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>dev_id <span class="token operator">==</span> dev_id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>dev <span class="token operator">=</span> devtab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"[%08x] unknown device type %d\n"</span><span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_id<span class="token punctuation">,</span> dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fd_alloc">fd_alloc</h4><p>在<span class="math inline">\([FDTABLE,FDTABLE+32*4K)\)</span>这地址空间中找到一个没有被映射的页作为一个新的文件描述符，并分配出去<br>&gt; 所有的文件描述符都被映射在<span class="math inline">\([FDTABLE,FDTABLE+32*4K)\)</span>这一地址空间，文件描述符的index与被映射的地址呈线性关系，地址可通过宏函数INDEX2FD（index）得到。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fd_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int va<span class="token punctuation">;</span>u_int fdno<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>fdno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fdno <span class="token operator">&lt;</span> MAXFD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> fdno<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>va <span class="token operator">=</span> <span class="token function">INDEX2FD</span><span class="token punctuation">(</span>fdno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpd<span class="token punctuation">)</span><span class="token punctuation">[</span>va <span class="token operator">/</span> PDMAP<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>fd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpt<span class="token punctuation">)</span><span class="token punctuation">[</span>va <span class="token operator">/</span> BY2PG<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//the fd is not used</span><span class="token operator">*</span>fd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span>E_MAX_OPEN<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="fd_close">fd_close</h4><p>删除文件描述符，只需删去进程页表对文件结束符所在页面的映射即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fd_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fd_lookup">fd_lookup</h4><p>根据下标fdnum获得对应的文件描述符，并将*fd赋值为该文件描述符所在页面的首地址。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// Check that fdnum is in range and mapped.  If not, return -E_INVAL.</span><span class="token comment">// Set *fd to the fd page virtual address.  Return 0.</span>u_int va<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fdnum <span class="token operator">&gt;=</span> MAXFD<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span>va <span class="token operator">=</span> <span class="token function">INDEX2FD</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpt<span class="token punctuation">)</span><span class="token punctuation">[</span>va <span class="token operator">/</span> BY2PG<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//the fd is used</span><span class="token operator">*</span>fd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fd2data">fd2data</h4><p>获得文件描述符所对应的文件在该进程地址空间中的位置。</p><blockquote><p>注意这里“在该进程地址空间的位置”并非是块缓存。块缓存是文件服务进程中的概念，在文件服务进程的地址空间中，块缓存位于<span class="math inline">\([0x10000000,0x50000000)\)</span>之间。而在用户进程的地址空间中，文件被映射到<span class="math inline">\([0x60000000,0x67000000]\)</span>之间（用户进程最多开32个文件描述符，每个文件描述符对应一个文件，每个文件最大为4MB，因此只需要在用户进程地址空间中分配0x7000000大小的空间即可）</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">fd2data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">INDEX2DATA</span><span class="token punctuation">(</span><span class="token function">fd2num</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="fd2num">fd2num</h4><p>获得文件描述符fd所对应的下标。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fd2num</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>fd <span class="token operator">-</span> FDTABLE<span class="token punctuation">)</span> <span class="token operator">/</span> BY2PG<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="num2fd">num2fd</h4><p>通过下标fd获得对应的文件描述符，返回文件描述符所在页面的首地址。（不就是函数版本的INDEX2FD吗orz）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">num2fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> fd <span class="token operator">*</span> BY2PG <span class="token operator">+</span> FDTABLE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="close">close</h4><p>关闭文件，不仅需要调用fd_close删除文件描述符，还需要调用文件对应的设备dev的dev_close函数（函数的具体实现取决于dev的种类，Lab5中只调用file.c文件中的file_close函数）将实际文件进行关闭。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">||</span>  <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dev_lookup</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token operator">-&gt;</span>dev_close<span class="token punctuation">)</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fd_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="close_all">close_all</h4><p>将进程中所有打开的文件关闭。因为进程中只有32个文件描述符，即只能同时打开32个文件，因此连续调用32次close函数即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">close_all</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXFD<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="dup">dup</h4><p>将下标为oldfdnum文件控制块的内容拷贝到下标为newfdnum的文件控制块中，并将文件控制块控制的文件的内容从地址fd2data(oldfd)拷贝到地址fd2data(newfd)中。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfdnum<span class="token punctuation">,</span> <span class="token keyword">int</span> newfdnum<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> r<span class="token punctuation">;</span>u_int ova<span class="token punctuation">,</span> nva<span class="token punctuation">,</span> pte<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>oldfd<span class="token punctuation">,</span> <span class="token operator">*</span>newfd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>oldfdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oldfd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>newfdnum<span class="token punctuation">)</span><span class="token punctuation">;</span>newfd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">INDEX2FD</span><span class="token punctuation">(</span>newfdnum<span class="token punctuation">)</span><span class="token punctuation">;</span>ova <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span>nva <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>oldfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>newfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>oldfd<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_V <span class="token operator">|</span> PTE_R <span class="token operator">|</span> PTE_LIBRARY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">goto</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpd<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>ova<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PDMAP<span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span> <span class="token punctuation">{</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span> vpt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>ova <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// should be no error here -- pd is already allocated</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ova <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nva <span class="token operator">+</span> i<span class="token punctuation">,</span> pte <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_V <span class="token operator">|</span> PTE_R <span class="token operator">|</span> PTE_LIBRARY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">goto</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> newfdnum<span class="token punctuation">;</span>err<span class="token operator">:</span><span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PDMAP<span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nva <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="read">read</h4><p>通过下标fdnum找到对应的文件控制块，然后将该文件前n个字节的数据（已经在本进程地址空间中）拷贝到buf中。返回值是最终实际读取的字节数。</p><blockquote><p>只要调用open函数（user/file），则文件的内容就从文件服务进程的地址空间中“复制”到用户进程的地址空间中。这里所说的“复制”实际上是将两个地址空间中两个虚拟页面映射到了同一个物理页面。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token comment">// Similar to 'write' function.</span><span class="token comment">// Step 1: Get fd and dev.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">||</span>  <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dev_lookup</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 2: Check open mode.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_omode <span class="token operator">&amp;</span> O_ACCMODE<span class="token punctuation">)</span> <span class="token operator">==</span> O_WRONLY<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"[%08x] write %d -- bad mode\n"</span><span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_id<span class="token punctuation">,</span> fdnum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 3: Read starting from seek position.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>debug<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"write %d %p %d via dev %s\n"</span><span class="token punctuation">,</span> fdnum<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>dev_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token operator">-&gt;</span>dev_read<span class="token punctuation">)</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fd<span class="token operator">-&gt;</span>fd_offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Step 4: Update seek position and set '\0' at the end of buf.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fd<span class="token operator">-&gt;</span>fd_offset <span class="token operator">+=</span> r<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">)</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="readn">readn</h4><p>循环调用了read函数，作用同上。（个人感觉好像没什么用）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">readn</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> tot<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> tot <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> tot <span class="token operator">+=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>m <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf <span class="token operator">+</span> tot<span class="token punctuation">,</span> n <span class="token operator">-</span> tot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> tot<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="write">write</h4><p>将buf的前n个字节的数据复制到指定文件描述符（下标fdnum）所代表的文件中。返回值是最终实际写入的字节数<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">||</span>  <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dev_lookup</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_omode <span class="token operator">&amp;</span> O_ACCMODE<span class="token punctuation">)</span> <span class="token operator">==</span> O_RDONLY<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"[%08x] write %d -- bad mode\n"</span><span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_id<span class="token punctuation">,</span> fdnum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>debug<span class="token punctuation">)</span> <span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"write %d %p %d via dev %s\n"</span><span class="token punctuation">,</span>  fdnum<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>dev_name<span class="token punctuation">)</span><span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token operator">-&gt;</span>dev_write<span class="token punctuation">)</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fd<span class="token operator">-&gt;</span>fd_offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fd<span class="token operator">-&gt;</span>fd_offset <span class="token operator">+=</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="seek">seek</h4><p>将文件描述符所记录的文件指针设置为offset的位置，和标准库中的fseek函数的作用相同。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">seek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> u_int offset<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>fd<span class="token operator">-&gt;</span>fd_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="fstat">fstat</h4><p>将fsnum所代表的文件描述符的状态记录在stat中。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Stat</span> <span class="token operator">*</span>stat<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">||</span>  <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dev_lookup</span><span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>stat<span class="token operator">-&gt;</span>st_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>stat<span class="token operator">-&gt;</span>st_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>stat<span class="token operator">-&gt;</span>st_isdir <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>stat<span class="token operator">-&gt;</span>st_dev <span class="token operator">=</span> dev<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token operator">-&gt;</span>dev_stat<span class="token punctuation">)</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> stat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="stat">stat</h4><p>打开path所代表的文件（调用open函数），获取该文件的文件描述符fd，并将fd中储存的文件状态信息转存到stat中（调用fstat函数）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Stat</span> <span class="token operator">*</span>stat<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> r<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> fd<span class="token punctuation">;</span><span class="token punctuation">}</span>r <span class="token operator">=</span> <span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> stat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="userfile.c">user/file.c</h3><h4 id="open">open</h4><p>在用户进程中打开path所指定的文件，打开模式指定为mode。函数的主要步骤有三个——</p><ul><li>申请一个新的文件描述符</li><li>向文件服务进程申请open服务：在文件服务进程中打开path所指定的文件，并将文件控制块的地址等信息追加在用户进程文件描述符的后面。（这也就是问什么structFd可以强制转换为struct Filefd，并可以获取相关信息）</li><li>将文件服务进程中对应块缓存的数据复制到用户进程地址空间中<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>ffd<span class="token punctuation">;</span>u_int size<span class="token punctuation">,</span> fileid<span class="token punctuation">;</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span>u_int va<span class="token punctuation">;</span>u_int i<span class="token punctuation">;</span><span class="token comment">// Step 1: Alloc a new Fd, return error code when fail to alloc.</span><span class="token comment">// Hint: Please use fd_alloc.</span>ret <span class="token operator">=</span> <span class="token function">fd_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token comment">// Step 2: Get the file descriptor of the file to open.</span><span class="token comment">// Hint: Read fsipc.c, and choose a function.</span>ret <span class="token operator">=</span> <span class="token function">fsipc_open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token comment">// Step 3: Set the start address storing the file's content. Set size and fileid correctly.</span><span class="token comment">// Hint: Use fd2data to get the start address.</span>va <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>ffd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span>fileid <span class="token operator">=</span> ffd<span class="token operator">-&gt;</span>f_fileid<span class="token punctuation">;</span>size <span class="token operator">=</span> ffd<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">;</span><span class="token comment">// Step 4: Alloc memory, map the file content into memory.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2BLK<span class="token punctuation">)</span> <span class="token punctuation">{</span>ret <span class="token operator">=</span> <span class="token function">fsipc_map</span><span class="token punctuation">(</span>fileid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Step 5: Return the number of file descriptor.</span><span class="token keyword">return</span> <span class="token function">fd2num</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="file_close-1">file_close</h4><p>关闭文件，需要调用文件服务进程的相关服务将内存中的“脏”数据重写回磁盘，还需要将用户进程中文件数据所占用的地址空间释放（删去用户页表的映射）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>ffd<span class="token punctuation">;</span>u_int va<span class="token punctuation">,</span> size<span class="token punctuation">,</span> fileid<span class="token punctuation">;</span>u_int i<span class="token punctuation">;</span>ffd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span>fileid <span class="token operator">=</span> ffd<span class="token operator">-&gt;</span>f_fileid<span class="token punctuation">;</span>size <span class="token operator">=</span> ffd<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">;</span><span class="token comment">// Set the start address storing the file's content.</span>va <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Tell the file server the dirty page.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">fsipc_dirty</span><span class="token punctuation">(</span>fileid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Request the file server to close the file with fsipc.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fsipc_close</span><span class="token punctuation">(</span>fileid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"cannot close the file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Unmap the content of file, release memory.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"cannont unmap the file.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="file_read">file_read</h4><p>将fd所描述文件从偏移offset开始的n个字节写入buf中，返回值为有效写入的字节数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">,</span> u_int offset<span class="token punctuation">)</span><span class="token punctuation">{</span>u_int size<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span><span class="token comment">// Avoid reading past the end of file.</span>size <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&gt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">+</span> n <span class="token operator">&gt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>n <span class="token operator">=</span> size <span class="token operator">-</span> offset<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">user_bcopy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="read_map">read_map</h4><p>首先通过fdnum找到对应的文件描述符，然后找到该文件中偏移为offset的数据所在的虚拟地址va（用户地址空间中），最后将*blk赋值为va。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read_map</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> u_int offset<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>blk<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int va<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id <span class="token operator">!=</span> devfile<span class="token punctuation">.</span>dev_id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span>va <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&gt;=</span> MAXFILESIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_DISK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpd<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>PTE_V<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> vpt<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_DISK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>blk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_write">file_write</h4><p>将buf的前n个字节的数据写入fd所描述文件的offset处。需要注意的是，如果offset+n的值超过了文件原大小，则需要调用ftruncate函数进一步调整文件的大小。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">file_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> u_int n<span class="token punctuation">,</span> u_int offset<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int tot<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span><span class="token comment">// Don't write more than the maximum file size.</span>tot <span class="token operator">=</span> offset <span class="token operator">+</span> n<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tot <span class="token operator">&gt;</span> MAXFILESIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_DISK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Increase the file's size if necessary</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tot <span class="token operator">&gt;</span> f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">ftruncate</span><span class="token punctuation">(</span><span class="token function">fd2num</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">,</span> tot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Write the data</span><span class="token function">user_bcopy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="file_stat">file_stat</h4><p>将fd所描述的文件的状态记录到st中</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">file_stat</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Stat</span> <span class="token operator">*</span>st<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>st<span class="token operator">-&gt;</span>st_name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_name<span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token operator">-&gt;</span>st_size <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">;</span>st<span class="token operator">-&gt;</span>st_isdir <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_type <span class="token operator">==</span> FTYPE_DIR<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ftruncate">ftruncate</h4><p>这个函数的命名还是比较坑的，原因是该函数不仅可以截断文件，还可以增加文件的大小。这个函数需要根据size和文件原大小oldsize的关系来选择合适的操作（map/unmap）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token function">ftruncate</span><span class="token punctuation">(</span><span class="token keyword">int</span> fdnum<span class="token punctuation">,</span> u_int size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> r<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token operator">*</span>fd<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>u_int oldsize<span class="token punctuation">,</span> va<span class="token punctuation">,</span> fileid<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAXFILESIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_DISK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fd_lookup</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd<span class="token operator">-&gt;</span>fd_dev_id <span class="token operator">!=</span> devfile<span class="token punctuation">.</span>dev_id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span><span class="token punctuation">}</span>f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span><span class="token punctuation">)</span>fd<span class="token punctuation">;</span>fileid <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_fileid<span class="token punctuation">;</span>oldsize <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size<span class="token punctuation">;</span>f<span class="token operator">-&gt;</span>f_file<span class="token punctuation">.</span>f_size <span class="token operator">=</span> size<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fsipc_set_size</span><span class="token punctuation">(</span>fileid<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span>va <span class="token operator">=</span> <span class="token function">fd2data</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Map any new pages needed if extending the file</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>oldsize<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fsipc_map</span><span class="token punctuation">(</span>fileid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">fsipc_set_size</span><span class="token punctuation">(</span>fileid<span class="token punctuation">,</span> oldsize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Unmap pages if truncating the file</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>oldsize<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> BY2PG<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"ftruncate: syscall_mem_unmap %08x: %e"</span><span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="remove">remove</h4><p>将文件移除，只需要通过调用fsipc_remove函数即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// Your code here.</span><span class="token comment">// Call fsipc_remove.</span><span class="token keyword">return</span> <span class="token function">fsipc_remove</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="sync">sync</h4><p>使缓存区和磁盘上的内容同步，只需要通过调用fsipc_sync函数即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">fsipc_sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab4：系统调用和fork</title>
      <link href="/2022/05/09/os/os-lab4-shi-yan-bao-gao/"/>
      <url>/2022/05/09/os/os-lab4-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-4.1">Thinking 4.1</h3><p><strong>Q：</strong> <strong>思考并回答下面的问题：</strong></p><ul><li><strong>内核在保存现场的时候是如何避免破坏通用寄存器的？</strong></li><li><strong>系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息吗？</strong></li><li><strong>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</strong></li><li><strong>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？</strong></li></ul><p><strong>A：</strong></p><ul><li>内核使用宏函数<code>SAVE_ALL</code>来保存现场，在该函数的代码实现里，只使用了k0和k1两个通用寄存器来进行操作，从而保证其他通用寄存器的值都不会被改变。</li><li>可以。因为内核在陷入内核、保存现场的过程中，寄存器$a0-$a3中的值都没有被破坏。</li><li>用户在调用<code>msyscall</code>时，传入的参数会被保存在$a0-$a3寄存器和堆栈中。当陷入内核时，$a0-$a3寄存器不会被破坏，而且用户栈中的内容会被原封不动地被拷贝到内核栈（<code>KERNEL_SP</code>）中。因此，<strong><code>sys_*</code>函数可以从寄存器和用户栈获得"用户调用<code>msyscall</code>时传入的参数值"</strong>。</li><li>在处理过程中，将<code>Trapframe</code>中<code>epc</code>的值进行了一定处理，同时将<code>sys_*</code>函数的返回值存入<code>Trapframe</code>中的<code>v0</code>寄存器中。这种修改保证在进入用户态时，用户程序能够从正确的位置正确运行，同时也使得用户程序从<code>v0</code>寄存器中获得<strong>系统调用的返回值</strong>。</li></ul><h3 id="thinking-4.2">Thinking 4.2</h3><p><strong>Q：</strong><strong>思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib/env.c文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC部分的实现 与 envid2env() 函数的行为进行解释。</strong><br><strong>A：</strong>回顾<code>mkenvid</code>的实现我们会发现，<code>envid</code>的第10位永远是1，即保证了生成的<code>envid</code>一定是非0的——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u_int <span class="token function">mkenvid</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    u_int idx <span class="token operator">=</span> e <span class="token operator">-</span> envs<span class="token punctuation">;</span>    u_int asid <span class="token operator">=</span> <span class="token function">asid_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>asid <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> LOG2NENV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LOG2NENV<span class="token punctuation">)</span> <span class="token operator">|</span> idx<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>所以为什么将0作为一个保留值呢？我们能在<code>envid2env</code>函数中会找到答案——<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token operator">*</span>penv<span class="token punctuation">,</span> <span class="token keyword">int</span> checkperm<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* Hint: If envid is zero, return curenv.*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>envid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>penv <span class="token operator">=</span> curenv<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以发现，<strong>当<code>envid</code>的值是0时，函数会返回指向当前进程控制块的指针</strong>（通过形参<code>penv</code>返回）。当某些系统调用函数需要访问当前进程的进程控制块时，可以直接通过向<code>envid2env</code>传0来会获得指向当前进程控制块的指针，然后通过指针对进程控制块进行访问。<p></p><p>因此，<strong>0作为<code>envid</code>的保留值是为了方便程序直接通过<code>envid2env</code>函数来访问当前进程的进程控制块。</strong></p><h3 id="thinking-4.3">Thinking 4.3</h3><p><strong>Q：</strong><strong>思考下面的问题，并对这两个问题谈谈你的理解：</strong></p><ul><li><strong>子进程完全按照 fork()之后父进程的代码执行，说明了什么？</strong></li><li><strong>但是子进程却没有执行 fork()之前父进程的代码，又说明了什么？</strong></li></ul><p><strong>A：</strong><strong>前者说明子进程的代码段和父进程是完全一样的；后者说明子进程的初始上下文位置是在<code>fork</code>函数</strong>，也就是说，子进程的初始<code>PC</code>并不是在用户程序的入口，而是在父进程<code>EPC</code>指向的位置。</p><blockquote><p>子进程实际上是在”syscall_env_alloc的执行刚刚从内核态返回用户态“的时候开始运行的，更准确的说，是在msyscal函数返回的位置开始的。</p></blockquote><h3 id="thinking-4.4">Thinking 4.4</h3><p><strong>Q：</strong> <strong>关于 fork函数的两个返回值，下面说法正确的是：</strong></p><ul><li><strong>A、fork 在父进程中被调用两次，产生两个返回值</strong></li><li><strong>B、fork在两个进程中分别被调用一次，产生两个不同的返回值</strong></li><li><strong>C、fork只在父进程中被调用了一次，在两个进程中各产生一个返回值</strong></li><li><strong>D、fork只在子进程中被调用了一次，在两个进程中各产生一个返回值</strong></li></ul><p><strong>A：</strong>当子进程被调度时，恢复的上下文环境是在<code>fork</code>函数中（实际上是<code>syscall_env_alloc</code>函数之后），但是这并非是真正的调用了<code>fork</code>函数，只是复制了父进程的上下文而已。此外，执行完<code>fork</code>函数后，父进程返回的是子进程的<code>envid</code>，子进程返回的是0，因此父子进程的返回值是不同的。综上，答案为C。</p><h3 id="thinking-4.5">Thinking 4.5</h3><p><strong>Q：</strong><strong>我们并不应该对所有的用户空间页都使用duppage进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合本章的后续描述、mm/pmap.c 中 mips_vm_init 函数进行的页面映射以及include/mmu.h 里的内存布局图进行思考。</strong></p><p><strong>A：</strong><code>UTOP</code>和<code>TLIM</code>之间储存的是<strong>和内核相关的页表信息</strong>。在执行<code>env_alloc()</code>函数时，这一部分的映射关系直接从<code>boot_pgdir</code>拷贝到进程页表中，因此不需要进行映射。</p><p><code>UTOP</code>和<code>USTACKTOP</code>之间是<strong>异常处理栈（userexception stack）和无效内存（invalidmemory）</strong>，前者是进行异常处理的地方，后者一般也不会用到，所以父子进程不需要共享这部分的内存，也就不需要进行映射了。</p><p>所以，最终需要被映射的页面<strong>只有<code>USTACKTOP</code>之下的部分</strong>。</p><h3 id="thinking-4.6">Thinking 4.6</h3><p><strong>Q：</strong><strong>在遍历地址空间存取页表项时你需要使用到vpd和vpt这两个“指针的指针”，请参考user/entry.S 和 include/mmu.h中的相关实现，思考并回答这几个问题：</strong></p><ul><li><strong>vpt和vpd的作用是什么？怎样使用它们？</strong></li><li><strong>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</strong></li><li><strong>它们是如何体现自映射设计的？</strong></li><li><strong>进程能够通过这种方式来修改自己的页表项吗？</strong></li></ul><p><strong>A：</strong></p><ul><li><code>vpt</code>和<code>vpd</code>分别是指向用户页表和用户页目录的指针，可以用来对用户页表和页目录进行访问。在使用的时候，以<code>vpt</code>为例，先用<code>*</code>运算符获得页表基地址，然后从要访问的虚拟地址中获得页表项相对基地址的偏移，最后两个相加就得到指向页表项的指针，这样我们就可以通过这个指针来对页表项进行访问。vpd同理。</li><li>在<code>entry.S</code>中我们可以找到<code>vpt</code>和<code>vpd</code>的定义——<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">.</span>globl vptvpt<span class="token operator">:</span>    <span class="token punctuation">.</span>word UVPT<span class="token punctuation">.</span>globl vpdvpd<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token function">word</span> <span class="token punctuation">(</span>UVPT<span class="token operator">+</span><span class="token punctuation">(</span>UVPT<span class="token operator">&gt;&gt;</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以发现，<code>vpt</code>和<code>vpd</code>分别指向了两个值——<code>UVPT</code>和<code>(UVPT+(UVPT&gt;&gt;12)*4)</code>，这两个值分别是用户地址空间中页表的首地址和页目录的首地址。所以我们可以直接通过<code>vpt</code>和<code>vpd</code>访问到用户进程页表和页目录。</li><li>上面说到，<code>vpd</code>的值是<code>(UVPT+(UVPT&gt;&gt;12)*4)</code>，而这个地址正好在<code>UVPT</code>和<code>UVPT+PDMAP</code>之间，说明页目录被映射到了某一个页表的位置。我们知道，每一个页表都被页目录中的一个页表项所映射。因此"页目录被映射到某一个页表的位置"就意味着，<strong>在页目录中一定有一个页表项映射到了页目录本身</strong>，即实现了自映射。</li><li>不能，页表是内核态程序维护的，用户进程只能对页表项其进行访问，而不能对其进行修改。</li></ul><h3 id="thinking-4.7">Thinking 4.7</h3><p><strong>Q：</strong> <strong>page_fault_handler函数中，你可能注意到了一个向异常处理栈复制Trapframe运行现场的过程，请思考并回答这几个问题：</strong></p><ul><li><strong>这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？</strong></li><li><strong>内核为什么需要将异常的现场Trapframe复制到用户空间？</strong></li></ul><p><strong>A：</strong> 解答如下——</p><ul><li><p>当用户程序写入了一个<code>COW</code>页，OS就会进入<strong>页写入异常的处理程序</strong>，最终调用<strong>用户态</strong>的<code>pgfault</code>函数进行处理。但是，如果在<code>pgfault</code>函数的处理过程中又写入了一个<code>COW</code>页，就会再次进入页写入异常处理程序，然后又调用<code>pgfault</code>函数……这就出现了”中断重入“的现象。<br>目前，<code>pgfault</code>函数的实现是不会出现中断重入的。因为在这个函数里，我们只对异常处理栈所在的页进行了读写（异常处理程序中的临时变量都保存在异常处理栈），而异常处理栈并非是父子进程共享的（详见Thinking4.6），不可能会有<code>COW</code>标志位。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pgfault</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span><span class="token punctuation">{</span>    u_int <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token comment">//writef("fork.c:pgfault():\t va:%x\n",va);</span>    va <span class="token operator">=</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//map the new page at a temporary place</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Pte<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"In pgfault: NOT A COW PAGE!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tmp <span class="token operator">=</span> USTACKTOP<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"In pgfault: MEMORY ALLOC FAILED!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//copy the content</span>    <span class="token function">user_bcopy</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//map the page on the appropriate place</span>    ret <span class="token operator">=</span> <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"In pgfault: MEMORY MAP FAILED!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//unmap the temporary place</span>    ret <span class="token operator">=</span> <span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"In pgfault: MEMORY UNMAP FAILED!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>所以，我们的MOS为什么还要支持”中断重入“呢？<p></p><p>实际上，用户态的页写入异常处理函数<strong>是用户态程序自行指定的</strong>，也就是说，每个用户程序都可以通过<code>syscall_set_pgfault_handler()</code>函数<strong>注册一个自己的页写入异常处理函数</strong>（直接向<code>syscall_set_pgfault_handler()</code>传递一个函数指针即可）。在MOS中，我们向<code>syscall_set_pgfault_handler()</code>传递的是<code>pgfault</code>函数指针，这个函数只对异常处理栈所在的页进行了写操作，所以不会出现异常重入。但如果用户程序注册了一个其他的函数呢？假设这个新函数写了某些全局变量，还是可能会出现”异常重入“。</p><p>总而言之，<strong>支持”中断重入“可以使我们的程序有更好的可扩展性，使得用户程序可以根据需要注册自己的中断处理程序</strong>。如果内核不实现这个写入异常的重入的话，意味着用户处理函数甚至无法使用全局变量，这样就会有很大的局限性。</p><blockquote><p>补充：MOS中对”中断重入“的支持主要体现在——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">page_fault_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> BY2PG<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span>  <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>一旦进入这个<code>if</code>分支，就说明上下文中的<code>sp</code>寄存器的值就是在异常处理栈，也就是说在中断处理的过程中又发生了页写入中断。<p></p></blockquote></li><li><p>因为异常的处理是在用户态进行的，而<strong>用户态只能访问用户空间（低2G空间）内的数据</strong>，所以需要将现场保存在用户空间。</p></li></ul><h3 id="thinking-4.8">Thinking 4.8</h3><p><strong>Q：</strong><strong>到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：</strong></p><ul><li><strong>在用户态处理页写入异常，相比于在内核态处理有什么优势？</strong></li><li><strong>从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？</strong></li></ul><p><strong>A：</strong> 解答如下——</p><ul><li>尽量减少内核出现错误的可能，即使程序崩溃，也不会影响系统的稳定。同时微内核的模式下，用户态进行新页面的分配映射也更加灵活方便。</li><li>在进入用户态的异常处理程序前，将通用寄存器中的值存储在一个特殊的栈空间——<strong>异常处理栈</strong>；执行完异常处理程序后，在从异常处理栈恢复到通用寄存器。</li></ul><h3 id="thinking-4.9">Thinking 4.9</h3><p><strong>Q：</strong> <strong>请思考并回答以下几个问题：</strong></p><ul><li><strong>为什么需要将set_pgfault_handler的调用放置在syscall_env_alloc之前？</strong></li><li><strong>如果放置在写时复制保护机制完成之后会有怎样的效果？</strong></li><li>**子进程是否需要对在entry.S定义的字__pgfault_handler赋值？**</li></ul><p><strong>A：</strong> 解答如下——</p><ul><li><p>其实<code>set_pgfault_handler</code>并不一定要置在<code>syscall_env_alloc</code>之前，只要放在“写时复制机制建立”之前即可。理由如下——<br> <br>我们知道，在子进程真正运行之前，父进程会将需要与子进程共享的页面共享给子进程，并同时设置写时复制机制。在这个过程中，<strong>父进程数据段里的全局变量也就变成了子进程的全局变量</strong>，因此只要在此之前父进程的<code>__pgfault_handler</code>已经被赋值过，那么设置完写时复制机制之后，子进程中<code>__pgfault_handler</code>的值就同样被"赋值"了（和父进程保持一致）<br> <br><strong>因此，<code>set_pgfault_handler</code>必须在”写时复制机制“完成之前。</strong><code>set_pgfault_handler</code>无论是放<code>syscall_env_alloc</code>之前还是之后，其实都没有问题。</p><p> <br>但是如果非要问为什么”<code>set_pgfault_handler</code>的调用放置在<code>syscall_env_alloc</code>之前“，大概是因为，这样可以节省子进程的运行时间，因为子进程是在"<strong><code>syscall_env_alloc</code>的执行刚刚从内核态返回用户态</strong>"的时候开始运行的。</p><p> </p></li><li><p>通过上面的解释可以知道，如果将<code>set_pgfault_handler</code>放置在写时复制保护机制完成之后，那么<strong>子进程中的全局变量<code>__pgfault_handler</code>就不会被赋值</strong>，那么页写入异常处理机制也就无法被建立起来。</p></li><li><p>不需要，因为父进程已经通过<code>set_pgfault_handler</code>函数将<code>__pgfault_handler</code>赋值为<code>pgfault</code>的函数地址了，并且在写时复制机制建立时将数据段里的全局变量都"复制"到了子进程的数据段（包括<code>__pgfault_handler</code>），因此子进程不需要再对其进行赋值。</p></li></ul><h2 id="实验难点图示">实验难点图示</h2><p>本次实验实验主要包含以下两个难点——</p><ul><li><strong>系统调用的处理流程</strong></li><li><strong>页写入异常处理机制的建立</strong></li><li><strong>页写入异常处理流程</strong></li></ul><h3 id="系统调用的处理流程">系统调用的处理流程</h3><p>系统调用的处理流程和时钟中断的处理流程相似：用户使用系统调用后，CPU进入内核态，并通过异常分发程序的分发进入到了异常服务函数<code>handle_sys</code>。然后，<code>handle_sys</code>函数根据传入的系统调用号跳转到具体的处理函数<code>sys_*</code>。经过一系列处理，最后返回用户态。</p><p>整个流程如下图所示——</p><p><img src="1.svg"></p><h3 id="页写入异常处理机制的建立">页写入异常处理机制的建立</h3><p>为建立起页写入异常处理机制，我们需要完成以下三个任务——</p><ul><li>为进程的异常处理栈分配物理页面</li><li>将进程控制块的异常处理栈地址设置为<code>UXSTACKTOP</code>，将异常处理函数地址设置为<code>__asm_pgfault_handle</code></li><li>将全局变量<code>__pgfault_handler</code>赋值为<code>pgfault</code>函数的地址</li></ul><p>因为父子进程都需要建立页写入异常处理机制，所以两者都需要完成上述的三个任务，即总共有6个任务。而这6个任务都由父进程通过fork函数完成的，具体过程如下——</p><p><img src="2.svg"></p><h3 id="页写入异常处理流程">页写入异常处理流程</h3><p>建立起页写入异常处理机制后，我们的操作系统就有了处理该异常的能力。每当写入<code>PTE_COW</code>为1的页面时，页写入异常就会被触发，处理流程如下所示——</p><p><img src="3.svg"></p><h2 id="体会与感想">体会与感想</h2><p>个人感觉这次实验的难度确实比Lab3高了很多，主要有两方面原因——一方面，fork函数本身就不太好理解，需要同时考虑父子进程的行为逻辑；另一方面，本次填写的十几个函数彼此密切相关，无论哪一个出现了问题都会导致评测出锅，所以定位bug简直就是大海捞针。虽然debug很痛苦，但是在这个过程中我又将代码重读了很多遍，对代码理解也更加深刻了。</p><p>最后，我还要在此感谢王廉杰学长，他帮我纠正了代码理解上的诸多错误，没有他的指导我也不可能这么顺利的完成Lab4的任务，再次表示感谢！！！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab3：进程调度</title>
      <link href="/2022/05/03/os/os-lab3-shi-yan-bao-gao/"/>
      <url>/2022/05/03/os/os-lab3-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lab3-实验报告">Lab3 实验报告</h1><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-3.1">Thinking 3.1</h3><p><strong>Q：</strong> <strong>思考<code>envid2env</code>函数:为什么<code>envid2env</code>中需要判断<code>e-&gt;env_id != envid</code>的情况？如果没有这步判断会发生什么情况？</strong></p><p><strong>A：</strong>通过阅读该函数的代码，我们能知道，<code>e</code>是根据<code>envid</code>的后10位从<code>envs</code>数组中获得的。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token operator">*</span>penv<span class="token punctuation">,</span> <span class="token keyword">int</span> checkperm<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>envid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>penv <span class="token operator">=</span> curenv<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span>envid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span>envid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>但是这样获得的<code>e</code>的<code>envid</code>不一定和<code>envid</code>相同，因为<code>envid</code>中还有<code>ASID</code>字段（11-16位），当<code>envs</code>中的某一个进程控制块被替换，新生成的<code>envid</code>的后10不变，但是<code>ASID</code>字段会改变。所以我们需要进一步判断<code>e-&gt;env_id != envid</code>是否成立。<p></p><p>如果不判断，则通过最终获得的<code>e</code>可能并不是我们想要的内存控制块，而如果对这个错误的内存控制块操作，则可能会导致内存控制出现混乱（例如获得一个仍在<code>env_free_list</code>中的PCB，然后运行它）。</p><h3 id="thinking-3.2">Thinking 3.2</h3><p><strong>Q：</strong> <strong>结合include/mmu.h中的地址空间布局，思考<code>env_setup_vm</code> 函数：</strong></p><ul><li><strong><code>UTOP</code>和<code>ULIM</code>的含义分别是什么，<code>UTOP</code> 和<code>ULIM</code>之间的区域与UTOP以下的区域相比有什么区别？</strong></li><li><strong>请结合系统自映射机制解释代码中<code>pgdir[PDX(UVPT)]=env_cr3</code>的含义。</strong></li><li><strong>谈谈自己对进程中物理地址和虚拟地址的理解。</strong></li></ul><p><strong>A：</strong></p><ul><li><p><code>ULIM</code>是<code>kseg0</code>和<code>kuseg</code>的分界线，也是内核态虚拟内存区和用户态虚拟内存区的分界线；<code>UTOP</code>是<code>kuseg</code>中只读区和可读写区的分界线。<strong><code>UTOP</code>和<code>ULIM</code>之间是只读区域</strong>，用来存放用户的进程信息和页表信息；<strong><code>UTOP</code>之下的是可读写区域</strong>，用户可以自由读写。</p></li><li><p><code>UVPT</code>是<code>kuseg</code>中保存用户（当前进程）页表信息的虚拟内存区，大小为4MB（0x7fc00000-0x80000000），<code>env_cr3</code>是进程页目录所在的物理地址。<code>pgdir[PDX(UVPT)]=env_cr3</code>表示页目录中第<code>PDX(UVPT)</code>项映射到页目录本身的物理地址，实现自映射机制。</p></li><li><p>在用户进程中使用的是虚拟地址（用户可见），然后MMU通过查询页表得到对应的物理地址（用户不可见），并最终通过物理地址在物理内存中获取值。</p></li></ul><h3 id="thinking-3.3">Thinking 3.3</h3><p><strong>Q：</strong> <strong>找到 <code>user_data</code>这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）</strong></p><p><strong>A：</strong> <code>user_data</code> 在 <code>load_elf</code>和 <code>load_icode_mapper</code> 两个函数中用到。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//env.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_icode_mapper</span><span class="token punctuation">(</span>u_long va<span class="token punctuation">,</span> u_int32_t sgsize<span class="token punctuation">,</span>                             u_char <span class="token operator">*</span>bin<span class="token punctuation">,</span> u_int32_t bin_size<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//kernel_elfloader.c</span><span class="token keyword">int</span> <span class="token function">load_elf</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> u_long <span class="token operator">*</span>entry_point<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>user_data<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>map<span class="token punctuation">)</span><span class="token punctuation">(</span>u_long va<span class="token punctuation">,</span> u_int32_t sgsize<span class="token punctuation">,</span>  u_char <span class="token operator">*</span>bin<span class="token punctuation">,</span> u_int32_t bin_size<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>user_data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>phdr<span class="token operator">-&gt;</span>p_vaddr<span class="token punctuation">,</span> phdr<span class="token operator">-&gt;</span>p_memsz<span class="token punctuation">,</span> binary <span class="token operator">+</span> phdr<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">,</span> phdr<span class="token operator">-&gt;</span>p_filesz<span class="token punctuation">,</span> user_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不可以没有这个参数，因为在<code>load_elf</code>函数中需要进一步将这个参数传递给函数指针<code>map</code>（实际上指向的是<code>load_icode_mapper</code>）。</p><h3 id="thinking-3.4">Thinking 3.4</h3><p><strong>Q：</strong> <strong>结合<code>load_icode_mapper</code>的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？</strong><br><strong>A：</strong><code>va</code>和<code>va+bin_size</code>的相对位置有以下6种</p><p><img src="3.4-1.png"></p><p><code>va+bin_size</code>和<code>va+sg_size</code>的相对位置有以下6种</p><p><img src="3.4-2.png"></p><h3 id="thinking-3.5">Thinking 3.5</h3><p><strong>Q：</strong> <strong>思考上面这一段话，并根据自己在lab2中的理解，回答：</strong></p><ul><li><strong>你认为这里的 <code>env_tf.pc</code>存储的是物理地址还是虚拟地址?</strong></li><li><strong>你觉得<code>entry_point</code>其值对于每个进程是否一样？该如何理解这种统一或不同？</strong></li></ul><p><strong>A：</strong>env_tf.pc中存储的是虚拟地址。对于每个用户进程来说entry_point都是一样的（如果不手动进行设置的话），这样可使让程序的每次执行都从一个固定的虚拟地址开始，这种统一对CPU是友好的。</p><h3 id="thinking-3.6">Thinking 3.6</h3><p><strong>Q：</strong><strong>请查阅相关资料解释，上面提到的<code>epc</code>是什么？为什么要将<code>env_tf.pc</code>设置为<code>epc</code>呢？</strong></p><p><strong>A：</strong><code>epc</code>是CP0中的一个寄存器（14号），用于保存使该进程出现异常（包括中断）时指令所在的<code>pc</code>。进程因异常被切换时将<code>env_tf.pc</code>设置为<code>epc</code>，实际上就是保存了“该进程运行到了什么地方”。这样就可以使进程在下一次被调度时，<strong>直接从上次出现异常的位置继续向后运行</strong>。</p><h3 id="thinking-3.7">Thinking 3.7</h3><p><strong>Q：</strong> <strong>关于<code>TIMESTACK</code>，请思考以下问题：</strong></p><ul><li><strong>操作系统在何时将什么内容存到了 <code>TIMESTACK</code>区域</strong></li><li><strong><code>TIMESTACK</code> 和 <code>env_asm.S</code> 中所定义的<code>KERNEL_SP</code> 的含义有何不同</strong></li></ul><p><strong>A：</strong>操作系统在发生时钟中断时时将<strong>原进程</strong>的<code>env_tf</code>中的内容保存到<code>TIMESTACK</code>区域（在<code>handle_int</code>函数中通过<code>SAVE_ALL</code>实现）。<code>TIMESTACK</code>时发生时钟中断时的栈顶指针，<code>KERNEL_SP</code>是发生其他中断时的栈顶指针。</p><h3 id="thinking-3.8">Thinking 3.8</h3><p><strong>Q：</strong> <strong>试找出上述 4个异常处理函数的具体实现位置</strong><br><strong>A：</strong><code>handle_int</code>和<code>handle_sys</code>的实现位置比较容易找到，前者在<code>genex.S</code>文件中，后者在<code>syscall.S</code>文件中。而<code>handle_mod</code>和<code>handle_tlb</code>藏得比较深，两者都是通过<code>genex.S</code>文件中的宏函数<code>BUILD_HANDLER</code>实现的。<br></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#宏函数.macroBUILD_HANDLER exception handler clear.align5NESTED(handle_\exception, TF_SIZE, sp)  .setnoatnopSAVE_ALL__build_clear_\clear.setatmovea0, spjal\handlernopjret_from_exceptionnopEND(handle_\exception).endm#具体实现BUILD_HANDLER reserved do_reserved cliBUILD_HANDLER tlbdo_refillcliBUILD_HANDLER modpage_fault_handler cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-3.9">Thinking 3.9</h3><p><strong>Q：</strong> <strong>阅读 <code>kclock_asm.S</code> 和<code>genex.S</code> 两个文件，并尝试说出 <code>set_timer</code> 和<code>timer_irq</code> 函数中每行汇编代码的作用</strong><br><strong>A：</strong> <code>set_time</code>函数的分析如下<br></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.macrosetup_c0_status set clr.setpushmfc0t0, CP0_STATUSort0, \set|\clrxort0, \clrmtc0t0, CP0_STATUS.setpop.endmLEAF(set_timer)li t0, 0xc8sb t0, 0xb5000100#在地址0xb5000100中写入0xc8，使时钟频率设为200swsp, KERNEL_SP#将sp寄存器中的值存入地址KERNEL_SP中setup_c0_status STATUS_CU0|0x1001 0#将CP0的SR寄存器中第1、12、28位 置为1，作用是开启全局中断使能和始终中断使能，并允许用户态使用CP0jr ra#函数返回nopEND(set_timer)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>time_irq</code>函数的分析如下<br><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">timer_irq:sb zero, 0xb5000110#在地址0xb0000110中写入0，响应时钟中断1:jsched_yield#跳转到sched_yield函数，进行进程切换nop/*li t1, 0xfflw    t0, delayaddu  t0, 1swt0, delaybeqt0,t1,1fnop*/jret_from_exception#跳转到ret_from_exception函数nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-3.10">Thinking 3.10</h3><p><strong>Q：</strong><strong>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</strong><br><strong>A：</strong><code>env_sched_list</code>有两个链表存放就绪进程。当进程被创建时，我们将其插入第一个进程调度链表的头部。调用<code>sched_yield</code> 函数时,先判断当前时间片是否用完。如果用完，则将其插入另一个链表的结尾，之后判断当前就绪状态进程链表是否为空。如果为空,将指针切换到另一个就绪状态进程链表。最后从指针指向的链表的头部获取一个就绪进程进行切换。</p><h2 id="实验难点图示">实验难点图示</h2><p>我认为该实验的难点在于理解<strong>进程的创建流程</strong>、<strong>时钟中断的处理流程</strong>和<strong>进程的切换流程</strong>。</p><h3 id="进程创建流程">进程创建流程</h3><p><img src="create.png"></p><h3 id="时钟中断的处理流程">时钟中断的处理流程</h3><p><img src="irq.png"></p><h3 id="进程切换流程">进程切换流程</h3><p><img src="run.png"></p><h2 id="体会与感想">体会与感想</h2><p>Lab3要求我们实现<strong>进程的创建、切换和调度</strong>，其中进程的调度主要是通过设置异常处理机制来实现。</p><p>本次实验的难度比Lab2稍稍低一些，主要原因是本次lab中各个函数之间的联系比较紧密。虽然某些复杂函数理解起来还是有些困难，但是如果在宏观上把握这些函数的关系，那么对于单个函数的理解就变得相对容易了。</p><p>所以，在阅读复杂工程的代码时，不要急于阅读每一个函数的细节，而是应该首先搞清楚<strong>工程的文件结构</strong>（bymakefile）和<strong>不同函数之间的关系</strong>（bydoc），然后再按照一定的逻辑顺序阅读代码，这样就可以达到事半功倍的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OO」第二单元:电梯调度</title>
      <link href="/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/"/>
      <url>/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>OO第二单元的主题是<strong>"多线程"</strong>，主要是让我们初步学习多线程的编程思想，理解和解决线程交互和线程安全问题，进一步深化对<strong>"面向对象"</strong> 的理解。</p><p>本单元的三次作业都是和 <strong>"电梯调度问题"</strong>有关，需要我们根据不同要求对电梯调度系统进行模拟。这三次作业不仅要求我们关注<strong>"如何正确的加锁来解决线程安全问题"</strong>，还要求我们考虑到<strong>调度策略的整体性能</strong>。</p><p>由于以前没有接触过多线程编程，因此刚开始做作业时稍微有些吃力。但是我随着对<strong>"多线程"</strong> 和 <strong>"线程同步"</strong>理解的加深，在做后面的作业时越来越得心应手。同时，我也学会在代码中使用一些常用的设计模式，例如<strong>"单例模式"、"工厂模式"、"流水线模式"</strong>等等，进一步降低代码的耦合度，让代码层次更加清晰。</p><h2 id="第一次作业分析">第一次作业分析</h2><p><a href="面向对象第二单元第一次作业指导书.pdf">题目链接</a></p><p>第一次作业比较简单，每个楼座只对一部电梯进行调度。这次作业主要是让我们熟悉线程创建、运行等基本操作，熟悉多线程的设计方法。</p><h3 id="代码架构分析">代码架构分析</h3><p>本次作业中我们需要关注以下三个问题</p><ul><li><strong>如何将"生产者-消费者"模型运用在本次作业中？</strong></li><li><strong>如何通过加锁来解决线程安全问题？</strong></li><li><strong>电梯调度采用什么样的策略？</strong></li></ul><p>下面我针对这三个问题进行分析——</p><h4 id="producer-consumer模型">Producer-Consumer模型</h4><p>在使用"生产者-消费者"模型之前我们需要明确——谁是消费者？谁是生产者？经过简单的分析我们不难发现——</p><ul><li><strong>输入线程</strong>（<code>InputHandler</code>）从终端中获取用户的请求，所以输入线程是生产者</li><li><strong>电梯线程</strong>（<code>Elevator</code>）对用户请求进行处理，并将用户运送指定位置，因此电梯线程应该作为消费者。</li><li>生产者和消费者中间的托盘是什么呢？很显然，托盘应该是一个用来盛放用户请求的"容器"，于是我设置了<strong>请求队列类</strong>（<code>RequestTable</code>）用来存放请求。</li></ul><p>在我的设计中，<code>RequestTable</code>类一共实例化了<strong>5个对象</strong>，分别用来储存A、B、C、D、E座发出的请求。<code>InputHandler</code>类同时"拥有"这5个请求队列，在请求输入的时候直接根据<strong>请求发出地</strong>将请求放进对应的请求队列中。每个楼座的<code>Elevator</code>只有拥有本楼座的请求队列，只对该请求队列中的请求进行处理。所以最后的结构就是下面这个样子——<br><img src="HW1结构.png"></p><p>另外，基于封装的思想，我还对用户请求单独建一个类（<code>Person</code>）,在这个类中封装了单个请求的所有信息，包括<strong>请求人id</strong>、<strong>出发地</strong>、<strong>目的地</strong>。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> fromBuilding<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> toBuilding<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fromFloor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> toFloor<span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>所以，请求（<code>Person</code>）是以什么形式存放在请求队列<code>RequestTable</code>呢？原来，在<code>RequestTable</code>类中我们有一个<code>requestMap</code>成员变量<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResquestTable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> endTag<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> requestMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>很明显，<code>requestMap</code>的类型是<code>HashMap</code>，其中<code>key</code>代表<strong>楼层序号</strong>（<span class="math inline">\(key\in[1,10]\)</span>），<code>value</code>表示的是<strong>在每个楼层发出的请求的集合</strong>。例如<code>requestMap.get(5)</code>就代表<strong>"出发地在5楼的所有请求的集合"</strong>。<p></p><h4 id="锁的设置">锁的设置</h4><p>请求队列<code>RequestTable</code>可以<strong>同时被输入线程和电梯线程访问</strong>，因此存在线程安全问题。在本次作业中，我主要是采用了”对方法加锁“的方式，将<code>RequestTable</code>涉及到成员变量读写的方法全部加了锁，这样就可以保证每次只有一个线程来访问请求队列。</p><h4 id="调度策略">调度策略</h4><p>众所周知，电梯调度问题本身是没有一个最优解的——一个算法在某种情况下可能效率比较高，但是总会出现一种特殊情况，使得该算法的性能远远落后于其他算法。目前已经有许多和电梯调度相关的算法，例如<code>ALS</code>,<code>LOOK</code>,<code>SCAN</code>等等，我们需要从中挑选一个<strong>平均性能占优并且比较稳定</strong>的算法。</p><p>往届学长大多选择的是<strong>LOOK算法</strong>，而且我们日常乘坐的电梯大多数也是采用的这种算法。既然它能被大多数电梯使用，那这种算法一定有它的"过人之处"。因此，最终我选择<strong>LOOK</strong>作为电梯调度的策略。</p><h5 id="look">LOOK</h5><p>下面来简单介绍我在本次作业中使用的调度算法（LOOK）——</p><ul><li>首先为电梯规定一个初始方向，然后电梯开始沿着该方向运动。</li><li>到达某楼层时，<strong>首先判断是否需要开门</strong><ul><li>如果发现电梯里有人可以出电梯（到达目的地），则开门让乘客出去；</li><li>如果发现该楼层中有人想上电梯，并且目的地方向和电梯方向相同，则开门让这个乘客进入。</li></ul></li><li><strong>接下来，进一步判断电梯里是否有人</strong>。如果电梯里还有人，则沿着当前方向移动到下一层。否则，检查请求队列中是否还有请求（目前其他楼层是否有乘客想要进电梯）——<ul><li><p>如果请求队列不为空，且某请求的发出地是电梯"前方"的某楼层，则电梯继续沿着原来的方向运动。</p></li><li><p>如果请求队列不为空，且所有请求的发出地都在电梯"后方"的楼层上，或者是在该楼层有请求但是这个请求的目的地在电梯后方（因为电梯不会开门接反方向的请求），则电梯掉头并进入"判断是否需要开门"的步骤（循环实现）。</p></li><li><p>如果请求队列为空，且输入线程没有结束（即没有输入文件结束符），则电梯停在该楼层等待请求输入（wait）。</p><blockquote><p>注意：电梯等待时运行方向不变。在我的设计中，运行方向是电梯的一个状态量而不是过程量，用来表示<strong>下一次move时的方向</strong>。当有新请求进入请求队列时，电梯被唤醒，此时电梯的运行方向仍然是电梯wait前的方向。</p></blockquote></li><li><p>如果请求队列为空，且输入线程已经结束，则电梯线程结束。</p></li></ul></li></ul><h5 id="策略类的设置">策略类的设置</h5><p>在本次作业中我采用了 <strong>"电梯类和策略类分离"</strong>的设计。策略类（<code>Strategy</code>）可以获得<strong>当前电梯和请求队列的当前状态</strong>，并基于LOOK策略向电梯提供建议，建议包括<code>OVER</code>,<code>MOVE</code>, <code>REVERSE</code>, <code>OPEN</code>,<code>WAIT</code>五种。我们把这些建议封装到枚举类<code>Advice</code>中，以提高代码的可读性。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*Strategy.java*/</span><span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token keyword">int</span> curFloor<span class="token punctuation">,</span> <span class="token keyword">int</span> curNum<span class="token punctuation">,</span> <span class="token keyword">boolean</span> direction<span class="token punctuation">,</span>                        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> destMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//判断现在是否可以上下电梯</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canOpenForOut</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> destMap<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">canOpenForIn</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> curNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果电梯里有人</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curNum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">MOVE</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果电梯里没有人</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//如果请求队列中没有人</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestTable<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>requestTable<span class="token punctuation">.</span><span class="token function">isOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OVER</span><span class="token punctuation">;</span> <span class="token comment">//如果输入结束，电梯线程结束</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">WAIT</span><span class="token punctuation">;</span> <span class="token comment">//如果输入未结束，电梯线程等待</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果请求队列中有人</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasReqInOriginDirection</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> direction<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">MOVE</span><span class="token punctuation">;</span> <span class="token comment">//如果有请求发出地在电梯“前方”，则前当前方向移动一层</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">;</span> <span class="token comment">//否则，电梯转向（仅状态改变，电梯不移动）</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><code>Strategy</code>类<strong>聚合</strong>在<code>Elevator</code>类中，电梯每到达一个楼层，就会调用策略类的<code>getAdvice()</code>方法来询问建议，并根据建议做出反应。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*Elevator.java*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Advice</span> advice <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> building<span class="token punctuation">,</span> floor<span class="token punctuation">,</span>                                        direction<span class="token punctuation">,</span>passenger<span class="token punctuation">,</span> requestTable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OVER</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>                              <span class="token comment">//电梯线程结束</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">MOVE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">//电梯沿着原方向移动一层</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            direction <span class="token operator">=</span> <span class="token operator">!</span>direction<span class="token punctuation">;</span>             <span class="token comment">//电梯转向</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">WAIT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            requestTable<span class="token punctuation">.</span><span class="token function">waitRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//电梯等待</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token function">openAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//电梯开门</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="代码复杂度分析">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="1_metrics.png"></p><p>由上面的分析可知，<code>Strategy</code>类中<code>gerAdvice()</code>、<code>hasReqInOrigin()</code>、<code>needAdjustDirection()</code>三个方法的复杂度较高。主要原因是<code>Strategy</code>类需要对电梯和请求队列的状态进行分析，从而为电梯提供建议，而整个判断过程需要较为复杂的逻辑（循环、大量if-else），因此复杂度显著高于其他方法。</p><p>但总体来说，本次作业代码的整体复杂度较为理想。主要是因为有了第一单元的经验，在设计时注意遵循了<strong>单一职责原则</strong>，避免出现较长的方法和类。</p><h3 id="代码uml图">代码UML图</h3><h4 id="类图">类图</h4><p><img src="1.jpg"></p><h4 id="时序图">时序图</h4><p><img src="1_seq.png"></p><hr><h2 id="第二次作业分析">第二次作业分析</h2><p><a href="面向对象第二单元第二次作业指导书.pdf">题目链接</a></p><p>第二次作业在第一次的基础上增加了横向电梯，这种电梯只能在某一楼层的不同楼座（A-E座）之间运动。此外，每一楼座、每一楼层的电梯也不止一部，可以动态增长。</p><h3 id="代码架构分析-1">代码架构分析</h3><h4 id="工厂模式">工厂模式</h4><p>本次作业电梯种类有所增加，为了提高代码可扩展性，我采用了工厂模式进行设计。首先我定义了一个抽象电梯类<code>Elevator</code>，该类实现<code>Runable</code>接口，并重写了<code>run()</code>方法（<code>run()</code>在<code>Elevator</code>类中是<strong>抽象方法</strong>）。然后我又定义了<code>VerticalElevator</code>类和<code>LateralElevator</code>类来继承<code>Elevator</code>，这两个类分别表示纵向电梯和横向电梯，并都对父类的<code>run()</code>方法进行重写。</p><p>当输入线程接收到“增加电梯”的指令时，就会把该请求传到工厂类对象中，然后工厂类根据<strong>新增电梯的类型</strong>生产出对应类型的电梯，向上转型为<code>Elevator</code>然后返回。</p><p><img src="HW2工厂模式.png"></p><p>此外，不管是横向电梯还是纵向电梯，都需要策略类来为电梯提供建议。但是，横向电梯和纵向电梯的调度策略又不完全相同，因此我们不能用一个策略类来组装两种电梯，而是<strong>需要为每一种电梯分别建立一个策略类</strong>。</p><p>不同的策略类都需要<code>getAdvice()</code>方法为不同电梯提供建议，<strong>在行为上有相似之处</strong>。基于抽象原则，我们定义了一个策略类接口<code>Strategy</code>，并在该接口中定义<code>getAdvice()</code>方法，然后定义<code>VerticalStrategy</code>类和<code>LateralStrategy</code>类分别实现该接口。电梯工厂在生产电梯时，会根据电梯种类来选择对应的策略类进行组装。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*ElevatorFactory.java*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ElevatorFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Elevator</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"building"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Strategy</span> strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VerticalStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">VerticalElevator</span><span class="token punctuation">(</span>strategy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Strategy</span> strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LateralStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LateralElevator</span><span class="token punctuation">(</span>strategy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="调度策略-1">调度策略</h4><h5 id="单电梯调度">单电梯调度</h5><p><code>VerticalStrategy</code>类为纵向电梯提供建议，因此可以直接使用第一次作业的设计。而在<code>LateralStrategy</code>类中，我采用的是一种<strong>"类似LOOK"的策略</strong>——</p><p>我们知道，横向电梯是可以在五个楼座之间<strong>循环移动</strong>的，因此无论你在哪一座，都可以按任意方向运动至目标楼座。但是，如果电梯自始至终都按一个方向运动，在某些情况下效率会比较低下。例如，有乘客想要从<strong>A座</strong>乘电梯到达<strong>E座</strong>，如果事先规定的方向是<strong>顺时针</strong>，那么电梯运动的路线就是<code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>。但是，显然<code>A-&gt;E</code>路线会更快。<br><img src="HW2横向电梯.png"><br>为解决上述问题，我借鉴了LOOK算法中 <strong>"及时掉头"</strong>的思想，让策略类根据电梯和请求队列的当前状态来判断当前是否需要掉头。"掉头"需要同时满足以下两个条件——<br>-电梯"前方"的<strong>两个座</strong>都没有请求发出，只有"后方"两个座发出来请求（无需关注请求的方向，因为横向电梯<strong>不采用同向捎带</strong>的策略，而是能接则接）。通过上图来解释就是，目前电梯在A座，而B座和C座没有请求发出，而D座和E座中至少有一个发出了请求。<br>- 电梯里没有人，或者电梯里乘客的目的地都是电梯"后面"的两个座。</p><h5 id="多电梯协同">多电梯协同</h5><p>策略类只是为一个电梯的运行提供建议，但是每一个楼层（座）可能配置有多个电梯，那么这些电梯之间是如何协同的呢？或者说，如何把该楼层（座）的请求分配给这些电梯呢?</p><p>最终，我采用”自由竞争“的策略来解决电梯间协同的问题。</p><p>首先，每个楼层、每个楼座都有一个请求队列（一共有是15个），而每一个请求队列都被某楼层（座）的所有电梯拥有。整个结构如下图所示——<br><img src="HW2结构.png"></p><p>每个电梯的策略类在决策的时候，都是根据该电梯当前状态和整个请求队列的状态进行判断，并提出建议。此时，同一楼层（座）的两部电梯可能会按照策略类的建议开门接同一个请求，即<strong>两者竞争资源</strong>，但最终只有一个电梯能真正接到。</p><p>此时，我们会遇到一个<strong>线程同步问题</strong>——两个电梯同时在某一层竞争一个请求，一个电梯开门并接到了，但是此时另一个电梯只是开了门，但并没有接上人，白白浪费了一次开关门时间，导致在性能上大打折扣。</p><p>本人采用 <strong>"二次咨询+缓冲队列"</strong>的方式解决这个了问题——当电梯运行到某层时会向策略类咨询建议，如果发现当前建议是<code>OPEN</code>，电梯会<strong>重新咨询一次策略类</strong>，如果此时的策略仍然是<code>OPEN</code>，那么我们就先把该楼层（座）可以上电梯的乘客放在一个<strong>缓冲队列</strong>中，电梯开门后再将缓冲队列中的乘客加入电梯。需要注意的是，<strong>"二次咨询"和"加入缓冲队列"两个操作应该加锁，使其变成一个原子操作</strong>，这样就可以保证另一个电梯在二次咨询时不会得到<code>OPEN</code>的建议（因为此时能接的乘客已经从请求队列中移出，进入另一个电梯的缓冲队列中了）。具体实现如下——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*VerticalElevator.java*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Advice</span> advice <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> building<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OVER</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">MOVE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">WAIT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>advice <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> peopleServed <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//缓冲队列</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>requestTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//二次咨询</span>                <span class="token class-name">Advice</span> checkOpen <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> building<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>checkOpen <span class="token operator">!=</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">//将能接的人从请求队列中移出，加入到缓冲队列中</span>                peopleServed <span class="token operator">=</span> <span class="token function">pickPeople</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> floor<span class="token punctuation">,</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">openAndClose</span><span class="token punctuation">(</span>peopleServed<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="代码复杂度分析-1">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="2_metrics.png"></p><p>和上一次作业相比，这次<code>VerticalElecator</code>和<code>VerticalElevator</code>中<code>run()</code>方法的基本复杂度也显著上升，主要是因为，我们为解决空开门的问题使用了<strong>"二次咨询+缓冲队列"</strong>的机制，这种机制的引入使判断逻辑变得更加复杂。</p><h3 id="代码uml图-1">代码UML图</h3><h4 id="类图-1">类图</h4><p><img src="2.jpg"></p><h4 id="时序图-1">时序图</h4><p><img src="2_seq.png"></p><h2 id="第三次作业分析">第三次作业分析</h2><p><a href="面向对象第二单元第三次作业指导书.pdf">题目链接</a></p><p>第三次作业增加了3个新要求——</p><ul><li>电梯容量和运行速度可自定义</li><li>横向电梯的停靠楼座可自定义</li><li>可能会出现乘客换乘问题</li></ul><h3 id="代码架构分析-2">代码架构分析</h3><h4 id="电梯类的迭代">电梯类的迭代</h4><p>在本次作业中我们仍然沿用工厂模式。但是，本次电梯的<strong>运行速度（<code>speed</code>）和容量（<code>capacity</code>）</strong>是可以自定义的，所以我们需要在<strong>抽象电梯类<code>Elevator</code></strong>中增加这两个成员变量。此时，子类<code>VeritcalElevator</code>和<code>LateralElevator</code>也会拥有这两个属性。</p><p>另外，横向电梯并不是在所有楼座都可以停靠，因此我们还需要在<code>LateralElevator</code>类中单独设置一个<code>SwitchInfo</code>变量来记录可停靠信息。当横向电梯策略类在判断是否可以开门接人时，必须考虑<strong>"电梯是否能够在该楼座开门"</strong> 以及<strong>"电梯能否在乘客的目的楼座上开门"</strong>。</p><h4 id="流水线模式的使用">流水线模式的使用</h4><p>本次作业中乘客可能需要几次换乘才能到达目的地，为了解决这个问题，我采用了课上实验课学到的<strong>流水线模式</strong>。</p><p>首先，经过简单分析可知，每一个乘客的请求都可以<strong>分成三段</strong>——<strong>先纵向、再横向、再纵向</strong>。对于一些同楼层（座）的请求也可以分成三段，只不过在其中某段可能会出现<strong>"目的地和出发地相同"</strong>的情况，例如"A3-&gt;A6"可以拆分为"A3-&gt;A3, A3-&gt;A3,A3-&gt;A6"。此时，我们需要对请求类<code>Person</code>进行一定修改，以满足分段需求——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*Person.java*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> nowStage<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span><span class="token punctuation">&gt;</span></span> routeList<span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token comment">/*Route.java*/</span><span class="token comment">/*用该类来封装每一阶段的请求*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Route</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fromBuilding<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> toBuilding<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fromFloor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> toFloor<span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>而<strong>请求的分段操作</strong>是在<code>Controller</code>类中完成的。<code>Controller</code>类是一个全局控制器，采用单例模式，它有两个作用——</p><ul><li>将<code>InputHandler</code>类输入的乘客请求分成三个流水段，并封装到一个<code>Person</code>类中。</li><li>根据<strong>请求当前的执行阶段</strong>将其分配给相应的请求队列，最后由拥有该请求队列的电梯处理。每当电梯完成一个阶段，电梯就会把该请求"扔回到"<code>Controller</code>，并由<code>Controller</code>将请求<strong>再分配</strong>，让其他电梯执行下一阶段的任务。如果控制器发现某请求的所有阶段都已经执行完，则不再将其分配。</li></ul><p>最后整个流水线模式的架构如下图所示。<br><img src="HW3结构.png"></p><blockquote><p>关于中转楼层的选择，我采用的是指导书上的基准策略——假设乘客的起始楼座为P，目的楼座为Q，起始楼层为X,目的楼层为Y，则中转楼层m满足如下公式：<br>存在 "(M &gt;&gt; (P -'A')) &amp; 1) + ((M &gt;&gt; (Q -'A')) &amp; 1)== 2"，且使"|X-m| + |Y-m|"最小的m</p></blockquote><h4 id="电梯结束问题">电梯结束问题</h4><p>设想这样一种情况——</p><ul><li>输入线程发现了文件结束符，于是通过<code>Controller</code>给<strong>每个请求队列的<code>EndTag</code>都置为<code>True</code></strong>。</li><li>此时电梯A中所有请求都已完成，而且它的策略类发现电梯所在楼层（座）的请求队列的<code>EndTag</code>是真，于是向电梯发出了<code>OVER</code>建议，该电梯线程结束。</li><li>此时，另一个楼层（座）中的电梯B正在处理某请求R的第2阶段。不幸的是，R的第3阶段需要A来执行，所以，R请求会永远无法被满足。</li></ul><p>因此，在本次作业中，我们不能直接根据文件结束符来判断是否应该将请求队列的<code>EndTag</code>置为真，而是<strong>应该等待所有请求都执行完</strong>。这个问题我们可以通过设计<code>RequestCounter</code>类来解决。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*RequestCounter.java*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestCounter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RequestCounter</code>和我们在OS课上学到的信号量（<code>Samaphore</code>）极为相似，而<code>release()</code>和<code>acquire()</code>两个方法分别对应信号量的<strong><code>P</code>操作和<code>V</code>操作</strong>。这两个方法分别在<code>Controller</code>类和<code>InputHandler</code>类中使用——</p><ul><li>当一个请求的所有阶段都完成，<code>Controller</code>会调用<code>release()</code>方法，使计数器的值加1。</li><li>当输入线程<code>InputHandler</code>获取文件结束符后，会连续调用n次<code>acquire()</code>方法（n表示乘客请求的总个数），每次调用都会使计数器的值减1（如果在减操作之前发现计数器值为0时，则会等待计数器大于0之后再减1）。当n次<code>acquire()</code>都成功执行，则说明所有的乘客请求都已经处理完毕了，然后就可以将所有请求队列的<code>EndTag</code>置为真。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*InputHandler.java*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> personNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span>    <span class="token comment">//输入结束之后执行personNum次acquire()方法</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> personNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RequestCounter</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//所有的请求都已经执行完毕，通过Controller将所有请求队列的`EndTag`置为真</span>    <span class="token class-name">Controller</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>这样一来，电梯结束的问题就成功解决了。</p><h3 id="代码复杂度分析-2">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="3_metrics.png"></p><p>第三次作业的新增方法<code>pickPeople()</code>和<code>getSwitchFloor()</code>的复杂度也比较高，主要是因为本次作业横向电梯的可停靠楼座可以自定义，导致我们在请求队列中接人时，还需要特判电梯是否可以在该楼座开门，以及电梯能否在乘客的目的楼座开门。因此，方法复杂度高也不足为奇。<br>### 代码UML图</p><h4 id="类图-2">类图</h4><p><img src="3.jpg"></p><h4 id="时序图-2">时序图</h4><p><img src="3_seq.png"></p><h2 id="个人bug分析">个人bug分析</h2><p>前两次作业的强测和互测均没有发现问题，但是在第三次作业的强测中有一个测试点出现了<code>RTLE</code>（运行时间超时）。一开始百思不得其解，后来重读了一遍代码才发现原来是<code>Controller</code>类中<code>setEndTag()</code>方法中少给了一个请求队列加锁，使得程序无法正确地将请求队列中的<code>endTag</code>置为真，最终导致线程无法正常关闭。</p><h2 id="关于测试">关于测试</h2><p>在这一单元我仍然采用<strong>自动化测试</strong>来寻找代码bug，测试程序分为两部分——</p><ul><li><strong>数据生成器</strong></li><li><strong>输出检查器</strong></li></ul><h3 id="数据生成器">数据生成器</h3><p>数据生成是用<strong>随机数</strong>的方式来实现的。为了让数据生成器也有很好的<strong>可扩展性</strong>，我将某些功能封装成了函数，便于在做后面的作业时对数据生成器进行修改和迭代。此外，在设计数据生成器时还需要注意指导书上提到的一些“数据规范”——</p><ul><li>电梯系统的指令数：1~70条</li><li>不能向没有电梯的楼层或者楼座发起请求</li><li>第一条指令的投喂时间在 1s 或 1s 以后</li><li>每个楼层（座）的电梯不能超过3个</li><li>电梯总数不能超过15个</li><li>电梯速度只能是{0.2, 0.4, 0.6}中的一个，电梯容量只能是{4, 6,8}中的一个</li><li>...</li></ul><p>整个数据生成器的架构如下所示<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">MAX_FLOOR <span class="token operator">=</span> <span class="token number">10</span> MAX_TIME <span class="token operator">=</span> <span class="token number">50</span>MAX_REQ_NUM <span class="token operator">=</span> <span class="token number">50</span>MAX_E_NUM <span class="token operator">=</span> <span class="token number">15</span>MAX_E_NUM_PER_BUILDING <span class="token operator">=</span> <span class="token number">3</span>MAX_E_NUM_PER_FLOOR <span class="token operator">=</span> <span class="token number">3</span>SINGLE <span class="token operator">=</span> <span class="token boolean">True</span>MULTIPLE <span class="token operator">=</span> <span class="token boolean">False</span>MAX_INT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>  <span class="token operator">-</span> <span class="token number">1</span><span class="token comment">#sets of people and elevator  </span>p_id_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>e_id_set <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token comment">#number of elevators per building or per floor</span>building_acess_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>floor_acess_map <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> MAX_FLOOR <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>floor_acess_map<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># tags of building and floor</span>building_tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span>floor_tags <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> MAX_FLOOR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>speed_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">]</span>capacity_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token comment">#initial data</span>time <span class="token operator">=</span> <span class="token number">1.0</span>e_num <span class="token operator">=</span> <span class="token number">5</span>req_num <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># Functions for get relative information </span><span class="token keyword">def</span> <span class="token function">get_p_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_e_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_time_gap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_building</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_floor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_switch_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">get_speed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token comment"># Functions for checking </span><span class="token keyword">def</span> <span class="token function">check_floor_can_add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">check_building_can_add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment"># Functions for generating person requests or elevator requests</span><span class="token keyword">def</span> <span class="token function">gener_p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">gener_e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">gener_virtical_e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">gener_lateral_e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment"># main</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> MAX_REQ_NUM<span class="token punctuation">)</span>    <span class="token keyword">global</span> time<span class="token punctuation">,</span> e_num<span class="token punctuation">,</span> req_num    time <span class="token operator">=</span> <span class="token number">1.0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>req_num <span class="token operator">&lt;</span> num <span class="token keyword">and</span> time <span class="token operator">&lt;</span> MAX_TIME<span class="token punctuation">)</span><span class="token punctuation">:</span>        choice <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">or</span> choice <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> e_num <span class="token operator">&gt;=</span> MAX_E_NUM<span class="token punctuation">)</span> <span class="token punctuation">:</span>            gener_p<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span> <span class="token punctuation">:</span>            gener_e<span class="token punctuation">(</span><span class="token punctuation">)</span>            e_num <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>生成的请求不能任其随机分布，还需要对某楼层或者某楼座进行压力测试，即只针对一楼层（座）生成大量请求。另外，我们可能还需要仅对横向电梯测试或者仅对纵向电梯测试。为了满足多样性的需求，我还为数据生成器增加了许多“模式”可以选择。</p><p>例如在第二次作业的数据生成器中，我专门设计了<code>dst_mode</code>和<code>run_mode</code>两个全局变量用来表示数据生成的模式，前者可取<code>LATERAL</code>、<code>VERICAL</code>、<code>CROSSING</code>三个值，后者可取<code>SINGLE</code>和<code>MULIPLE</code>两个值，两个变量进行组合就有6种不同的模式。<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">'''Copyright (C) 2022 BUAAAuthor: Hyggge, &lt;czh20020503@buaa.edu.com&gt;You can use this program to generate test data, which can be used in Unit 6 of BUAA-OO.Before run it, you should choose a operatatin mode based on your need. To change the mode, you need modify the values of "dst_mode" and "run_mode". The introduction is shown below.############################## Mode Introduction #################################____________________________________________________________________________________| dst_mode | run_mode |                       Introduction                         || -------- | -------- | -----------------------------------------------------------||  SINGLE  | VERTICAL | Only "certain-building" has vertical elevators             ||  SINGLE  | LATERAL  | Only "certain-floor" has lateral elevators                 ||  SINGLE  | CROSSING | Only "certain-building" and "certain-floor" have elevators || MULTIPLE | VERTICAL | Every building can have vertical elevators                 || MULTIPLE | LATERAL  | Every floor can have lateral elevators                     || MULTIPLE | CROSSING | Every building and every floor can have elevators          |------------------------------------------------------------------------------------'''</span><span class="token comment"># const defination</span>LATERAL <span class="token operator">=</span> <span class="token number">1</span>VERTICAL <span class="token operator">=</span> <span class="token number">2</span>CROSSING <span class="token operator">=</span> <span class="token number">3</span>SINGLE <span class="token operator">=</span> <span class="token number">1</span>MULTIPLE <span class="token operator">=</span> <span class="token number">2</span><span class="token comment"># variable for mode selection</span>dst_mode <span class="token operator">=</span> SINGLErun_mode <span class="token operator">=</span> LATERALcertain_building <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>building_tags<span class="token punctuation">)</span>certain_floor <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>floor_tags<span class="token punctuation">)</span><span class="token comment">#...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="输出检查器">输出检查器</h3><p>在这一部分，我们需要对作业代码的运行结果进行检查。需要检查的内容包括——</p><ul><li><strong>输出格式是否正确</strong></li><li><strong>电梯是否已经超载</strong></li><li><strong>电梯运行速度和开关门速度是否满足要求</strong></li><li><strong>电梯开关门是否符合常理</strong>（电梯不能先关后开，不能在电梯关门后再让乘客进出）</li><li><strong>电梯到达的楼层或者楼座是否真实存在</strong>（电梯不能跑到-18楼...）</li><li><strong>电梯在某楼做是否可以停靠</strong>（主要针对横向电梯，需要结合输入数据进行判断）</li><li><strong>所有乘客的请求是否全部满足</strong>（检查是否出现“电梯吃人”或者“请求饿死”的现象，需要结合输入数据进行判断）</li><li><strong>从电梯里出来的乘客是否真实存在</strong>（细思极恐...）</li></ul><h2 id="心得体会">心得体会</h2><ul><li><strong>写代码时注意遵循"SOLID"原则</strong>，这会使我们省去不少debug的麻烦。</li><li><strong>多多关注讨论区</strong>。在本单元的讨论区中我学到了不少新知识，比如<strong>CPU时间查看、泛型的使用、监视器底层原理</strong>等等。</li><li><strong>加锁要慎重</strong>。我们需要对共享对象做同步处理，但并不意味之要将所有的方法都加上锁，这样会极大影响并行效率。此外，要注意尽量不要在方法上加锁，而是优先使用<code>synchronize</code>同步块，减少同步区域，提高性能。</li><li><strong>架构设计时应注意层次化</strong>。先根据需要实现的功能把工程划分成几个不同的功能模块，并规定好不同模块之间的接口，然后再自上而下依次实现。这样不仅有利于降低整个工程的复杂度，还有利于后期的迭代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec7:C++类模版和STL简介</title>
      <link href="/2022/04/18/c/cpp-programing-lec-7/"/>
      <url>/2022/04/18/c/cpp-programing-lec-7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="class-template">Class Template</h2><p>首先我们可以用类来实现一个<code>int</code>型数据的栈，代码如下<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pool<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-&gt;</span>pool<span class="token punctuation">[</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>pool<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此时，如果我们想要实现一个储存<code>double</code>类型的栈怎么办呢？<p></p><p>当然，我们可以使用程序员传统艺能——“ctrl C + ctrlV”，这在栈的类型较少时是比较适用的，顶多就是代码多了一些；但是如果需要的栈的类型比较多（比如我们需要一个存储“苹果”类对象的栈），这种方法显然是不行的。</p><p>类模板可以帮助我们解决这个问题。<strong>所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。</strong>在该类创建对象的时候，我们需要指定一个确定的类型，然后编译器就会用<strong>我们指定的类型</strong>来代替前面<strong>定义类模板时适用的虚拟类型</strong>。模板类的定义方法为——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>在用类模板来创建对象时，需要用<code>&lt;&gt;</code>指定一下具体类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ClassName<span class="token operator">&lt;</span>type_name<span class="token operator">&gt;</span> obj_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>下面我们使用类模板来重新定义一下<code>Stack</code>类，并使用这个类模板分别创建<code>int</code>类型和<code>double</code>类型的<code>Stack</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    T pool<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    T top<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-&gt;</span>pool<span class="token punctuation">[</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>pool<span class="token punctuation">[</span><span class="token operator">--</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> intStack<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> intStack<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="stl">STL</h2><p>像上面<code>Stack</code>这种数据结构（或者称为容器），我们在编程时会大量使用。但是，如果每次使用都定义一次<code>Stack</code>，显然是非常费力的，而且这种重复造轮子的工作也没有什么意义。</p><p>这让我们不禁会想——如果C++能够为我们提供一个写好<code>Stack</code>模板就好了</p><p>幸运的是，C++摸透了我们的小心思，提供了STL（标准模板库）供我们使用。STL中有大量的动态增长的万能容器，像<code>list</code>、<code>vector</code>、<code>queue</code>、<code>stack</code>等等，同时还为我们提供了容器操作（增删改查）的相关操作。</p><h3 id="listvector">list&amp;vector</h3><p>我们先简单介绍一下两个常用的容器——<code>list</code>和<code>vector</code>，这两种容器都是线性存储容器，其定义和操作也很相似<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//insert element</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//insert element</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们需要关注的是这两者的底层实现原理——<p></p><ul><li><code>vector</code>类似于我们在c语言中使用的数组，强于随机访问，弱于增删改</li><li><code>list</code>类似于我们学过的链表，强于增删改，弱于随机访问</li></ul><p>问题来了，前面提到STL中的容器大多都是可以动态增长的，那么<code>vector</code>和<code>list</code>是如何实现动态增长的呢？</p><ul><li><p><code>list</code>比较好理解，毕竟是链表嘛，当需要插入一个新的数据时，直接申请一个新的空间来容纳新的链表项就行。</p></li><li><p>而<code>vector</code>实现方式是，在<code>vector</code>创建时先在内存空间中开辟了一大块连续的空间用来存储，当发现这一块连续的空间不够用了，他会在内存中找到一个更大的连续的空间，然后将之前的数据全部都复制到新的内存空间，从而实现动态增长。</p></li></ul><p>为了证明这一点，我们可以做一个小的实验，我们先定义一个<code>vector&lt;int&gt;</code>类型的对象<code>a</code>，然后<code>a</code>中插入10000个数字，每次插入后看一下<code>a[0]</code>的地址又没有改变，如果改变了则证明我刚才的解释是正确的。实验代码如下<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> last_addr <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> last_addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            last_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>实验结果为——<br><pre class="line-numbers language-none"><code class="language-none">0x6c25200x6c25400x6c25200x6c25400x6c38a00x6c38f00x6c39800x6c3a900x6a63000x6a67100x6a6f200x6a7f300x6a9f400x6c38a00x6cb8b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="iterator">Iterator</h3><p>如果想要访问<code>vector</code>中的某一个数据，直接可以使用下标<code>a[i]</code>访问；但是，如果想要访问<code>list</code>中的一个元素呢？我们需要先翻一下STL手册，查一下有没有和访问相关的函数。同样，对于不同的容器，同一访问操作（增、删、改、查）可能会有不同的函数定义。如果要把所有容器的相关函数都记住，显然是不可能的，查STL手册同样也费事费力。</p><p><strong>所以，那么多STL容器就没有一个统一的访问方法么???</strong></p><p>答案当然是<strong>有的</strong>，那就是使用<strong>迭代器</strong>。迭代器实际上是每个STL容器中都定义的一个数据类型，通过这个数据类型我们可以访问容器中所有的元素。此外，基本每个STL容器中也都提供了<code>begin()</code>和<code>end()</code>函数，这两个函数分别返回容器开头和末尾的迭代器，这样我们就可以很容易的遍历容器中的元素了——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以发现迭代器的操作和指针是非常像的，这是因为，STL的开发者对迭代器进行了<strong>运算符重载</strong>，从而方便用户使用迭代器。<p></p><p>实际上，迭代器有不同的类型，包括<strong>输入迭代器</strong>、<strong>输出迭代器</strong>、<strong>正向迭代器</strong>、<strong>双向迭代器</strong>和<strong>随机访问迭代器</strong>，而且不同类型的迭代器操作方法也不完全相同。关于迭代器的类型和相关操作，可以参考这篇<a href="https://blog.csdn.net/qq_23100787/article/details/51388163">博客</a>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab2：内存管理</title>
      <link href="/2022/04/18/os/os-lab2-shi-yan-bao-gao/"/>
      <url>/2022/04/18/os/os-lab2-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lab2-实验报告">Lab2 实验报告</h1><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-2.1">Thinking 2.1</h3><p><strong>Q：</strong> <strong>在我们编写的 C程序中，指针变量中存储的地址是虚拟地址还是物理地址？ MIPS 汇编程序中 lw,sw 使用的是虚拟地址还是物理地址？</strong><br><strong>A：</strong>因为CPU只会发出虚拟地址，因此指针变量中储存的是虚拟地址。MIPS汇编程序中lw、sw中使用的也是虚拟地址。</p><h3 id="thinking-2.2">Thinking 2.2</h3><p><strong>Q1：</strong><strong>请从可重用性的角度，阐述用宏来实现链表的好处。</strong></p><p><strong>A1：</strong>使用宏定义对链表操作进行封装，可以实现代码的复用，既减少了工作量，也提高了程序的可读性</p><p><strong>Q2：</strong> <strong>请你查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异</strong></p><p><strong>A2：</strong> 三者的操作性能有以下差异——</p><ul><li><strong>对于单向链表</strong>，由于它只能获得每一项的后面一项，因此在删除时需要遍历整个链表；同样，如果是在某一项的前面插入，也需要从<code>head</code>开始遍历这个链表。但是如果是“在某一项之后插入”，单项链表可以直接进行该操作。</li><li><strong>对于循环链表</strong>，因为它仍然是单向的，所以在“删除”、“某一项之前插入”、“某一项之后插入”三个操作的性能和单项链表相同。但是，由于循环链表首尾相连，同时维护了一个指向尾项的指针，因此它可以直接在尾部插入。</li><li><strong>对于双向链表</strong>，因为它可以直接获得某一项的前后两项，所以无论是“删除”还是“在某一项前或后插入”都可以以O(1)的开销实现。但是，双向链表没有维护指向尾部的指针，因此无法直接将某一项插入链表尾部，如要实现该操作还需要遍历整个链表。</li></ul><h3 id="thinking-2.3">Thinking 2.3</h3><p><strong>Q：</strong><strong>选择<code>Page_list</code>正确的展开结构。</strong><br><strong>A：</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prec<span class="token punctuation">;</span>        <span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>        u_short pp_ref<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="thinking-2.4">Thinking 2.4</h3><p><strong>Q：</strong> <strong>请你寻找上述两个<code>boot_*</code>函数在何处被调用</strong><br><strong>A：</strong><code>boot_pgdir_walk()</code>在<code>boot_map_segment()</code>函数中被调用，用于在建立映射时根据<strong>虚拟地址</strong>寻找二级页表项。<code>boot_map_segment()</code>在<code>mips_vm_init()</code>中调用，用于将<code>kuseg</code>中的<code>UPAGES</code>和<code>NENV</code>两个区域映射到物理地址空间。</p><h3 id="thinking-2.5">Thinking 2.5</h3><p><strong>Q1：</strong> <strong>请阅读上面有关 R3000-TLB的叙述，从虚拟内存的实现角度，阐述 <code>ASID</code>的必要性</strong><br><strong>A1：</strong>操作系统会给每一个进程分配一个页表，每个页表都有自己的虚拟地址空间，而同一虚拟地址在不同地址空间中通常映射到不同的物理地址。如果没有<code>ASID</code>来区分<strong>当前虚拟地址是在哪个进程中使用</strong>，则可能会将该虚拟地址映射到错误的物理地址。</p><p><strong>Q2：</strong> <strong>请阅读《IDT R30xx Family SoftwareReference Manual》的 Chapter6，结合<code>ASID</code>段的位数，说明<code>R3000</code>中可容纳不同的地址空间的最大数量</strong><br><strong>A2：</strong><code>ASID</code>在<code>HntryHi</code>寄存器中占6位，可以被设置为64个不同的值，因此<br><code>R3000</code>中可最多容纳<code>64</code>个不同的地址空间。</p><blockquote><p>"By setting up TLB entries with a particular ASID setting and withthe EntryLo G bit zero, those entries will only ever match a programaddress when the CPU’s ASID register is set the same. This allowssoftware to map up to <strong>64 different address spaces</strong>simultaneously, without requiring that the OS clear out the TLB on acontext change. " ——《<em>IDT R30xx Family Software ReferenceManual</em>》</p></blockquote><h3 id="thinking-2.6">Thinking 2.6</h3><p><strong>Q1：</strong> <strong><code>tlb_invalidate</code> 和<code>tlb_out</code> 的调用关系是怎样的？</strong><br><strong>A1：</strong><code>tlb_invalidata</code>函数中调用了<code>tlb_out</code>函数。</p><p><strong>Q2：</strong> <strong>请用一句话概括<code>tlb_invalidate</code> 的作用</strong><br><strong>A2：</strong> 在页表内容改变后及时更新<code>TLB</code>。</p><p><strong>Q3：</strong> <strong>逐行解释 <code>tlb_out</code>中的汇编代码</strong><br><strong>A3：</strong><code>tlb_out</code>作用实际上就是<strong>使得某一虚拟地址对应的tlb表项失效</strong>，基本思路是——<strong>先将要查找的虚拟地址存入<code>EntryHi</code>寄存器，然后调用<code>tlbp</code>指令在TLB中查找</strong>（此时Index寄存器中保存了找到的对应表项的索引）。如果没有找到（索引小于0），则直接跳到最后；<strong>如果找到了，将索引对应的tlb项清空</strong>（需要将<code>EntryHi</code>和<code>EntryLo</code>寄存器清零后使用<code>tlbwi</code>指令）。注意在函数最后需要将“调用该函数前<code>EntryHi</code>寄存器中的值恢复”</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LEAF(tlb_out)//1: j 1bnopmfc0k1,CP0_ENTRYHI      #将EntryHi寄存器的值存入k1寄存器mtc0a0,CP0_ENTRYHI      #将a0中的值存入EntryHi寄存器noptlbp                        #根据EntryHi在TLB中查找与之对应的表项，并把表项的索引存入Index寄存器nopnopnopnopmfc0k0,CP0_INDEX        #将Index寄存器的值存入k0寄存器    bltzk0,NOFOUND          #如果k0值小于零，即没有在TLB中找到EntryHi对应的表项，则跳转到NOFOUND标签处nopmtc0zero,CP0_ENTRYHI    #将EntryHi寄存器赋值为0mtc0zero,CP0_ENTRYLO0   #将EntryLo0寄存器赋值为0noptlbwi                       #将EntryHi和EntryLo0寄存器中的值存取Index对应的TLB表项中NOFOUND:mtc0k1,CP0_ENTRYHI      #将k1寄存器中的值存入EntryHi寄存器(恢复到调用该函数之前的状态)jra                  #函数返回nopEND(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="thinking-2.7">Thinking 2.7</h3><p><strong>Q：</strong><strong>在现代的<code>64</code>位系统中，提供了<code>64</code>位的字长，但实际上不是<code>64</code>位页式存储系统。假设在<code>64</code>位系统中采用三级页表机制，页面大小<code>4KB</code>。由于<code>64</code>位系统中字长为<code>8B</code>，且页目录也占用一页，因此页目录中有<code>512</code>个页目录项，因此每级页表都需要<code>9</code>位。因此在<code>64</code>位系统下，总共需要<code>3 × 9 + 12 = 39</code>位就可以实现三级页表机制，并不需要<code>64</code>位。现考虑上述<code>39</code>位的三级页式存储系统，虚拟地址空间为<code>512GB</code>，若记三级页表的基地址为<span class="math inline">\(PT_{base}\)</span>，请你计算：</strong></p><ul><li><strong>三级页表页目录的基地址?</strong></li><li><strong>映射到页目录自身的页目录项</strong></li></ul><p><strong>A：</strong> 三级页表页目录的基地址为<br><span class="math display">\[PT_{base} + PT_{base}&lt;&lt;9 +PT_{base}&lt;&lt;18\]</span><br>映射到页目录自身的页目录项<br><span class="math display">\[PT_{base} + PT_{base}&lt;&lt;9 +PT_{base}&lt;&lt;18 + PT_{base}&lt;&lt;27\]</span></p><h3 id="thinking-2.8">Thinking 2.8</h3><p><strong>Q：简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和MIPS 在内存管理上的区别</strong><br><strong>A：</strong> 两者有以下三点主要区别——</p><ul><li><p>首先是内存管理机制上，MIPS主要采用的是页式管理系统，X86主要采用的是段页式</p></li><li><p>其次，在对 TLB 不命中时的处理上，MIPS 会触发TLB Refill异常，内核的 <code>tlb_refill_handler</code> 会以<code>pgd_current</code> 为当前进程的 <code>PGD</code>基址，索引获得转换失败的虚址对应的<code>PTE</code>，并将其填入TLB，然后CPU再用刚刚转换失败的虚拟地址重新访问以下TLB。</p><p>而X86在TLB不命中时，是由硬件MMU以<code>CR3</code>为当前进程的PGD基址，索引获得PFN后，直接输出PA。同时MMU会填充TLB以加快下次转换的速度。</p><p>另外转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</p></li></ul><h2 id="实验难点图示">实验难点图示</h2><p>我认为该实验主要包含以下两个难点——<strong>Page存储结构和二级页表查询机制</strong></p><h3 id="page存储结构">Page存储结构</h3><p><code>Page</code>是我们用于管理物理内存块的结构体，该结构体包含两部分——一个是"数据域"（<code>pp_ref</code>）,另一个是"指针域"（<code>pp_link</code>）。<br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span><span class="token punctuation">{</span>u_short pp_ref<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prec<span class="token punctuation">;</span><span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>其中，<code>pp_ref</code>代表着该物理内存块被引用的次数，即有多少个虚拟地址映射到该物理内存块。<code>pp_link</code>中包含两个指针变量——<code>le_next</code>和<code>le_prec</code>，前者是<strong>指向后一个Page结构体的指针</strong>，后者是指向<strong>前一个Page的<code>le_next</code>的指针</strong>。<p></p><p>所以"前"、"后"是指什么意思呢？原来，我们为了便于对<strong>空闲物理内存块的管理</strong>，将<strong>所有空闲物理内存块对应的<code>Page</code>结构体</strong>用一个<strong>链表</strong>链接了起来，为了便于链表的增删改查，我们就需要上述<code>le_next</code>和<code>le_prec</code>发挥作用了。链表示意图如下所示<br><img src="lab2_1.png"></p><p>可以看到，上面的链表实际上是一个<strong>双向链表</strong>，但和我们常见的双向链表又有区别。该双向链表可以直接通过<code>le_next</code>来访问下一个链表项，但却无法直接访问上一个链表项。因为<code>le_prec</code>仅仅是指向了前一个Page的<code>le_next</code>，换句话说，就是一个<strong>指向了"指向自己的指针"的指针</strong>。虽然<code>le_prec</code>无法帮助我们直接访问上一个链表项，但是，它却可以帮助我们以<code>O(1)</code>的开销<strong>实现链表的增删操作</strong>。</p><p>此外，为了便于定位该链表的首项，我们还定义了一个结构体<code>page_free_list</code>用于存储<strong>指向链表首项的指针</strong><br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span><span class="token punctuation">}</span> page_free_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>因此，最终的链表结构为——<br><img src="lab2_2.png"><p></p><h3 id="二级页表查询机制">二级页表查询机制</h3><p>所谓二级页表机制，实际上就是<strong>将页表再进行分页</strong>，离散地将各个页表页面存放在不同的物理块中，同时也再建立一张"外部页表"用以记录页表页面对应的物理块号，这个"外部页表"实际上就是“页目录”，也是第一级页表。示意图如下所示——<br><img src="lab2_3.png"></p><blockquote><p>由于页目录自映射机制的存在，页目录实际上也是众多二级页表中的一个，并非是一个独立于外部的页表。</p></blockquote><p>我们将虚拟地址分成三部分——</p><ul><li><strong>31~22位是页目录中的表项号</strong>，我们可以根据该表项号从页目录中取出对应的页表项，该页表项中储存的是二级页表首地址。<br></li><li><strong>21~12位是二级页表中的表项号</strong>，我们可以根据该表项号从二级页表中取出对应的页表项，该页表项中储存的是<strong>虚拟地址所对应的物理页框的首地址</strong>。</li><li><strong>12~0位是页内偏移</strong>，通过将上面得到的<strong>物理页框的首地址</strong>和<strong>页内偏移</strong>相加，最终就可以得到虚拟地址对应的物理地址。</li></ul><p>二级页表的整个访存流程如下所示——<br><img src="lab2_4.png"></p><h2 id="体会与感想">体会与感想</h2><p>Lab2主要是实现MOS中的内存管理机制，包括物理内存管理、虚拟内存管理和TLB重填机制。和Lab1相比，本次Lab代码量剧增，而且链表操作部分<strong>使用了指向指针的指针</strong>，对代码的理解和补全也造成一定困难（有的时候甚至怀疑自己是不是真的学会了指针qwq）。虽然一路艰辛，但是做完整个Lab2之后，不仅让我巩固了理论课上学到的内存管理相关知识，还使我加深了对指针操作的理解，可以说是收获满满啦<span class="emoji" data-emoji="smile">😄</span></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「操作系统」进程调度</title>
      <link href="/2022/04/16/os/os-jin-cheng-diao-du/"/>
      <url>/2022/04/16/os/os-jin-cheng-diao-du/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>进程调度实际上就是在<strong>就绪进程队列</strong>中选择一个进程执行，关于进程的调度我们需要考虑三个问题——</p><ul><li><strong>调度的时机</strong>：何时进行进程调度</li><li><strong>调度的执行</strong>：调度时如何进行CPU上下文切换</li><li><strong>调度的策略</strong>：按照什么原则选择一个就绪进程进行调度</li></ul><h2 id="调度的时机">调度的时机</h2><p>当遇到下面几种情况时，可能会发生进程的调度——</p><ul><li><strong>当一个新的进程被创建时</strong></li><li><strong>当一个进程运行完毕时</strong></li><li><strong>当一个进程由于I/O、信号量或其他原因被阻塞时</strong></li><li><strong>当一个I/O中断发生时（表明某个I/O操作已经完成，而等待该I/O操作的进程转入就绪状态）</strong></li><li><strong>在分时系统中，当一个时钟中断发生时</strong></li><li><strong>当OS取得对CPU的控制时（例如用户系统调用、中断、陷阱）</strong></li></ul><h2 id="调度的执行">调度的执行</h2><p>在进程上下文切换时，会执行以下步骤——</p><ol type="1"><li><strong>保存处理器的上下文，包括程序计数器（PC）和其它寄存器；保存内存镜像（页表信息）</strong></li><li><strong>用新状态和其它相关信息更新正在运行进程的PCB</strong></li><li><strong>把进程移至合适的队列-就绪或阻塞</strong></li><li><strong>选择另一个要执行的进程，更新进程的PCB</strong></li><li><strong>从被选中进程中重装入CPU上下文和内存镜像</strong></li></ol><p>CPU调度按调度层次的不同可以划分为三级——</p><ul><li><strong>高级调度：</strong>作业层面，即从用户工作流程的角度，对用户提交到每个作业进行调度，时间上通常是分钟、小时或天</li><li><strong>中级调度：</strong>储存器资源层面，即将进程的部分或全部换出到外存上，将当前所需部分换入到内存</li><li><strong>低级调度：</strong>CPU资源层面，即对CPU计算资源（ALU等）进行分配，时间上通常是毫秒。</li></ul><h2 id="调度的策略">调度的策略</h2><h3 id="调度策略的度量指标">调度策略的度量指标</h3><p>衡量调度策略时通常采用以下几个常用的度量指标——</p><ul><li><strong>吞吐量：</strong> <span class="math inline">\(作业数/总执行时间\)</span></li><li><strong>周转时间：</strong> <span class="math inline">\(完成时间-提交时间\)</span></li><li><strong>带权周转时间：</strong> <span class="math inline">\(周转时间/服务时间（执行时间\)</span>）</li><li><strong>平均周转时间：</strong> <span class="math inline">\(一组作业周转时间之和/作业数\)</span></li><li><strong>平均带权周转时间：</strong> <span class="math inline">\(一组作业带权周转时间之和/作业数\)</span></li></ul><h3 id="调度策略的选择">调度策略的选择</h3><p>根据进程对CPU计算资源和I/O设备的使用情况，我们可以将进程分为两种——<strong>I/O密集型</strong>和<strong>CPU密集型</strong>。前者会频繁地进行I/O，通常会花费很多时间等待I/O操作完成，而计算时间相对I/O时间短；后者计算量大，进程会花费大量的时间在计算上。</p><p>对于不同特性的进程，我们通常会采用不同的调度算法。</p><p>根据<strong>”是否在时钟中断作出调度决策“</strong>，我们将进程的调度分为<strong>非抢占式和抢占式</strong>。</p><ul><li><strong>非抢占式：</strong>被调度进程会一直执行<strong>直到阻塞或主动放弃CPU</strong>，时钟中断时不会做调度决策</li><li><strong>抢占式：</strong>被调度程序运行一个固定的最大时间段（时间片），如果时间结束进程还在执行，挂起进程并进行切换（时钟中断时做调度决策）。</li></ul><p>对于不同的应用领域，我们会采用不同的调度策略，而这些策略也都离不开非抢占式和抢占式两种基本算法。常见的应用领域包括<strong>批处理系统、交互式系统、实时系统、多处理系统</strong>。<br><img src="进程调度.jpg"></p><h4 id="批处理系统"><strong>批处理系统</strong></h4><p>批处理是指用户将一批作业提交给操作系统后就不再干预。在批处理系统中，一个作业需要长时间的占用CPU，因此我们一般采用<strong>非抢占式算法或分配长时间周期的抢占算法</strong>。</p><p>在策略选择时，我们主要关注<strong>吞吐量和周转时间</strong>这两个指标。常用策略——</p><ul><li>先来先服务（FCFS：First Come First Serve)</li><li>最短作业优先（SJF：Shortest Job First)</li><li>最短剩余时间优先（SRTN：Shortest Remaining&nbsp;Time&nbsp;Next）</li><li>最高响应比优先（HRRN：Highest&nbsp;Response Ratio&nbsp;Next）</li></ul><h4 id="交互式系统"><strong>交互式系统</strong></h4><p>交互式计算机系统与操作人员以人机对话的方式一问一答，直至获得最后处理结果。这种系统服务于多个用户的环境，例如分时系统、手机系统，因此需要避免一个进程霸占CPU，一般使用<strong>抢占式算法</strong>。</p><p>在策略选择时，我们主要关注<strong>响应时间</strong>这个指标，并希望任务花费时间随着其复杂度应该线性增长。常用策略——</p><ul><li>时间片轮转(RR：Round Robin）</li><li>优先级调度(Priority Scheduling)</li><li>多级队列（MQ：Multi-level Queue）</li><li>多级反馈队列（MFQ：Multi-level&nbsp;Feedback Queue&nbsp;）</li><li>彩票调度（Lottery Scheduling）</li></ul><h4 id="实时系统"><strong>实时系统</strong></h4><p>实时系统是指计算的正确性不仅取决于程序的逻辑正确性，也取决于结果产生的时间。如果不满足确定性的截止时间需求，将会发生系统出错。因此我们<strong>主要采用抢占式算法，也可能非抢占式</strong>。</p><p>在策略选择时，我们主要关注<strong>"截止时间是否可以得到满足"</strong>，并希望策略有一定可预测性和规律性。常用策略——</p><ul><li>静态表调度（Static table-driven scheduling）</li><li>单调速率调度（RMS：Rate&nbsp;Monotonic Scheduling）</li><li>最早截止时间优先算法（EDF：Earliest Deadline&nbsp;First）</li></ul><h4 id="多处理系统"><strong>多处理系统</strong></h4><p>多处理系统指系统中有多个处理机同时进行工作，这种系统的调度更需要关注于系统整体的运行效率，调度单位广泛采用线程。</p><p>多处理系统有两种，包括<strong>非对称式多处理系统(AMP)</strong>和<strong>对称式多处理系统(SMP)</strong>。</p><ul><li><p>AMP中各个处理器的地位不同，有“主从”之分——由主处理机管理一个公共就绪队列，并分派进程给从处理机执行，每个处理机都有固定的分工（执行OS的系统功能？处理I/O？）</p></li><li><p>SMP中各个处理器的地位是相同的。根据控制的方式的不同，SMP调度算法可分为集中控制和分散控制，前者主要包括<strong>静态分配(staticassignment)</strong>和<strong>动态分配(dynamicassignment)</strong>，后者主要包括<strong>自调度（SelfScheduling）</strong>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec6:多态</title>
      <link href="/2022/04/12/c/cpp-progranming-lec-6/"/>
      <url>/2022/04/12/c/cpp-progranming-lec-6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++中的多态是继数据抽象(封装)和继承之后第三个重要的面向对象的特性，<strong>所谓多态是指用一个名字定义不同的函数，这些函数执行不同但又类似的操作，这样就可以用同一个函数名调用不同内容的函数</strong>。C++中多态主要依靠<strong>向上转型、动态绑定、虚函数</strong>等机制实现。</p><h2 id="向上转型upcasting">向上转型upcasting</h2><p>我们定义的类是一种数据类型，既然是数据类型，就可以发生数据类型的转换，但是这种转换仅限于在父类和子类之间。父类和子类之间的转换并不是双向的，而是只能从子类向父类进行转换，这种转换叫做<strong>“向上转型”</strong>。 向上转型有下面两种方式——</p><ul><li>用父类的引用类型来引用子类对象</li><li>用父类的指针类型来指向子类对象<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Father</span></span><span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//第一种转换</span>    Child a<span class="token punctuation">;</span>    Father<span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">//第二种转换</span>    Child <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Father <span class="token operator">*</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>向上转型由编译器自动完成，是十分安全的。向下转型也不是不可以，但是这样做会有风险，并且需要程序员根据需要手动强制转换。</p><p>向上转型后<strong>可以直接由父类的指针或引用来调用子类对象中的数据成员</strong>（只能是子类从父类中继承来的数据成员）,考虑下面的例子——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> father_id<span class="token punctuation">;</span>    <span class="token function">Father</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">father_id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Father</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> child_id<span class="token punctuation">;</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Father</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">child_id</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//Father(a)是调用父类有参构造，child_id(b)是初始化列表</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Father <span class="token operator">&amp;</span>f <span class="token operator">=</span> c<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span>father_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//输出1</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span>child_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//error！child_id不是子类从父类中继承来的数据成员！</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当某一个场景（如函数）需要传入父类的指针或者引用时，我们仍然可以传入子类对象的指针或引用，这样<strong>编译器会自动帮我们实现向上转型</strong>。如我们在上述程序中再定义一个<code>get_father_id(Father &amp;f)</code>函数，调用该函数时我们可以传入一个子类对象。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">get_father_id</span><span class="token punctuation">(</span>Father <span class="token operator">&amp;</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>father_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">get_father_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//输出仍然是1</span>    <span class="token comment">/*上述代码相当于\    Child c(1, 2);    Father&amp; f = c;    cout &lt;&lt; get_father_id(f) &lt;&lt; endl;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></blockquote><h2 id="动态绑定">动态绑定</h2><p><strong>父类的指针或引用类型能不能调用调用子类对象中的的函数</strong>呢（只能是子类从父类中继承来的函数）？答案当然是可以的，但是并不像调用数据成员那样简单。可以看下面的例子——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Pet</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pet::speak"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Pet</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dog::speak"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span>Pet<span class="token operator">&amp;</span> pet<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pet<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Dog dog<span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时输出就变成了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们希望的是调用<code>Dog</code>类中重写后的<code>speak()</code>函数，即希望输出<strong>"dog::speak"</strong>, 但最终输出的却是<strong>"pet::speak"</strong>。这是为什么呢？解答这个问题就需要涉及<strong>绑定</strong>的概念了——<p></p><p><strong>绑定（<code>binding</code>）是指将函数的一次调用与函数对应入口相对应的过程</strong>，绑定分为两种——</p><ul><li><strong>前绑定（<code>early binding</code>）</strong>，是指函数运行前就决定好了函数的运行的状态。我们遇到的大多数函数都是前绑定，例如上边的例子中<code>listen</code>函数中调用了<code>pet.speak()</code>，后者在运行前就决定好了要运行父类<code>Pet</code>中的<code>speak()</code>函数，因此即使传进来的是子类，仍然调用父类的函数。</li><li><strong>后绑定（<code>later binfing</code>）</strong>，也称为运行时绑定、动态绑定，是指函数调用是根据调用者（对象）的状态来决定函数的运行状况。</li></ul><p>所以我们如何将<code>speak()</code>函数设置为后绑定呢？只需要在父类的函数声明前加入<code>virtual</code>关键字即可。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Pet</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pet::speak"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//....</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Dog dog<span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>再次运行程序，输出结果就变成了 <strong>"dog::speak"</strong>！！！<p></p><h2 id="虚函数">虚函数</h2><p>上面<strong>用<code>virtual</code>声明的函数被称为虚函数</strong>。当某个虚函数通过指针或者引用被调用时，编译器产生的代码直到运行时才能确定该调用哪个版本的函数，这就是上面所说的<strong>运行时调用</strong>。虚函数的使用要注意以下几点——</p><ul><li>若父类中某函数被定义为虚函数，子类在继承该函数的同时，<strong>也继承了<code>virtual</code>关键字</strong>。</li><li>当子类的某函数重写了父类的一个虚函数，则它的<strong>形参类型</strong>必须与被它覆盖的父类函数完全一致</li><li><strong>构造函数一般不能被定义为虚函数</strong>，即不存在多态性。<strong>析构函数一般是多态的</strong>，多用<code>virtual</code>来修饰。此外，<strong>静态函数也不能是多态的</strong>。</li><li><code>laler binding</code>称运行时绑定，函数调用时跟据当前对象的状态决定函数的运行状况<br>使用<code>virtual</code>来限定父类中的函数，该关键词自动继承，<ul><li>虚指针<code>V-Ptr</code></li><li>虚列表<code>V-table</code><br>每个类都有一个<code>V-table</code>，并在每个对象的初始部分多出四个字节储存<code>V-Ptr</code>指向这个<code>V-table</code>，这样保证了upcasting行为的正确性。虚指针的初始化是在构造函数中默认完成的</li></ul></li></ul><blockquote><p><strong>补充：override和final的使用</strong><br>当子类对父类中的某<strong>虚函数</strong>进行重写是，我们可以在子类的对应函数后面写上override关键字，表示该函数是重写父类的。如果被override修饰的函数在父类中没有同名同参的函数，编译器会报错。使用该关键字可以让编译器帮助我们检查子类在重写父类函数时是否发生了错误，类似于JAVA中的@Override注解<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>父类中有某个函数，他只想让子类继承而不想让子类重写，这样我们可以在该函数后面加上final关键字。一旦子类重写了父类中被final修饰的函数，那么编译器就会报错。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">;</span><span class="token comment">//无法被子类修改</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//Base::speak(int a) {...};</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token comment">//error!!!</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//Derived::speak(int a) {...};</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></blockquote><h2 id="纯虚函数">纯虚函数</h2><p>在父类中有一种<strong>虚函数</strong>，在父类中没有必要将他定义，只有子类才能根据具体情况实现它，这种函数称为<strong>纯虚函数</strong>。纯虚函数的定义方式为——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>纯虚函数只能声明，不能定义。<strong>拥有纯虚函数的类被称为抽象类</strong>，而因为纯虚函数是不能被定义的，<strong>所以抽象类不能用来创建对象</strong>。如果父类是抽象类，则子类应该重写父类中的纯虚函数，<strong>不重写纯虚函数的子类仍然是抽象类</strong>。<p></p><p><strong>抽象类有以下两个作用：</strong></p><ul><li><strong>规定一个类家族所有的共性行为。</strong>这种抽象类既可以有纯虚函数，也可以有定义好的函数（包括虚函数和一般函数），相当于JAVA中的<strong>抽象类（<code>abstract class</code>）</strong>。</li><li><strong>链接本不相关的多个类家族。</strong>这种抽象类只能由纯虚函数组成，相当于JAVA中的<strong>接口（interface）</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Git」分支管理</title>
      <link href="/2022/04/11/git/git-fen-zhi-guan-li/"/>
      <url>/2022/04/11/git/git-fen-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分支基本操作">分支基本操作</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git branch</strong></td><td style="text-align: center;">查看本地分支</td></tr><tr class="even"><td style="text-align: center;"><strong>git branch -a</strong></td><td style="text-align: center;">可以查看本地和远程仓库的分支</td></tr><tr class="odd"><td style="text-align: center;"><strong>git branch -vv</strong></td><td style="text-align: center;">将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。一般需要先<code>git fetch --all</code>更新远程数据</td></tr><tr class="even"><td style="text-align: center;"><strong>git branch&lt;name&gt;</strong></td><td style="text-align: center;">创建分支</td></tr><tr class="odd"><td style="text-align: center;"><strong>git checkout&lt;name&gt;</strong><br><strong>git switch&lt;name&gt;</strong></td><td style="text-align: center;">切换到已有的分支</td></tr><tr class="even"><td style="text-align: center;"><strong>git checkout -b&lt;name&gt;</strong><br><strong>git switch -c&lt;name&gt;</strong></td><td style="text-align: center;">创建并切换分支</td></tr><tr class="odd"><td style="text-align: center;"><strong>git merge&lt;name&gt;</strong></td><td style="text-align: center;">将某个分支合并到当前的分支</td></tr><tr class="even"><td style="text-align: center;"><strong>git branch -d&lt;name&gt;</strong></td><td style="text-align: center;">删除分支</td></tr><tr class="odd"><td style="text-align: center;"><strong>git branch -D&lt;name&gt;</strong></td><td style="text-align: center;">强制删除分支（如果删除一个没有被合并的分支，只能用该指令而不能用-d）</td></tr><tr class="even"><td style="text-align: center;"><strong>git checkout -b &lt;本地分支名&gt;origin/&lt;远程分支名&gt;</strong></td><td style="text-align: center;">在本地创建一个和远程仓库origin中某分支相关联的分支（名字最好是一样的）</td></tr><tr class="odd"><td style="text-align: center;"><strong>git branch --set-upstream&lt;本地分支名&gt; origin/&lt;远程分支名&gt;</strong></td><td style="text-align: center;">将本地已经存在的某分支和远程库的某分支建立关联</td></tr></tbody></table><hr><h2 id="分支合并merge">分支合并——merge</h2><p>我们可以通过<code>git merge &lt;name&gt;</code>进行两个分支的合并，其效果是将名为<code>&lt;name&gt;</code>的分支里的内容合并到当前所在的分支上。当我们进行分支合并时，有的时候需要解决冲突，举下面三个例子——</p><ul><li><p><strong>Position 1</strong><br>如果我们在master分支上新建了一个dev分支，并在dev上修改了一个文件并提交，这样dev分支就比master分支提前一步，如下图所示<br><img src="2.png"><br>此时我们切换到<code>master</code>分支，并使用指令<code>git merge dev</code>，此时git就直接将master的指针移动到了dev上，如图<br><img src="1.png"><br>这种模式被称作<strong>快进模式</strong>（<code>Fast-forward</code>）,仅仅通过移动指针即可完成，不需要我们进行冲突合并。</p></li><li><p><strong>Position 2</strong><br>接上例，如果禁用<code>Faster-forward</code>模式会怎样?答：Git会自动在master上生成一个新的提交，该提交是两者合并后的结果，然后master指向该次提交，如下图所示<br><img src="3.png"><br>如何禁用<code>Faster-forward</code>模式呢？我们只需要在当前分支切换到<code>master</code>后，使用。因为这种合并方式需要在<code>master</code>上创建一个新的提交，所以需要输入提交描述信息。</p></li><li><p><strong>Position 3</strong><br>我们再换一个例子。假设<code>master</code>分支上有一个空文件<code>readme.txt</code>（已经提交到版本库）,然后我们在<code>master</code>分支上新建一个<code>dev</code>分支，这样两个分支都有空文件<code>readme.txt</code>了</p><ul><li>之后我们切换到在<code>dev</code>分支上，在<code>readme.txt</code>的第一行添加了一句<strong>“dev modify it!”</strong>, 保存之后commit到本地仓库。</li><li>然后我们在切换到<code>master</code>分支上，此时<code>readme.txt</code>还是一个空文件。我们在<code>readme.txt</code>的第一行添加了一句<strong>“master modify it!”</strong>, 保存之后也commit到本地仓库</li></ul><p>此时，<code>master</code>和<code>dev</code>两个分支是真的分道扬镳了！如下图所示——<br><img src="4.png"></p><p>这种情况下，如果在<code>master</code>分支中使用指令<code>git merge dev</code>，则可能产生冲突。因为我们在两个分支上同时对<code>readme.txt</code>加了一行，但是内容不同，Git并不知道该保存哪个。此时使用<code>merge</code>命令后，Git会提示我们<strong>“Automatic merge failed; fix conflicts and then commit theresult.”</strong>也就是说自动给合并失败了，需要我们手动结局冲突后再次提交。</p><p>我们打开<code>readme.txt</code>,会发现内容变成了<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster modify it！=======dev modify it！&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此时我们手动修改之后再<code>commit</code>即可。<p></p></li></ul><p>此外，如果在手动合并时出现了失误，我们可以通过<code>git merge --abort</code>回到合并前的状态。</p><hr><h2 id="分支变基rebase">分支变基——rebase</h2><h3 id="命令格式">命令格式</h3><p>变基命令的一般格式为——<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> rebase <span class="token operator">&lt;</span>basebranch<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>topicbranch<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>其中<code>basebranch</code>是作为新基底的分支，<code>topicbranch</code>是待变基的分支。当然，如果你想让当前所在的分支作为<code>topicbranch</code>，可以直接使用<code>git rebase &lt;basebranch&gt;</code>。<p></p><h3 id="用法解释">用法解释</h3><p><code>git rebase</code>的官方解释是——"<strong>当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。</strong>"我们用下面的例子来分析</p><p><img src="合并前.jpg"></p><p>此时<code>master</code>指向的是<code>C4</code>，<code>dev</code>指向的是<code>C6</code>，它们的公共祖先是<code>C2</code>。此时我们在<code>dev</code>分支上调用命令<code>git rebase master</code>，Git就会比较<code>C5</code>、<code>C6</code>和<code>C2</code>之间的区别，然后将<code>C5</code>、<code>C6</code>较<code>C2</code>的修改应用在<code>C4</code>上（即<code>C4</code>作为新的基底），形成新的提交<code>C5'</code>和<code>C6'</code>，最后再将原先的<code>C5</code>和<code>C6</code>删掉。其效果相当于将<code>dev</code>上的两个提交记录（<code>C5</code>和<code>C6</code>）拿下来，安到master的最新提交（<code>C4</code>）上。</p><p>操作结果如下图所示——</p><p><img src="变基后.jpg"></p><p>可以发现，变基实际上就是更改历史，使得提交历史成为一条直线而没有分叉。这样做的好处是能够保持提交历史的整洁性，但是缺点也很明显——丢弃了一些提交记录，如果你的同伴是基于这些记录进行开发，那就会使事情变得很麻烦。</p><p>因此，如果正在和同伴协作开发，应该尽量避免使用<code>rebase</code>。如果真出现了"<strong>有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</strong>",我们可以通过两种方法解决（具体可参见《<em>ProGit</em>》的相关章节）<br>-<strong>第一种</strong>：先使用<code>get fetch --all</code>获取同伴使用变基后的提交记录，然后使用<code>get rebase origin/master</code>（也就是用变基解决变基）。<br>-<strong>第二种</strong>：在下拉时使用<code>git pull --rebase</code>，而不是使用<code>git pull</code>。</p><hr><h2 id="分支拣选cherry-pick">分支拣选——cherry-pick</h2><p>Git 中的拣选类似于对特定的某次提交的变基。它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。这种方式在你只想引入<strong>某个分支中的某个提交</strong>，或者<strong>某个分支中只有一个提交，而你不想运行变基</strong>时很有用。假设你的项目提交历史如下图所示——</p><p><img src="拣选前.jpg"></p><p>此时如果想要将提交<code>e43a6</code>拉去到<code>master</code>分支，我们可以先切换到<code>master</code>分支，然后使用命令<code>git cherry-pick e43a6</code>。这样一来，<code>master</code>分支会新增一个提交，结果如下——</p><p><img src="拣选后.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Git」远程仓库</title>
      <link href="/2022/04/11/git/git-yuan-cheng-cang-ku/"/>
      <url>/2022/04/11/git/git-yuan-cheng-cang-ku/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="远程仓库操作">远程仓库操作</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git remote add origin&lt;ssh&gt;</strong></td><td style="text-align: center;">将远程仓库关联到本地版本库,并将<code>origin</code>作为远程库的名字</td></tr><tr class="even"><td style="text-align: center;"><strong>git clone&lt;ssh&gt;</strong></td><td style="text-align: center;">直接将远程仓库克隆到本地</td></tr><tr class="odd"><td style="text-align: center;"><strong>git remote rmorigin</strong></td><td style="text-align: center;">删除<code>origin</code>代表的远程库（只是解除了关联，并不是真正的删除远程库），可以提前使用<code>git remote -v</code>来查看远程库的信息</td></tr><tr class="even"><td style="text-align: center;"><strong>git remote rename &lt;name1&gt;&lt;name2&gt;</strong></td><td style="text-align: center;">远程仓库重命名</td></tr></tbody></table><h2 id="push命令">push命令</h2><p><code>git push</code>时使用本地分支来更新远程分支，基本形式是——<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push <span class="token operator">&lt;</span>远程仓库名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>本地分支名</strong>为要被推送的分支，<strong>远程分支名</strong>是远程仓库中要被更新的分支。该指令有以下几种使用方法——<p></p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git push originmaster:master</strong></td><td style="text-align: center;">使用完整性形式，表示用本地master分支来更新远程仓库origin的master分支</td></tr><tr class="even"><td style="text-align: center;"><strong>git push originmaster</strong></td><td style="text-align: center;">省略了远程分支名，表示将本地master本支推送到origin的master分支，如果后者不存在，则会被新建</td></tr><tr class="odd"><td style="text-align: center;"><strong>git push -u originmaster</strong></td><td style="text-align: center;">作用同<code>git push origin master</code>，同时指定origin为默认远程仓库，以后就可以直接使用<code>git push</code>而不用带其他参数了</td></tr><tr class="even"><td style="text-align: center;"><strong>git push origin:master</strong></td><td style="text-align: center;">省略了本地分支名，表示用空分支来跟新origin的master分支，其实是删除了远程origin的master分支。该指令相当于<code>git push origin --delete master</code></td></tr><tr class="odd"><td style="text-align: center;"><strong>git push origin</strong></td><td style="text-align: center;">省略了远程分支名和本地分支名，只有在当前分支（HEAD指向的分支）和远程仓库中某分支存在追踪关系的时候才可以使用（一般是分支名相同）</td></tr><tr class="even"><td style="text-align: center;"><strong>git push</strong></td><td style="text-align: center;">不带任何参数，默认只推送当前分支到默认远程仓库</td></tr><tr class="odd"><td style="text-align: center;"><strong>git push --allorigin</strong></td><td style="text-align: center;">将所有的本地分支都推送到origin远程仓库</td></tr><tr class="even"><td style="text-align: center;"><strong>git push --forceorigin</strong></td><td style="text-align: center;">如果远程仓库的版本比本地新，git会报错，如果一定要推送，则可以使用该指令强制推送</td></tr></tbody></table><h2 id="pull命令">pull命令</h2><p><code>git pull</code>表示将远程仓库中某分支下拉并合并到本地某分支，指令基本形式是——<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push <span class="token operator">&lt;</span>远程仓库名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>该指令有以下几种使用方法——<p></p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git pull originmaster:master</strong></td><td style="text-align: center;">使用完整性形式，表示将远程仓库origin的master分支下拉并合并到本地master分支上</td></tr><tr class="even"><td style="text-align: center;"><strong>git pull originmaster</strong></td><td style="text-align: center;">省略了远程分支名，表示将远程仓库origin的master分支下拉并合并到当前分支上（HEAD指向的分支）</td></tr></tbody></table><h2 id="常见问题及解决方式">常见问题及解决方式</h2><p><strong>情景1：</strong>假设你刚刚在<code>master</code>分支上干完一部分工作，commit到本地仓库后正准备上传到远程仓库，结果使用<code>push</code>是竟然报错了。原因是和你在同一分支上工作的大兄弟早早的干完活push上去了，而他的最新提交和你的提交是有冲突的。<br><strong>解决方法：</strong>先<code>git pull origin master:master</code>把最新的<code>origin/master</code>下并合并到本地<code>master</code>，当然此时会提示“合并有冲突”。我们手动解决冲突后再次commit，这时push就没有什么问题了。</p><p><strong>情景2：</strong>假设你对<code>master</code>进行了版本回退，在该回退版本上修改了一些问题后想要上传到远程分支，结果发现直接push也有问题。此时不可以先pull在push，因为pull之后代码就和远程仓库一样了。<br><strong>解决方法：</strong>我们可以先使用<code>git branch a</code>新建一个分支a，然后回到版本回退前的最新一次commit，使用<code>git merge a</code>即可将该修改合并到最新的分支。</p><p><strong>情景3：</strong>假设你正在<code>master</code>分支上工作，并已经对<code>master</code>分支上的内容进行了修改。此时你的同事已经将他的修改上传到远程仓库里，而你想将他的修改和你的修改合并在一起，如果此时直接pull也会出现错误。<br><strong>解决方法：</strong>先用<code>git stash</code>将本地的修改暂存，然后<code>git pull</code>拉取同事修改后的版本，最后<code>git stash pop</code>将自己的修改恢复。此时可能会有冲突，需要手动进行解决。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Git」撤销、删除与版本回退</title>
      <link href="/2022/04/11/git/git-che-xiao-yu-ban-ben-hui-tui/"/>
      <url>/2022/04/11/git/git-che-xiao-yu-ban-ben-hui-tui/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="查看修改">查看修改</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git diff&lt;file&gt;</strong></td><td style="text-align: center;">查看工作区中某文件的修改。</td></tr><tr class="even"><td style="text-align: center;"><strong>git diff --cached&lt;file&gt;</strong> 或<br> <strong>git diff staged&lt;file&gt;</strong></td><td style="text-align: center;">显示暂存区(已add但未commit文件)和最后一次commit(HEAD)之间的所有不相同文件的增删改</td></tr><tr class="odd"><td style="text-align: center;"><strong>git diff HEAD --&lt;file&gt;</strong></td><td style="text-align: center;">查看工作区文件（没有add到暂存区）和版本库最后一次commit之间的区别</td></tr><tr class="even"><td style="text-align: center;"><strong>git diff HEAD~X --&lt;file&gt;</strong></td><td style="text-align: center;">查看最近一次提交的版本与往过去时间线前数<code>X</code>个的版本之间的差别</td></tr><tr class="odd"><td style="text-align: center;"><strong>git diff &lt;branch1&gt;&lt;branch2&gt;</strong></td><td style="text-align: center;">比较两个分支最后一次commit的内容的差别</td></tr></tbody></table><ul><li>对<code>git diff &lt;file&gt;</code>指令：当工作区有改动、暂存区为空时，比较的是工作区和最后一次commit提交；当工作区有改动、暂存区不为空时，比较的是工作区和暂存区。</li></ul><h2 id="重命名指令">重命名指令</h2><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git mv &lt;name1&gt;&lt;name2&gt;</strong></td><td style="text-align: center;">将名为<code>name1</code>的文件重命名为<code>name2</code></td></tr></tbody></table><ul><li>使用<code>git mv</code>指令后，工作区和暂存区的文件名都被修改。以<code>git mv file1.txt file2.txt</code>为例，它其实相当于三条指令——<code>mv file1.txt file2.txt</code>、<code>git rm file1.txt</code>、<code>git add file2.txt</code></li></ul><h2 id="撤销指令">撤销指令</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git checkout --&lt;file&gt;</strong></td><td style="text-align: center;">将工作区中该文件的修改撤销，该文件此时应没有提交到暂存区</td></tr><tr class="even"><td style="text-align: center;"><strong>git checkout HEAD --&lt;file&gt;</strong></td><td style="text-align: center;">将工作区、暂存区和HEAD的提交保持一致</td></tr><tr class="odd"><td style="text-align: center;"><strong>git reset HEAD&lt;file&gt;</strong></td><td style="text-align: center;">将暂存区和HEAD的提交保持一致（达到取消暂存的效果）</td></tr><tr class="even"><td style="text-align: center;"><strong>git reset --hardHEAD</strong></td><td style="text-align: center;">将工作区、暂存区和HEAD的提交保持一致</td></tr><tr class="odd"><td style="text-align: center;"><strong>git commit --amend</strong></td><td style="text-align: center;">如果提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了，可以用该命令来重新提交将暂存区中的文件提交，并覆盖上一次提交信息。</td></tr></tbody></table><ul><li>需要注意的是<code>git checkout -- &lt;file&gt;</code>指令应该是从<strong>先从缓存区中拉取版本还原</strong>，如果没有<strong>再到版本库中拉取还原</strong>。用廖神的话来说就是——"<strong>总之，将这个文件回到最近一次<code>git commit</code>或者<code>git add</code>时的状态</strong>"</li><li><code>git checkout HEAD -- &lt;file&gt;</code>和<code>git reset --hard HEAD &lt;file&gt;</code>作用相似，都是可以使"工作区、暂存区和HEAD的提交保持一致"。但是两者并不完全一样：<ul><li>首先，<code>git checkout HEAD -- &lt;file&gt;</code>可以指定文件，但是<code>git reset -- hard HEAD</code>指令会作用于所有的文件。</li><li>其次，如果使用<code>git checkout HEAD -- .</code>时，不会对没有commit的新增文件起作用；但如果我们使用的是<code>git reset --head HEAD</code>，因为新增文件没有commit，即在版本库中找不到，所以执行该命令后未commmit新文件会消失（相比<code>git checkouit HEAD -- .</code>更加彻底）。具体示例可参考这篇<a href="https://stackoverflow.com/questions/59339986/is-there-a-difference-between-git-checkout-head-and-git-reset-hard-head">博客</a>。</li></ul></li></ul><h2 id="删除指令">删除指令</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git rm&lt;file&gt;</strong></td><td style="text-align: center;">工作区和暂存区的该文件都会被删除。<br>再使用<code>git commit</code>就可以将该文件从版本库中删除</td></tr><tr class="even"><td style="text-align: center;"><strong>git rm --cached&lt;file&gt;</strong></td><td style="text-align: center;">从暂存区删去该文件，而工作区不删除。<br>此时使用<code>git commit</code>可以将该文件从版本库中删除，但工作区不会被删</td></tr><tr class="odd"><td style="text-align: center;"><strong>git clean &lt;file&gt;-f</strong></td><td style="text-align: center;">删除工作区中没有被追踪的文件</td></tr></tbody></table><h2 id="版本回退">版本回退</h2><p>在版本回退操作之前，我们可以通过<code>git log</code>指令来查看提交历史记录，进而确定自己想要回退的版本。（加入<code>--pretty=oneline</code>参数后可以让输出信息更加简洁。）确定了想回退的版本后，可以使用下面三个指令中的一个进行回滚——</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>git reset --hardHEAD^</strong></td><td style="text-align: center;">回退到上一个版本，<code>^</code>的个数表示回滚的次数</td></tr><tr class="even"><td style="text-align: center;"><strong>git reset --hardHEAD~100</strong></td><td style="text-align: center;">回滚100次，<code>~</code>后的数字表示回滚的次数</td></tr><tr class="odd"><td style="text-align: center;"><strong>git reset --hard&lt;hashcode&gt;</strong></td><td style="text-align: center;">回滚到<code>&lt;hashcode&gt;</code>表示的版本</td></tr></tbody></table><p>如果想要重返未来，则需要先使用<code>git reflog</code>来查看历次<code>commit</code>和<code>reset</code>的记录，找到对应版本的<code>hashcode</code>，再使用<code>git reset --hard [hashcode]</code>进行重返。</p><blockquote><p>执行回退指令之后，不仅HEAD指针发生了变化，而且工作区和暂存区也都和指定版本保持一致，类似于<code>git reset --hard HEAD &lt;file&gt;</code>指令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Letax」Letax Mathematical Symbols</title>
      <link href="/2022/04/10/letax/letax-shu-xue-fu-hao/"/>
      <url>/2022/04/10/letax/letax-shu-xue-fu-hao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>源文档<a href="https://www.caam.rice.edu/~heinken/latex/symbols.pdf">下载链接</a></li><li><a href="https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols">表格版符号大全</a></li></ul><hr><p><img src="1.png"><br><img src="2.png"><br><img src="3.png"><br><img src="4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Letax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Letax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab1：内核、Boot和Print</title>
      <link href="/2022/04/03/os/os-lab1-shi-yan-bao-gao/"/>
      <url>/2022/04/03/os/os-lab1-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-1.1">Thinking 1.1</h3><p><strong>Q：</strong> 请查阅并给出前述 <code>objdump</code>中使用的参数的含义。使用其它体系结构的编译器（如课程平台的 MIPS交叉编译器）重复上述各步编译过程，观察并在实验报告中提交相应的结果。<br><strong>A：</strong><br>objdump命令的常用参数有以下几个</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-d</td><td style="text-align: center;">将代码段反汇编反汇编那些应该还有指令机器码的section</td></tr><tr class="even"><td style="text-align: center;">-D</td><td style="text-align: center;">与 -d 类似，但反汇编所有section</td></tr><tr class="odd"><td style="text-align: center;">-S</td><td style="text-align: center;">将代码段反汇编的同时，将反汇编代码和源代码交替显示，源码编译时需要加-g参数，即需要调试信息</td></tr><tr class="even"><td style="text-align: center;">-C</td><td style="text-align: center;">将C++符号名逆向解析</td></tr><tr class="odd"><td style="text-align: center;">-l</td><td style="text-align: center;">反汇编代码中插入源代码的文件名和行号</td></tr><tr class="even"><td style="text-align: center;">-j</td><td style="text-align: center;">section:仅反编译所指定的section，可以有多个-j参数来选择多个section</td></tr></tbody></table><p>因此，指导书上的<code>objdump -DS [executable file]</code>这一命令中<code>-DS</code>表示将所有的<code>section</code>反汇编，并<strong>将反汇编代码和原码交替显示</strong>。<br>我们使用MIPS交叉编译器重复指导书上的编译过程——</p><ul><li>我们先新建一个C文件<code>main.c</code><br><img src="1.1_code.png"></li><li>然后使用交叉编译器<code>mips_4KC-gcc</code>将该文件编译成<code>main.o</code>文件,然后用<code>mips_4KC-objdump</code>将其反汇编。<br><img src="1.1_order.png"></li><li>反汇编结果如下所示（截取部分）<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">main.o:     <span class="token function">file</span> <span class="token function">format</span> elf32-tradbigmipsDisassembly of section .text:00000000 <span class="token operator">&lt;</span>main<span class="token operator">&gt;</span>:<span class="token number">0</span>:   27bdffe0        addiu   sp,sp,-32<span class="token number">4</span>:   afbe0018        sw      s8,24<span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token number">8</span>:   03a0f021        move    s8,spc:   <span class="token number">24020001</span>        li      v0,1<span class="token number">10</span>:   afc20010        sw      v0,16<span class="token punctuation">(</span>s8<span class="token punctuation">)</span><span class="token number">14</span>:   <span class="token number">24020002</span>        li      v0,2<span class="token number">18</span>:   afc2000c        sw      v0,12<span class="token punctuation">(</span>s8<span class="token punctuation">)</span>1c:   8fc30010        lw      v1,16<span class="token punctuation">(</span>s8<span class="token punctuation">)</span><span class="token number">20</span>:   8fc2000c        lw      v0,12<span class="token punctuation">(</span>s8<span class="token punctuation">)</span><span class="token number">24</span>:   00621021        addu    v0,v1,v0<span class="token number">28</span>:   afc20008        sw      v0,8<span class="token punctuation">(</span>s8<span class="token punctuation">)</span>2c:   00001021        move    v0,zero<span class="token number">30</span>:   03c0e821        move    sp,s8<span class="token number">34</span>:   8fbe0018        lw      s8,24<span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token number">38</span>:   27bd0020        addiu   sp,sp,323c:   03e00008        jr      ra<span class="token number">40</span>:   00000000        nop        <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="thinking-1.2">Thinking 1.2</h3><p><strong>Q：</strong> 也许你会发现我们的 <code>readelf</code>程序是不能解析之前生成的内核文件 (内核文件是可执行文件)的，而我们刚才介绍的工具 <code>readelf</code>则可以解析，这是为什么呢?(提示：尝试使用<code>readelf -h</code>，观察不同)</p><p><strong>A：</strong>我们使用<code>readelf -h</code>分别查看<code>testELF</code>和<code>vmlinux</code>的文件头<br><img src="1.2testelf.png"><br><img src="1.2vmlinux.png"><br>可以发现，<code>testELF</code>文件是小端储存，而<code>vmlinux</code>是大端储存。因为我们写的<code>readelf</code>不能读取大端存储的数据，所以无法解析<code>vmlinux</code>。</p><h3 id="thinking-1.3">Thinking 1.3</h3><p><strong>Q：</strong> 在理论课上我们了解到， MIPS体系结构上电时，启动入口地址为<code>0xBFC00000</code>（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？<br><strong>A：</strong>因为我们在<code>scse0_3.lds</code>中设置好了各个节被加载的位置，即最终的<code>segment</code>地址，同时使用了<code>ENTRY(_start)</code>指定了程序入口（即内核入口），最终保证了内核入口能够被正确跳转。</p><h3 id="thinking-1.4">Thinking 1.4</h3><p><strong>Q：</strong> <code>sg_size</code> 和 <code>bin_size</code>的区别它的开始加载位置并非页对齐，同时 <code>bin_size</code>的结束位置（<code>va+i</code>）也并非页对齐，最终整个段加载完毕的<code>sg_size</code>末尾的位置也并非页对齐，请思考，为了保证页面不冲突（不重复为同一地址申请多个页，以及页上数据尽可能减少冲突），这样一个程序段应该怎样加载内存空间中。<br><img src="1.4.png"><br><strong>A：</strong>加载前先检查，当程序运行到该页面时，再把该页面加载到相应位置。</p><h3 id="thinking-1.5">Thinking 1.5</h3><p><strong>Q：</strong>内核入口在什么地方？<code>main</code>函数在什么地方？我们是怎么让内核进入到想要的<code>main</code>函数的呢？又是怎么进行跨文件调用函数的呢？<br><strong>A：</strong>内核入口的起始地址是<code>_start</code>的地址（因为在<code>linker script</code>中用<code>ENTRY()</code>指定了），main函数是在<code>start.S</code>中跳转的地址。这两个地址可以通过反汇编<code>vmlinux</code>获知。<br><img src="1.5.png"><br>由上图可知，内核入口地址是<code>0x80010000</code>，<code>main</code>函数地址是<code>0x80010050</code></p><p>本实验中是通过<code>start.S</code>中使用<code>jal</code>指令跳转到<code>main</code>函数的。跨文件调用是通过跳转指令实现的，在调用函数之前还需将数据存入<strong>栈</strong>中。</p><h3 id="thinking-1.6">Thinking 1.6</h3><p><strong>Q：</strong> 查阅《See MIPS Run Linux》一书相关章节，解释boot/start.S 中下面几行对 CP0协处理器寄存器进行读写的意义。具体而言，它们分别读/写了哪些寄存器的哪些特定位，从而达到什么目的？<br><img src="1.6.png"></p><p><strong>A：</strong></p><ul><li><code>mtc0 zero, CP0_STATUS</code>主要是用来将CPO的<code>12</code>号寄存器（即<code>SR</code>寄存器）设置为0，此时全局中断能位<code>IE</code>的值也是<code>0</code>,全局中断使能失效，CPU不对中断进行响应.<br><img src="SR.png"></li><li>下面4行代码主要是对CP0的<code>16</code>号寄存器（即<code>Config</code>寄存器）进行操作。使用<code>and</code>和<code>ori</code>指令将该寄存器的<code>K0</code>域（0-2位）域设置为<code>0b010</code>，目的是禁止固定的<code>kseg0</code>经过高速缓存。<br><img src="Config.png"></li></ul><h2 id="实验难点图示">实验难点图示</h2><p>我认为该实验的难点主要包含以下两个难点——</p><ul><li>如何使用指针来获取ELF文件中各个<code>section</code>和<code>segment</code>中的数据</li><li>printf实现逻辑的梳理</li></ul><h3 id="elf的解析">ELF的解析</h3><p>在这一部分中，我们需要熟悉ELF文件的基本结构，尤其是下面这个图——<br><img src="elf.png"></p><p>此外，我们需要学会通过<code>ELF</code>手册来获知各个结构体的内部数据，最后通过指针来将数据获取。无论是解析<code>section</code>还是解析<code>segment</code>，我们都需要从文件头中获得<code>section header table</code>或者<code>segment header table</code>的位置。<br>以<code>segment</code>为例，我们需要先从<strong>文件头结构体（<code>ELF header</code>）</strong>中获得段表（<code>sgement header table</code>）与文件头的偏移<code>e_phoff</code>，然后让文件头地址<code>bineary</code>与之相加就可以得到段表的位置了。此外，我们还能在<strong>文件头结构体</strong>中获得每个<code>segment</code>的大小（<code>e_phentsize</code>）和<code>segment</code>的总数量（<code>e_phnum</code>）,然后我们就可以通过指针的移动来遍历所有的<code>segment</code>了。</p><p>具体的实现方法有以下两种——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Elf32_Phdr <span class="token operator">*</span>phdr <span class="token operator">=</span> null<span class="token punctuation">;</span>ptr_ph_table <span class="token operator">=</span> binary <span class="token operator">+</span> ehdr <span class="token operator">-&gt;</span> e_phoff<span class="token punctuation">;</span> <span class="token comment">//ptr_ph_table是u_char*类型</span>ph_entry_count <span class="token operator">=</span> ehdr <span class="token operator">-&gt;</span> e_phnum<span class="token punctuation">;</span>ph_entry_size <span class="token operator">=</span> ehdr <span class="token operator">-&gt;</span> e_phentsize<span class="token punctuation">;</span><span class="token comment">//第一种：指向段表指针的移动</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> Nr <span class="token operator">&lt;</span> ph_entry_count<span class="token punctuation">;</span> Nr<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    shdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf32_Phdr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr_ph_table <span class="token operator">+</span> Nr <span class="token operator">*</span> ph_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d:0x%x\n"</span><span class="token punctuation">,</span> Nr<span class="token punctuation">,</span> shdr<span class="token operator">-&gt;</span>sh_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//第二种：将段表作为数组访问</span>shdr <span class="token operator">=</span>  <span class="token punctuation">(</span>Elf32_Phdr<span class="token operator">*</span><span class="token punctuation">)</span>ptr_ph_table<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> Nr <span class="token operator">&lt;</span> ph_entry_count<span class="token punctuation">;</span> Nr<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d:0x%x\n"</span><span class="token punctuation">,</span> Nr<span class="token punctuation">,</span> shdr<span class="token punctuation">[</span>Nr<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="printf实现逻辑">printf实现逻辑</h3><p>我们的<code>printf()</code>函数是通过调用<code>print.c</code>文件中定义的的<code>lp_Print()</code>函数来实现打印的功能——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Pvoid <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     va_list ap<span class="token punctuation">;</span>     <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">lp_Print</span><span class="token punctuation">(</span>myoutput<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这个<code>lp_Print()</code>函数实现了<code>printf</code>的核心逻辑，虽然函数很长，但是逻辑并不复杂。实际上就是，遍历一遍<strong>格式字符串<code>fmt</code></strong>，如果没有遇到<code>\0</code>或者<code>%</code>就直接打印到终端，如果遇到<code>%</code>就按照<code>%[flags][width][.precision][length]specifier</code>的形式进行<strong>输出格式的解析</strong>，并以这种输出格式打印<strong>从可变参数列表获得的参数</strong>；如果遇到<code>\n</code>就结束整个打印过程。具体流程如下图所示——<br><img src="printf.png"><p></p><h2 id="体会与感想">体会与感想</h2><p>Lab1主要让我们学习<strong>操作系统启动的基本流程</strong>、掌握<strong>ELF文件的结构和功能</strong>，以及最终<strong>完成一个<code>printf</code>函数的书写</strong>。本次Lab花费时间大约为10个小时，大多数时间都花在阅读源代码和思考源代码的逻辑上。由于完成每个功能依赖的代码文件不止一个，而且在vim中阅读代码终归不如在vscode等图形化编辑器上方便，因此给代码阅读和理解带来了不小的麻烦。此外，课程组提供的源代码中大量使用了“指针”，也给代码的理解带来了一定的困难。<br>但是，当我真正的读懂所给代码的逻辑并完成练习，尤其是当我看到<code>printf</code>函数可以正常运行时，那种成就感和快乐感是无法用言语来形容的。从一开始“不识庐山真面目”，到最终“柳暗花明又一村”，这大概就是操作系统的魅力吧！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec5:继承和组合</title>
      <link href="/2022/03/29/c/cpp-progranming-lec-5/"/>
      <url>/2022/03/29/c/cpp-progranming-lec-5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++中有两种实现<strong>代码重用（<code>reuse</code>）</strong>的方式——<strong>继承（<code>inheritance</code>）和组合（<code>composition</code>）</strong></p><h2 id="继承inheritance">继承inheritance</h2><p>继承：<strong>共性和特性的关系</strong>——</p><ul><li><strong>子类拥有父类所有数据成员和函数，这是所有子类的共性。</strong></li><li><strong>子类可以父类实现的函数进行重写，成为子类自己的特性。（一代更比一代强）</strong></li></ul><blockquote><p>通常情况下，一旦在子类中对父类函数进行了改写，在子类中的该函数中通常会以某种方式调用了父类的同名函数。相反，如果子类和父类的同名函数没有任何关系，那么“继承”则没有任何意义。</p></blockquote><p>继承的语法如下所示<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token punctuation">[</span>子类名<span class="token punctuation">]</span> ： <span class="token keyword">public</span> <span class="token punctuation">[</span>父类名<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><blockquote><p>父类名前通常使用关键字<code>public</code>来修饰。当然使用<code>private</code>在语法上是没有任何问题的，但是这样的话继承方式就会变成<strong>私有继承</strong>。如果是私有继承，则子类中无法使用父类的<code>public</code>方法。<br>私有继承的存在仅仅是为了维护语法完整性，<strong>没有实质性的作用</strong>。</p></blockquote><h3 id="重载函数的重写">重载函数的重写</h3><p>如果父类中有重载函数，且子类想要对其重写，则它应该重写父类所有的重载函数。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base func(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Dervied</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="构造函数的调用问题">构造函数的调用问题</h3><p>在调用子类构造函数时，会默认调用父类的<strong>无参构造函数</strong>调用顺序是——<strong>先父类，后子类</strong>。（在调用子类析构函数时，顺序是<strong>先子类，后父类</strong>）<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//父类</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Base"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//子类</span><span class="token keyword">class</span> <span class="token class-name">Dervied</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Dervied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Dervied</span><span class="token double-colon punctuation">::</span><span class="token function">Dervied</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Derived"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//输出为</span><span class="token comment">//constructor of Base</span><span class="token comment">//constructor of Derived</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>但是，如果此时父类中只有<strong>有参构造函数</strong>，则需要在子类构造函数中<strong>显式地调用父类构造函数</strong>。显式调用的语法为——<code>Dervied::Dervied(...) : Base(...)</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//父类</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Base"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//子类</span><span class="token keyword">class</span> <span class="token class-name">Dervied</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Dervied</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Dervied</span><span class="token double-colon punctuation">::</span><span class="token function">Dervied</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>j <span class="token operator">=</span> j<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Derived"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="多重继承问题">多重继承问题</h3><p>和Java不同，C++是允许使用多重继承的，即<strong>“一个儿子可以有多个父亲”</strong> 。多重继承的语法为——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token punctuation">[</span>子类名<span class="token punctuation">]</span> ： <span class="token keyword">public</span> <span class="token punctuation">[</span>父类名<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token punctuation">[</span>父类名<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>子类同样可以<strong>使用所有父类中的所有<code>public</code>函数和所有<code>public</code>成员变量</strong>,如下所示<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Derived d<span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用父类Base1中的f()函数</span>    d<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用父类Base2中的g()函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>但是如果两个父类<strong>有同名的函数</strong>，则在调用该函数时编译器会报错。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Derived d<span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     d<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//error!!!</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当然这个问题也是能解决的。我们可以<strong>用组合消除多重继承</strong>，即可以将<code>Base2</code>作为子类的一个组成部分（即属性），然后在子类中重写父类<code>Base1</code>的<code>g()</code>函数，重写后的函数内容为——<strong>调用数据成员<code>Base2</code>的<code>g()</code>函数。</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>     Base2 base2<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">Derived</span><span class="token double-colon punctuation">::</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">{</span>    base2<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>注意：<code>data member</code>不一定是属性。在上一个例子中，<code>base2</code>是<code>Derived</code>的<code>data member</code>,但是，我们只是用它来访问<code>Base2</code>类中的<code>g()</code>函数。因此<code>base2</code>不能称作<code>Derived</code>的属性！</p></blockquote><h2 id="组合composition">组合composition</h2><p>组合其实描述的就是<strong>在一个类里内嵌了其他类的对象作为成员的情况</strong>，它们之间的关系是一种<strong>包含与被包含</strong>的关系。在下面这个例子中，发动机类（<code>Engine</code>）作为汽车类（<code>Car</code>）的一个<code>data member</code>，他们之间的关系就是组合。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> power<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Engine</span><span class="token double-colon punctuation">::</span><span class="token function">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Engine"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    Engine engine<span class="token punctuation">;</span> <span class="token comment">//engine成为Car类中的data member</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Car</span><span class="token double-colon punctuation">::</span><span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Car"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="构造函数的调用问题-1">构造函数的调用问题</h3><p>组合中构造函数的调用<strong>和继承相似</strong>，即当<code>Car</code>的构造函数被调用时，<code>Engine</code>的构造函数也会被调用（默认调用<strong>无参构造函数</strong>）。这一点也很显然，我们想要造一辆汽车时，作为其组成部分的<code>Engine</code>当然也会被造出来，否则汽车就无法被开动。</p><p>在调用顺序上，同样是<strong>被包含的类的构造函数首先被调用</strong>，如下所示——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Car car<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//输出:</span><span class="token comment">//constructor of Engine</span><span class="token comment">//constructor of Car</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>但是，如果此时<strong>被包含的类</strong>中只有<strong>含参构造函数</strong>，则需要在<strong>外层类</strong>中<strong>显式地调用被包含类的构造函数</strong>。调用的语法和继承中的也很相似，可以从下面的例子看出——<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> part<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Engine</span><span class="token punctuation">(</span><span class="token keyword">int</span> power<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Engine</span><span class="token double-colon punctuation">::</span><span class="token function">Engine</span><span class="token punctuation">(</span><span class="token keyword">int</span> part<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Engine"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    Engine engine<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Car</span><span class="token punctuation">(</span><span class="token keyword">int</span> power<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Car</span><span class="token double-colon punctuation">::</span><span class="token function">Car</span><span class="token punctuation">(</span><span class="token keyword">int</span> power<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">engine</span><span class="token punctuation">(</span>power<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor of Car"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="构造初始化列表">构造初始化列表</h3><p>上面<strong>被包含的类的对象</strong>的初始化方式同样适用于<code>int</code>等基本类型，这种方式叫做<strong>构造初始化列表</strong>，具体方式是"<strong>在构造函数后以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式</strong>"。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">int</span> grade<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> grade<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">grade</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>因为<code>const</code>对象或引用类型只能初始化，不能二次赋值，也不能在构造函数中进行赋值，所以他们只能通过<strong>构造初始化列表的方式进行赋初值（初始化）</strong>。</p></blockquote><p>需要注意的是，初始化顺序与构造初始化列表中的顺序无关，<strong>只与类中变量被定义的顺序有关</strong>。在下面这个例子中，无论构造初始化列表中的顺序怎样，首先被初始化的都是<code>j</code>,而因为用来初始化<code>j</code>的<code>i</code>是未定义的，所以最后<code>j</code>的值一个<strong>“垃圾数”</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Test</span><span class="token double-colon punctuation">::</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">j</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//把j(a)放在i(j)前面时结果也是一样的</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OO」第一单元:表达式展开</title>
      <link href="/2022/03/24/oo/oo-di-yi-dan-yuan-zong-jie/"/>
      <url>/2022/03/24/oo/oo-di-yi-dan-yuan-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>第一单元的主题是<strong>表达式括号展开</strong>，主要的学习目标是熟悉面向对象的思想，学会使用类来管理对象，掌握一定的模块化设计能力。本单元一共有三次作业——<strong>单变量多项式展开</strong>，<strong>含有三角函数、求和函数和自定义函数的多项式展开</strong>，<strong>含有多层嵌套的表达式展开</strong>。</p><p>可以看出，这三次作业的要求是<strong>一步步递进的</strong>，代码的复杂度也同样大大递增。就好像是一个喋喋不休的甲方每周都会定时给你提一堆“变态”的要求，而你又无法拒绝……不过好在经过一个月的挣扎，第一单元终于落下了帷幕，借着这篇博客，我将对三次作业的代码进行详细分析，并对本人的学习心得和体会进行总结。</p><h2 id="第一次作业分析">第一次作业分析</h2><p>第一次作业主要是关于单变量多项式的展开，这次我们需要展开的表达式中项只有三种——幂函数，常数因子和表达式因子。</p><h3 id="代码uml类图">代码UML类图</h3><p>本次作业代码的UML类图如下所示<br><img src="1.png"></p><h3 id="代码架构分析">代码架构分析</h3><p>简单分析本次作业的要求后我们不难发现，我们表达式主要包含三部分——<code>Expr</code>，<code>Term</code>，<code>Factor</code>，而<code>Factor</code>又有三种——<strong>幂函数，常数因子和表达式因子</strong>，基于面向对象的思想，我们要对这些类型分别建类。其中<code>Expr</code>类中使用<code>ArrayList</code>来容纳该表达式中含有的<code>Term</code>，<code>Term</code>类中使用<code>ArrayList</code>来容纳该项中含有的<code>Factor</code>。</p><p>建类仅仅是第一步，此外我们还面临两个问题——</p><ul><li><strong>如何将表达式、项和因子解析出来？</strong></li><li><strong>如何将表达式进行展开?</strong></li></ul><h4 id="表达式解析递归下降算法">表达式解析：递归下降算法</h4><p>第一个问题主要有两种解决方式——一个是使用<strong>正则表达式</strong>进行字符串的解构，另一个是往届学长大力推荐的<strong>递归下降算法</strong>。曾有学长说——“使用正则表达式后给后面的作业带来意想不到的bug”，于是我就果断选择了后者。</p><p>递归下降算法听上去高深莫测，但是在课程组开放的训练题中一番接触后，感觉其实也不是很复杂。它主要包含了两个部分——<code>Lexer</code>（词法分析器）和<code>Paser</code>（解析器）。</p><p><code>Lexer</code>主要是将表达式分解成一系列基本语法单元，而<code>Parser</code>主要是根据表达式的形式化定义，依靠<code>Lexer</code>分解出的语法单元(<code>token</code>)，递归的生成表达式、项和因子。</p><h5 id="lexer">Lexer</h5><p>在本次作业中，表达式的基本语法单元的类型有 <code>NUM</code>,<code>X</code>, <code>MULTI</code>, <code>MINUS</code>,<code>EXP</code>, <code>PLUS</code>, <code>LP</code>,<code>RP</code>，我们将这些语法单元的类型用<code>TokenType</code>这一枚举类型来记录。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">TokenType</span> <span class="token punctuation">{</span>    <span class="token constant">NUM</span><span class="token punctuation">,</span> <span class="token class-name">X</span><span class="token punctuation">,</span>    <span class="token constant">MULTI</span><span class="token punctuation">,</span> <span class="token constant">MINUS</span><span class="token punctuation">,</span> <span class="token constant">EXP</span><span class="token punctuation">,</span> <span class="token constant">PLUS</span><span class="token punctuation">,</span>    <span class="token constant">LP</span><span class="token punctuation">,</span> <span class="token constant">RP</span><span class="token punctuation">,</span> <span class="token comment">//左括号和右括号</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>因为本作业语法单元比较简单，我们可以<strong>直接用for循环来遍历字符串，</strong>然后用<code>switch-case</code>来对语法单元进行分析，将分析出来的<strong>语法单元及其类型</strong>分别放入Lexer类中的<code>tokenList</code>和<code>tokenTypeList</code>——<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token char">'+'</span><span class="token operator">:</span>        tokenList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tokenTypeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">PLUS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token char">'-'</span><span class="token operator">:</span>        <span class="token comment">//...</span>    <span class="token keyword">case</span> <span class="token char">'*'</span><span class="token operator">:</span>        <span class="token comment">//...</span>    <span class="token keyword">case</span> <span class="token char">'('</span><span class="token operator">:</span>        <span class="token comment">//...</span>    <span class="token keyword">case</span> <span class="token char">')'</span><span class="token operator">:</span>        <span class="token comment">//...</span>    <span class="token keyword">case</span> <span class="token char">'x'</span><span class="token operator">:</span>        <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样我们就把表达式中所有语法单元都解析出来了，下面就该到<code>Parser</code>发挥作用了<p></p><h5 id="parser">Parser</h5><p><code>Parser</code>类的设计主要是沿用了本单元练习题中的写法，将表达式的解析分成了三部分——<code>parseExpr</code>,<code>parseTerm</code>,<code>parseFactor</code>，每一部分的解析都遵循形式化文法。</p><p>以<code>parseExpr</code>为例，因为第一项之前可能带有符号，于是我们就先将符号（<code>+</code>或者<code>-</code>）解析出来，然后解析第1项。解析完第1项后，我们就可以直接使用<code>while</code>循环对后面的项依次进行解析。需要注意的是，<strong>解析项</strong>实际上就调用一次<code>parseFactor()</code>方法.代码如下——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Expr</span> expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// get the first term</span>    <span class="token keyword">int</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">MINUS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sign <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">PLUS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    expr<span class="token punctuation">.</span><span class="token function">addTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// get the terms left;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">MINUS</span> <span class="token operator">||</span> lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">PLUS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">PLUS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expr<span class="token punctuation">.</span><span class="token function">addTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expr<span class="token punctuation">.</span><span class="token function">addTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token keyword">int</span> sign<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="表达式展开">表达式展开</h4><p>经过分析，本次作业中表达式展开的最终结果其实是一个多项式的形式——<br><span class="math display">\[Expr = \sum a_ix^{n_i}\]</span><br>可以发现，<strong>多项式</strong>中含有一系列的<strong>单项式</strong>，每个单项式都是<span class="math inline">\(ax^n\)</span>这种形式。于是我们不难想到，我们可以再建立两个类——<code>Poly</code>（<strong>多项式类</strong>）和<code>Mono</code>（<strong>单项式类</strong>）。</p><ul><li><p><code>Mono</code>类含有两个成员变量——<code>coe</code>和<code>exp</code>，分别代表<strong>系数</strong>和<strong>x的指数</strong>。然后还有<code>toString()</code>方法，将<code>Mono</code>转化成<strong>"coe*x**exp"</strong> 这种形式<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Mono.java</span><span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coe<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> exp<span class="token punctuation">;</span><span class="token comment">//...</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toStirng</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><code>Poly</code>类有一个<code>ArrayList</code>容器，用来容纳<strong>一系列<code>Mono</code></strong>，此外还有<code>addPoly()</code>，<code>mulPoly()</code>和<code>powPoly()</code>等方法来实现多项式的运算,最后有<code>toString()</code>方法<strong>将每个<code>Mono</code>的字符串形式链接起来，形成表达式字符串</strong><br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Poly.java</span><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> monoList<span class="token punctuation">;</span><span class="token comment">//.....</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">addPoly</span><span class="token punctuation">(</span><span class="token class-name">Poly</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">mulPoly</span><span class="token punctuation">(</span><span class="token class-name">Poly</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">powPoly</span><span class="token punctuation">(</span><span class="token class-name">Poly</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toStirng</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样之后，我们就可以在<code>Expr</code>、<code>Term</code>、<code>Factor</code>等类中都写一个<code>toPoly()</code>方法，将类中的内容转化为多项式。然后从<code>factor.toPoly()</code>一步步向上转化，那么最终可以通过<code>expr.toPoly()</code>来获得结果。具体的转化过程如下——<p></p></li><li><p><code>numFactor</code>(数字因子)和<code>powerFactor</code>（幂函数因子）的<code>toPoly</code>方法很简单，直接转化为<strong>只含有一个<code>Mono</code>的<code>Poly</code></strong>即可。<strong>例如</strong>，因子<code>5</code>可以转化为一个只含有单项式<code>5*x**0</code>的多项式，因子<code>x**2</code>一个只含有单项式<code>1*x**2</code>的多项式。</p></li><li><p><code>Term</code>类的<code>toPoly()</code>方法是：将该类中含有的所有<code>Factor</code>的<code>Poly</code>形式（即<code>toPoly()</code>的结果）用<code>mulPoly()</code>方法乘起来。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Term.java</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//....</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Factor</span> it <span class="token operator">:</span> factors<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Poly</span> temp <span class="token operator">=</span> poly<span class="token punctuation">.</span><span class="token function">mulPoly</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poly <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sign <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        poly<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>注意一个细节，因为项是有符号的，如果该项整体是负的，我们需要把<code>Poly</code>中所有的单项式的系数取反，这个取反操作我们是通过<code>Poly</code>类中定义的<code>negate()</code>方法实现的。<p></p></li><li><p><code>Expr</code>类的<code>toPoly()</code>方法是：将其含有的所有<code>Term</code>的<code>Poly</code>形式（即<code>toPoly()</code>的结果）用<code>addPoly()</code>方法加起来。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Expr.java</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Poly</span> poly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Term</span> it <span class="token operator">:</span> terms<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Poly</span> temp <span class="token operator">=</span> poly<span class="token punctuation">.</span><span class="token function">addPoly</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poly <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>对于<code>exprFactor</code>，因为其包含一个<strong>Expr类型的“底”</strong>和一个<strong>int类型的指数</strong>，我们可以通过<code>expr.toPoly()</code>得到<strong>”底”的多项式形式</strong>，然后使用<code>powPoly()</code>方法展开。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//exprFactor.java</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Poly</span> poly <span class="token operator">=</span> base<span class="token punctuation">.</span><span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">powPoly</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样，我们就可以通过在每个类中定义的<code>toPoly()</code>方法<strong>自底向上</strong>地得到<strong>表达式的多项式形式</strong>。最后，我们再通过Poly中的<code>toString()</code>方法就可以获得最终展开后的结果。<p></p></li></ul><h4 id="其他细节">其他细节</h4><ol type="1"><li><strong>表达式预处理：</strong>我们设置了一个表达式预处理类<code>Processer</code>，预处理的内容包括——<strong>将表达式中空白符删去</strong>、<strong>将连续的+-号合并成一个</strong>。</li><li><strong>关于优化</strong>：<ul><li>如果单项式系数为<code>0</code>，则最终结果为<code>0</code>,</li><li>如果单项式系数为<code>1</code>，则可以省略系数，简化为<span class="math inline">\(x^n\)</span></li><li>如果单项式系数为<code>-1</code>，则可以省略系数，简化为<span class="math inline">\(-x^n\)</span></li><li>如果单项式x的指数为<code>0</code>，则最终结果只输出系数</li><li>如果单项式x的指数为<code>1</code>，则指数部分可以省略,简化为<span class="math inline">\(ax\)</span></li><li>如果单项式x的指数为<code>2</code>,则<code>x**2</code>可以化简为<code>x*x</code></li></ul></li></ol><h3 id="代码复杂度分析">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="P1dependecy.png"><br>从代码复杂度分析数据可以看到，大多数方法的复杂度在合理范围之内，而有四个方法复杂度超标.</p><ul><li><p><code>Lexer</code>类中的<code>getTokens()</code>方法使用了<code>switch-case</code>对表达式的语法单元进行解析。由于使用了<code>switch</code>的语法结构，因此结构非常冗杂，导致代码量暴增。<br>在作业2中，我采用了<code>正则表达式</code>来进行优化</p></li><li><p>在<code>Parser</code>类中的<code>parseFactor()</code>方法里，我们需要<strong>先判断当前解析的因子是什么类型的</strong>（数字因子？幂函数因子？表达式因子？）然后<strong>再根据因子的类型分别进行解析</strong>，这样也导致了代码复杂度较高。</p><p>在作业2中，我为每一种因子的解析都单独封装了一个方法，然后在<code>parseFactor()</code>中调用这些方法。这样既可以减少<code>parseFactor()</code>方法的复杂度，也提高了代码可读性。</p></li><li><p><code>Mono</code>类中<code>toString()</code>方法<strong>在生成单项式的字符串形式时</strong>，需要针对对每一种特定的情况进行优化，免不了使用大量的<code>if-else</code>语句进行特判，复杂度高也在所难免。</p></li></ul><h2 id="第二次作业分析">第二次作业分析</h2><p>第二次作业在第一次的基础上增加了<strong>三角函数因子</strong>，<strong>求和函数因子</strong>和<strong>自定义函数因子</strong>，复杂度进一步提高。</p><h3 id="代码uml类图-1">代码UML类图</h3><p>本次作业代码的UML类图如下所示<br><img src="2.png"></p><h3 id="代码架构分析-1">代码架构分析</h3><p>第一次作业到第二次作业的跨度比较大，但是<strong>递归下降方法可以继续沿用</strong>，只需要增加几种语法单元即可（包括<code>SIN</code>,<code>COS</code>,<code>FUNC</code>,<code>SUM</code>,<code>CMA</code>[逗号]）。本次作业的困难之处主要有以下几点——</p><ul><li><strong>三角函数如何解析</strong>？</li><li><strong>如何解析求和函数<code>sum(i, 求和下界, 求和上界, 求和表达式)</code>？如何将i的值带入到求和因子<code>factor</code>中？</strong></li><li><strong>如何解析自定义函数<code>[fgh](x,y,z)</code>?如何将实参带入到函数定义式中?</strong></li><li><strong>在本次作业我们不能使用<span class="math inline">\(ax^n\)</span>作为多项式<code>Poly</code>的最小组成单元，那么我们该用什么?</strong></li></ul><h4 id="三角函数的解析">三角函数的解析</h4><p>首先我们可以新建了一个<code>sinFactor</code>类和<code>cosFactor</code>类（其实也可以合并成一个类），类中有两个成员变量——<code>factor</code>(表示三角函数括号内的因子)，<code>exp</code>(表示三角函数的指数部分)<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//sinFactor.java</span><span class="token keyword">private</span> <span class="token class-name">Factor</span> factor<span class="token punctuation">;</span> <span class="token comment">//三角函数括号内的因子</span><span class="token keyword">private</span> <span class="token keyword">int</span> exp<span class="token punctuation">;</span> <span class="token comment">//三角函数的指数部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>为解析三角函数，我们在<code>parser</code>类中设置了一个<code>parserSinCosFactor()</code>方法，该方法在<code>parseFactor()</code>中被调用。<strong>解析逻辑是</strong>，当我们在<code>parseFactor()</code>中发现当前解析的因子为<code>sin</code>或者<code>cos</code>时，我们就可以调用<code>parserSinCosFactor()</code>方法，先将三<strong>角函数括号内的因子</strong>进行解析（即在该方法中再调用<code>parseFactor()</code>方法），然后解析该<strong>三角函数的指数</strong>，最后将解析结果保存到一个<code>SinFactor</code>对象或者<code>CosFactor</code>对象中返回即可。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Paser.java</span><span class="token keyword">private</span> <span class="token class-name">Factor</span> <span class="token function">parseSinCosFactor</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//......</span>    <span class="token class-name">Factor</span> inside <span class="token operator">=</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//.......</span>    <span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">EXP</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        exp <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//如果有指数的话则更新exp，否则exp = 1 </span>    <span class="token punctuation">}</span>    <span class="token comment">//.....</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"sin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">sinFactor</span><span class="token punctuation">(</span>inside<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">cosFactor</span><span class="token punctuation">(</span>inside<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="求和函数的解析">求和函数的解析</h4><p>首先，我新建了一个<code>SumFactor</code>类，成员变量有——<code>upper</code>,<code>lower</code>,<code>sumTarget</code>,<code>sumRes</code>,<code>expr</code>，用于封装求和函数对象<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//SumFactor.java</span><span class="token keyword">private</span> <span class="token class-name">BigInteger</span> upper<span class="token punctuation">;</span> <span class="token comment">//求和上界</span><span class="token keyword">private</span> <span class="token class-name">BigInteger</span> lower<span class="token punctuation">;</span> <span class="token comment">//求和下界</span><span class="token keyword">private</span> <span class="token class-name">Factor</span> sumTarget<span class="token punctuation">;</span> <span class="token comment">//求和目标，即需要求和的因子</span><span class="token keyword">private</span> <span class="token class-name">String</span> sumRes<span class="token punctuation">;</span> <span class="token comment">//根据求和初步展开的表达式</span><span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span> <span class="token comment">//将sumRes解析出来的表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>为解析求和函数，我们在<code>parser</code>类中设置了一个<code>parserSumFactor()</code>方法，<strong>解析逻辑是</strong>，先将求和函数的<strong>上界和下界</strong>解析出来，然后解析最后的<code>求和因子</code>（同样是调用<code>parseFactor()</code>方法），最后将解析结果保存到一个<code>SumFactor</code>对象中返回。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Paser.java</span><span class="token keyword">private</span> <span class="token class-name">Factor</span> <span class="token function">parseSumFactor</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token class-name">NumFactor</span> upper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">NumFactor</span><span class="token punctuation">)</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//skip ','</span>    <span class="token class-name">NumFactor</span> lower <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">NumFactor</span><span class="token punctuation">)</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//skip ','</span>    <span class="token class-name">Factor</span> sumTarget <span class="token operator">=</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//skip ')'</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SumFactor</span><span class="token punctuation">(</span>upper<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> sumTarget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>“将结果保存到一个<code>SumFactor</code>对象”实际上是调用了一个<strong>该类的构造函数</strong>，在这个构造函数中我们还做了进一步处理——<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//SumFactor.java</span><span class="token keyword">public</span> <span class="token class-name">SumFactor</span><span class="token punctuation">(</span><span class="token class-name">NumFactor</span> lower<span class="token punctuation">,</span> <span class="token class-name">NumFactor</span> upper<span class="token punctuation">,</span> <span class="token class-name">Factor</span> sumTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>upper <span class="token operator">=</span> upper<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lower <span class="token operator">=</span> lower<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sumTarget <span class="token operator">=</span> sumTarget<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sumRes <span class="token operator">=</span> <span class="token function">setSumRes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>expr <span class="token operator">=</span> <span class="token function">setExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里我们调用了两个函数——<code>setSumRes()</code>和<code>setExpr()</code>，这两个函数都是定义在该文件中的<code>private</code>方法<p></p><ul><li><p><code>setSumRes()</code>方法主要是根据<code>lower</code>和<code>upper</code>将求和函数展开成字符串，主要采用的是字符串替换的方法——使用<code>for</code>循环让<code>i</code>从<code>lower</code>遍历到<code>upper</code>，然后将i的值代入的<strong>求和目标<code>sumTarget</code>的字符串形式</strong></p><blockquote><p>这时你可能会疑惑，求和目标<code>sumTarget</code>是<code>Factor</code>类型，怎么获得字符串形式呢???<br>实际上，在这次作业中我给每一个数据类都重写了<code>toString()</code>方法，非递归的<code>Factor</code>类型(如数字因子，幂函数因子)可以直接变为字符串形式，<code>Term</code>的<code>toString()</code>是将其含有的所有<code>Factor</code>的字符串形式用"*"连接起来，而<code>Expr</code>的<code>toString()</code>是将其含有的所有<code>Term</code>的字符串形式用"+"连接起来即可。</p></blockquote></li><li><p><code>setExpr()</code>实际上将字符串形式的求和结果<code>sumRes</code>使用<code>Lexer</code>和<code>Paser</code>进行解析，然后返回解析出来的<code>Expr</code>对象。</p></li></ul><p>至此，求和函数解析告一段落。</p><h4 id="自定义函数的定义和解析">自定义函数的定义和解析</h4><p>首先，我新建了一个<code>FuncFactor</code>类，成员变量有——<code>newFunc</code>和<code>expr</code>，用于封装自定义函数类型的对象<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//FuncFactor.java</span><span class="token keyword">private</span> <span class="token class-name">String</span> newFunc<span class="token punctuation">;</span> <span class="token comment">//将函数实参带入形参位置后的结果(字符串形式)</span><span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span> <span class="token comment">//将newFunc解析成表达式后的结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>为了便于自定义函数的定义和解析，我还新建了一个工具类<code>Definer</code>,主要处理<strong>自定义函数的定义和调用</strong>。该函数的成员和方法都是静态的，意味着我们不需要实例化对象，直接通过类名即可调用。<p></p><ul><li>该函数有两个主要的私有静态成员<code>funcMap</code>和<code>paraMap</code>,两者都是HashMap类型，前者可以通过<strong>函数名</strong>（f/g/h）来获得<strong>函数的定义式</strong>，后者可以通过<strong>函数名</strong>来获得该<strong>函数的形参列表</strong>（x/y/z）。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Definer.java</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> funcMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> paraMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>该类有两个主要函数——<code>addFunc()</code>和<code>callFunc()</code>，看名字就大概能猜出来他俩的功能。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Definer.java</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualParas<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>前者是在函数调用时使用，将终端输入的函数表达式传入该函数并进行解析（主要通过<strong>正则表达式</strong>），并<strong>将该函数的定义式和形参列表分别加入<code>funcMap</code>和<code>paraMap</code></strong>。</li><li>后者是在函数调用时使用（更准确的说是在自定义函数解析的时候使用的），传入的参量是函数名<code>name</code>和实参列表<code>acturalParas</code>。<br>该函数的逻辑是——首先根据<code>name</code>获得<strong>函数定义式和行参列表</strong>，根据<strong>形参列表</strong>和<strong>实参列表</strong>的对应关系建立一个映射<code>map</code>。然后<strong>遍历一遍字符串</strong>，根据映射关系将函数定义式中的<strong>形参</strong>替换成<strong>实参的字符串形式</strong>(实参传入时是<code>Factor</code>类型,直接调用其<code>toString()</code>方法即可)</li></ul></li></ul><p>有了工具类<code>Definer</code>提供的buff加成，我们接下来就可以轻松的进行自定义函数的解析了。<br>首先还是先在<code>parser</code>类中设置了一个<code>parseFuncFactor()</code>方法，<strong>解析逻辑是</strong>先解析函数名，然后解析所有的实参（因为实参是<code>Factor</code>类型，因此还是直接调用<code>parseFactor()</code>），最后将结果封装在<code>FuncFactor</code>对象中返回即可<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Parser.java</span><span class="token keyword">private</span> <span class="token class-name">Factor</span> <span class="token function">parseFuncFactor</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualParas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    actualParas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">getTokenType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">TokenType</span><span class="token punctuation">.</span><span class="token constant">RP</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lexer<span class="token punctuation">.</span><span class="token function">nextPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        actualParas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuncFactor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> actualParas<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此时我们只把函数名和实参解析出来，还没有对函数表达式进行解析。剩下的解析过程在<code>FuncFactor</code>类的构造方法中实现——<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//FuncFactor.java</span><span class="token keyword">public</span> <span class="token class-name">FuncFactor</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualParas<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>newFunc <span class="token operator">=</span> <span class="token class-name">Definer</span><span class="token punctuation">.</span><span class="token function">callFunc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> actualParas<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>expr <span class="token operator">=</span> <span class="token function">setExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token class-name">Expr</span> <span class="token function">setExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token class-name">Processer</span><span class="token punctuation">.</span><span class="token function">adjust</span><span class="token punctuation">(</span>newFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Lexer</span> lexer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lexer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Parser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parser</span><span class="token punctuation">(</span>lexer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> parser<span class="token punctuation">.</span><span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在构造函数中，我们通过工具类<code>Definer</code>中的<code>callFunc()</code>方法，获得了<strong>带入实参后的表达式的字符串形式</strong><code>newFunc</code>，然后用本类中的私有方法<code>setExpr()</code>将<code>newFunc</code>解析成了<code>Expr</code>（同样需要使用<code>Lexer</code>和<code>Paser</code>)<p></p><p>至此，自定义函数的解析也圆满结束了。</p><h4 id="表达式展开-1">表达式展开</h4><p>将新加入的几种<code>Factor</code>解析完后，终于遇到了最难啃的一块骨头——<strong>表达式展开</strong>。我的思路是继续沿用第一次作业中<code>Mono</code>和<code>Poly</code>的形式，但是因为本次作业中多项式最小单元不是<span class="math inline">\(ax^n\)</span>，而是变成了<br><span class="math display">\[ax^n\prod_isin(Factor_i)\prod_icos(Factor_i)\]</span><br>这意味这我们在第一次作业中使用的<code>Mono</code>失效了，经过再三斟酌，我将<code>Mono</code>改称为<code>Unit</code>（表示最小单元），并对其数据组成进行了一定修改——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Unit.java</span><span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coe<span class="token punctuation">;</span> <span class="token comment">//系数</span><span class="token keyword">private</span> <span class="token keyword">int</span> varExp<span class="token punctuation">;</span> <span class="token comment">//x的指数部分</span><span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sinMap<span class="token punctuation">;</span> <span class="token comment">//所有sin括号里的内容及其指数</span><span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cosMap<span class="token punctuation">;</span> <span class="token comment">//所有cos括号里的内容及其指数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>coe</code>和<code>varExp</code>都很好理解，<code>sinMap</code>和<code>cosMap</code>是用来存储这个最小单元的三角函数。Hashmap的key是<strong>三角函数括号里的表达式</strong>，value是<strong>三角函数指数</strong><p></p><blockquote><p>注意“三角函数括号里的表达式实”际上是<code>SinFactor</code>（或者<code>CosFactor</code>）中的<strong>expr成员</strong>先转化为<code>Poly</code>，再转化成字符串得到的。也就是直接调用<code>expr.toPoly().toString()</code>获得的结果）</p><p>不得不说这样确实很复杂，而且因为直接转化成了字符串，也不能对三角函数括号里的内容做任何修改，所在第三次作业中我直接改用<code>Poly</code>作为<code>sinMap</code>和<code>cosMap</code>的键。</p></blockquote><p>在<code>Poly</code>中，我们仍然使用一个<code>ArrayList</code>来存放它下属的各个<code>Unit</code>，因为<code>Unit</code>结构的改变,<code>mulPoly()</code>, <code>addPoly()</code>,<code>powPoly()</code>等函数的实现细节也需要进行一定的修改，此处不再赘述。但是需要注意的时，在上述函数中少不了合并同类项的步骤，为了识别同类项，我们需要在<code>Unit</code>中重写<code>equals()</code>和<code>hashCode()</code>方法。</p><blockquote><p>注意equals()方法重写时，不需要比较coe。</p></blockquote><p>这样再稍微调整一下<strong>各个数据类的toPoly()方法</strong>的实现，就可以得到最终的结果了。</p><h3 id="代码复杂度分析-1">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="P2dependecy.png"><br>由于方法太多，我们只截取了parser和polynomial包内的方法复杂度（其他包内的方法的复杂度均为合理范围之内）。</p><p>不难发现，这次复杂方法重灾区主要集中在<code>Unit</code>类和<code>Poly</code>类中，其中<code>Unit.toStirng()</code>方法的复杂度更是高达<code>50</code>!!!分析原因，主要是因为<code>Unit</code>类中增加了<code>sin</code>,<code>cos</code>等新的数据成员，导致在输出时判断逻辑更为复杂，同时也直接导致了<code>Poly</code>类中进行<code>add</code>和<code>mul</code>运算时进行的操作也更为复杂。</p><h2 id="第三次作业分析">第三次作业分析</h2><p>第三次作业允许“函数实参可以是函数”，“三角函数括号中可以有任意因子”等多层嵌套行为，表达式复杂度达到了顶峰。</p><h3 id="代码uml类图-2">代码UML类图</h3><p>本次作业代码的UML类图如下所示</p><p><img src="3.png"></p><h3 id="代码架构分析-2">代码架构分析</h3><p>由于我第二次作业中<strong>已经实现了多层嵌套的功能</strong>，因此这次作业挑战并不是很大，除了一些修修补补的工作，我主要把精力放在了结果的优化上——</p><ul><li>二倍角优化：<span class="math inline">\(2sin(x)cos(x) =sin(2x)\)</span></li><li>平方和优化：<span class="math inline">\(sin(x)^2+cos(x)^2=1\)</span></li></ul><p>我在<code>Unit</code>类中重新增加了<code>simply()</code>方法和<code>trigMerge()</code>方法分别来实现上面两种优化，然后在<code>Poly</code>类的<code>addPoly()</code>和<code>mulPoly()</code>中调用这两种方法。</p><p>其实逻辑也很简单——</p><ul><li>在两个<code>Poly</code>相乘时，实际上就是两个<code>Poly</code>中<strong>任意两个<code>Unit</code>相乘后再相加</strong>，我们把两个<code>Unit</code>相乘后的结果用<code>simply()</code>方法进行简化。而<code>simply()</code>的逻辑就是在<code>Unit</code>的<code>sinMap</code>和<code>cosMap</code>中寻找可以进行二倍角合并的项进行合并。</li><li>在两个<code>Poly</code>相加，实际上就是两个<code>Poly</code>中所有<code>Unit</code>相加，我们使用<code>trigMerge()</code>方法进行判断两个<code>Unit</code>是否可以进行平方和优化。<code>trigMerge()</code>方法的逻辑是，如果两个<code>Unit</code>分别有<code>sin(expr)^2</code>和<code>cos(expr)^2</code>，且其他的数据成员都一样，那么就将这两个<code>Unit</code>合并</li></ul><p>虽然逻辑简单，但是实现后的代码还是十分复杂的）</p><h3 id="代码复杂度分析-2">代码复杂度分析</h3><p><strong>Method Metrics</strong></p><p><img src="P3dependecy.png"><br>果不其然，<code>simply()</code>方法和<code>trigMerge()</code>方法的复杂度还是超标了，甚至<code>simply()</code>的<strong>圈复杂度、基本复杂度和模块设计复杂度</strong>均爆红，这是三角函数化简本身的复杂性导致的（因为需要增加很多特判条件）。而且，由于在<code>Poly.addPoly()</code>方法和<code>Poly.mulPoly()</code>方法中也调用了<code>simply()</code>和<code>trigMerge()</code>，所以这两个方法的复杂度和上次作业相比也更高</p><h2 id="关于测试">关于测试</h2><h3 id="单元测试">单元测试</h3><p>每当写完一个(或几个)可以实现<strong>特定功能</strong>的类后，我会先在<code>test</code>文件夹下新建一个<strong>测试类</strong>，然后对这个（或这些）类的功能进行测试。如果测试没有问题，再去实现其他功能。</p><p>例如，在写完<code>Processer</code>类后，我新建了一个<code>TestProcesser</code>类，用来测试字符串的预处理功能是否正常；在写完<code>Lexer</code>和<code>Parser</code>类之后，我会建立一个<code>TestParser</code>类，测试是否将<code>Expr</code>,<code>Term</code>和<code>Factor</code>等正确的解析出来……<br><img src="test.png"></p><p>这是以前用<code>SprintBoot</code>开发后端时养成的习惯，这样做可以尽早将一些不必要的bug定位出来，减轻后期<strong>整体测试</strong>时的工作量。</p><p>其实，除了新建测试类，也可以<code>Junit</code>进行单元测试，只需要在<strong>“测试方法”</strong>开头写上<code>@Test</code>注解即可，非常方便。例如，我在<code>Definer</code>类中写了一个<code>test()</code>方法来测试函数的定义和调用功能是否符合预期，如下图所示<br><img src="junit.png"></p><h3 id="整体测试">整体测试</h3><p>当我们将整个项目写完后，需要对其进行完整、系统的测试，以确定我们的设计是否符合要求，输出是否合法。我主要采用了自动化随机测试的方法进行整体测试。</p><p>自动化测试是我写了两个文件——<code>generate.py</code>和<code>test.py</code></p><p><code>generate.py</code>是用来构造测试数据的，构造逻辑和我们解析表达式的逻辑相似，同样是采用了<strong>"递归下降"</strong>的思想。其中三个关键函数是<code>gener_E()</code>,<code>gener_T()</code>,<code>gener_F()</code>，大体结构如下所示（<strong>以下非完整代码，只提供答题思路</strong>）<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">gener_E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成Expr</span>    s <span class="token operator">=</span> gener_T<span class="token punctuation">(</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> RANGE<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        s <span class="token operator">+=</span> <span class="token string">"+"</span> <span class="token operator">+</span> gener_T<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> s <span class="token keyword">def</span> <span class="token function">gener_T</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成Term</span>    s <span class="token operator">=</span> gener_F<span class="token punctuation">(</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> RANGE<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        s <span class="token operator">+=</span> <span class="token string">"*"</span> <span class="token operator">+</span> gener_F<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token keyword">def</span> <span class="token function">gener_F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成Factor</span>    F_list <span class="token operator">=</span>  <span class="token punctuation">[</span>gener_F_num<span class="token punctuation">,</span> gener_F_pow<span class="token punctuation">,</span> gener_F_sin_cos<span class="token punctuation">,</span> gener_F_expr<span class="token punctuation">,</span> gener_F_sum<span class="token punctuation">,</span> gener_F_func<span class="token punctuation">]</span> <span class="token comment">#函数列表</span>    choice <span class="token operator">=</span> random<span class="token punctuation">.</span>randin<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>F_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> F_list<span class="token punctuation">[</span>choice<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">gener_F_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成数字因子</span>    <span class="token comment">#......</span><span class="token keyword">def</span> <span class="token function">gener_F_pow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成幂函数因子</span>    <span class="token comment">#......</span><span class="token keyword">def</span> <span class="token function">gener_F_sin_cos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成三角函数因子</span>    <span class="token comment">#......</span><span class="token keyword">def</span> <span class="token function">gener_F_sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成求和函数因子</span>    <span class="token comment">#......</span><span class="token keyword">def</span> <span class="token function">gener_F_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成自定义函数因子</span>    <span class="token comment">#......</span><span class="token keyword">def</span> <span class="token function">gener_F_expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment">#生成表达式因子</span>    <span class="token comment">#......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><code>test.py</code>主要用于测试，它首先运行<code>generate.py</code>来获取测试数据，然后运行我们的<strong>工程jar包</strong>（在IDEA中生成），将测试数据输入，获取化简后的结果。为了判断化简结果是否正确，我们可以使用<code>sympy</code>库进行判断。<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sympy<span class="token keyword">def</span> <span class="token function">judge_equal</span><span class="token punctuation">(</span>expr_in<span class="token punctuation">,</span>expr_out<span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment">#注意我们交给sympy库的表达式中不能存在前导0，我们可以手动处理</span>    simpy_in <span class="token operator">=</span> sympy<span class="token punctuation">.</span>core<span class="token punctuation">.</span>sympify<span class="token punctuation">(</span>del_zero<span class="token punctuation">(</span>expr_in<span class="token punctuation">)</span><span class="token punctuation">)</span>    simpy_out <span class="token operator">=</span> sympy<span class="token punctuation">.</span>core<span class="token punctuation">.</span>sympify<span class="token punctuation">(</span>expr_out<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>simpy_in<span class="token punctuation">.</span>equals<span class="token punctuation">(</span>simpy_out<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&gt;&gt;&gt;&gt;&gt;The comparison result is:"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"success!!!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&gt;&gt;&gt;&gt;&gt;The comparison result is:"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"failed!!!"</span><span class="token punctuation">)</span>        write_log<span class="token punctuation">(</span>ans<span class="token punctuation">,</span> expr_in<span class="token punctuation">,</span> expr_out<span class="token punctuation">,</span> simpy_in<span class="token punctuation">,</span> simpy_out<span class="token punctuation">)</span> <span class="token comment">#输出错误日志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此外，我还想补充一下<strong>在一个python文件中运行其他代码文件(python、Cpp...)的方法</strong><br>1. <code>os.system(cmd)</code><br>这个函数以<strong>命令</strong>为参数，可以直接运行我们输入的命令，将命令返回的结果在终端中显示出来<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"python generate.py"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>这个方法的缺点是无法直接获得命令运行后的结果，但是我们可以通过<strong>将运行结果重定向到文件</strong>来间接获得。<br>2. <code>os.popen(cmd, mode)</code><br>我觉得这个函数是<code>os.system()</code>的升级版，他将命令的运行结果以文件的形式返回，然后我们就可以通过读文件的方法获得运行结果了<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"python test.py"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>3. <code>subprocess.run(args, input, stdout, stderr)</code><br><code>args</code>实际上就是命令，只不过传入的是<strong>将命令的各个部分拆解后形成的列表</strong>（好像直接传入命令行字符串也是可以的orz），<code>input</code>是我们<strong>运行命令之后需要在终端输入的内容</strong>。以运行工程jar包为例——<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">cmd <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'-jar'</span><span class="token punctuation">,</span> <span class="token string">'Unit1_HW3.jar'</span><span class="token punctuation">]</span>data <span class="token operator">=</span> <span class="token string">"0\n"</span> <span class="token operator">+</span> <span class="token string">"sin(x**2)**2 + cos(x**2)**2"</span>p <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token operator">=</span>data<span class="token punctuation">,</span> stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span> stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token comment">#也可以写 p = subprocess.run("java -jar Unit1_HW3.jar", input=data, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding="UTF-8")</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span> <span class="token comment">#输出化简后的结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="bug分析">BUG分析</h2><p>不幸的是，本人在第三次作业的强测和互测中出现了bug，主要是<strong>三角函数平方和优化</strong>引起的。</p><p>当输入的数据为——<br></p><pre class="line-numbers language-none"><code class="language-none">0sin(x)**2+cos(x)**2+sin(1)**2+cos(1)**2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>本应该输出的是<code>2</code>,而我的输出确实是<code>1</code>,<strong>主要原因是</strong>，我在优化的时候，每加一个项就判断一下是不是可以进行三角合并，并将最终加的结果保存在<code>ArrayList</code>中。根据我的优化方法，加到最后<code>ArrayList</code>中有两个<code>1</code>；但是当我将<code>ArrayList</code>直接转化为<code>HashSet</code>时，由于两个项都是<code>1</code>，最后<code>HashSet</code>中只保存了一个<code>1</code>。<p></p><p>这个bug出现在<code>Poly</code>类的<code>addPoly()</code>方法中，此方法长达<code>50</code>余行，复杂度更是到达了<code>30</code>,这给我<strong>定位bug</strong>和<strong>修改bug</strong>带来了不小的困难。</p><p>这次惨痛的经历告诉我们——<strong>优化一定要慎重！！！</strong></p><h2 id="架构设计体验">架构设计体验</h2><p>在这三次作业中我并没有重构，主要得益于<strong>递归下降算法</strong>的天然优势和合理的<strong>需求预测</strong>。</p><p>首先，我并没有采用<strong>大正则</strong>来解析表达式，而是听从学长的建议果断选择了<strong>递归下降算法</strong>。这个算法在三次作业中都是适用的，我相信即使再增加因子类型，递归下降同样也可以解决。</p><p>其次，我在做每一次作业时，并<strong>不仅仅着眼于本次作业的要求</strong>，还对下次作业的要求进行一定预测，然后在coding的时候尽量关注代码的可扩展性，为下一次作业的迭代做好准备。</p><h2 id="心得体会">心得体会</h2><ul><li><strong>多多关注讨论区</strong>。当某个地方陷入死局时，阅读一下同学的思路和分享也许会让你豁然开朗。</li><li><strong>关注代码复杂度</strong>，尽量不要写太长的方法。即使不得不写，也要多加小心，因为很有可能有bug藏匿其中。</li><li><strong>优化时要慎重</strong>，正确性一定要放在第一位。</li><li><strong>注意测试的全面性</strong>。在测试的时候不能只进行随机测试，还要针对我们做的优化多测几组特殊数据。</li><li><strong>注意代码可扩展性</strong>。写代码时不仅仅要着眼于本次作业的要求，还需要思考下一次作业中可能会有哪些新的要求，为迭代开发做好准备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec4:static、const和运算符重载</title>
      <link href="/2022/03/21/c/cpp-progranming-lec-4/"/>
      <url>/2022/03/21/c/cpp-progranming-lec-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="static限定符">static限定符</h2><h3 id="static-local-variable">static local variable</h3><ul><li>静态局部变量的特点是”<strong>一次构造，永不析构，直到程序结束</strong>“。因此静态局部变量可以用来保值，这和全局变量行为相似）</li><li>静态变量放在<strong>全局变量区</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> i<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="static-function">static function</h3><ul><li>函数前用<code>static</code>修饰，表示此函数<strong>为本文件专用</strong>，其他文件无法<strong>进行访问</strong>。</li><li>函数默认是<strong>全局域</strong>，全局变量默认是<strong>文件域</strong>。<code>static</code>可将函数默认的全局域改为文件域<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//a.cpp</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//.......</span><span class="token punctuation">}</span><span class="token comment">//b.cpp</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错！！！</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>函数默认是<strong>全局域</strong>，全局变量默认是<strong>文件域</strong>，这也就说明为什么我们在使用外部变量（定义在其他文件的变量）前需要用<code>extern</code>进行声明，而使用外部函数是不需要(当然也是可以的)</p></blockquote><h3 id="static-data-member">static data member</h3><ul><li>类中可以定义静态变量，一次性初始化，所有对象共享。</li><li>类中的静态变量，<strong>既可以通过对象访问，也可以通过类名访问</strong>。</li><li>静态变量必须在类外进行初始化，而且只能初始化一次。</li><li>不能在构造函数中为静态变量赋值。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Static</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token function">Static</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-&gt;</span>j <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Static<span class="token double-colon punctuation">::</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Static <span class="token function">s1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span>i <span class="token operator">&lt;&lt;</span>s2<span class="token punctuation">.</span>i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="static-function-member">static function member</h3><ul><li>类中的静态函数，<strong>既可以通过对象访问，也可以通过类名访问</strong></li><li>静态函数中没有this指针</li><li>静态函数只能访问类中的静态变量，不能访问类的对象。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Static</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"static!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//通过对象调用</span>    Static s<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通过类名调用</span>    <span class="token class-name">Static</span><span class="token double-colon punctuation">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>设计模式：单例模式（<code>signleton</code>）<br>单例模式是指某个类全局只有一个对象,一个单例模式的例子如下——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Single</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> Single<span class="token operator">*</span> self <span class="token comment">//定义一个指向该类唯一对象的指针</span>   <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造函数私有化</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">static</span> Single<span class="token operator">*</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Single<span class="token operator">*</span> Single<span class="token double-colon punctuation">::</span>self <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Single<span class="token operator">*</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//获取这一对象</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       self <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> self<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   Single<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></blockquote><h2 id="const限定符">const限定符</h2><h3 id="const-parameter">const parameter</h3><ul><li>函数参数定义为const,则只能<strong>使用</strong>该参数的值，不能改变该参数，也不能将该参数作为左值(<code>l-value</code>)使用。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//error! 不能将(*p)作为左值使用，因为p指向的是const int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="const-data-member">const data member</h3><ul><li>在类中我们将数据成员定义为<code>const</code>，这样的数据成员只读。</li><li>对于<code>const</code>数据成员来说，初始化主要有以下两种方法——<ul><li>使用类内初始值</li><li>使用构造函数的初始化列表<br>如果同时使用以上两种方式，则已初始化列表中的值为最终初始化结果</li></ul></li><li>不能在构造函数和其他成员函数内部对<code>const</code>数据成员进行赋值！<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>&gt;早期C++中没有const datamember这种语法，党史如果要在类中定义常量，一般需要用枚举型<code>enum</code>。</li></ul><h3 id="const-function-member">const function member</h3><ul><li>一般来说，<code>const</code>对象是不可以调用函数的，这是为了防止函数会修改<code>const</code>对象中的值。但是如果真的需要其调用函数怎么办（前提是被调用的函数不能修改对象的值）？</li><li>我们可以将被调用的函数用<code>const</code>来限定，这样就可以让<code>const</code>对象调用该函数了。写法如下——<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//const限定符写在最后</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const function mumber!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> Student s<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以进行调用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="关于new和delete">关于new和delete</h2><ul><li><code>new</code>和<code>malloc</code>都可以用于<strong>动态申请堆空间来建立新对象</strong>。但是，<code>new</code>一个对象时会调用该类的构造函数，而<code>malloc</code>不会。因此，<code>new</code>和<code>malloc</code>有以下关系——<br><span class="math display">\[new = malloc + construction\]</span></li><li>同理，<code>delete</code>和<code>free</code>也有相似的关系。（注意：<code>destruction</code>应该在<code>free</code>前面）<br><span class="math display">\[delete = destruction + free\]</span></li></ul><h2 id="运算符重载">运算符重载</h2><p>一般情况下, <code>+</code>, <code>-</code>, <code>*</code>,<code>++</code>,<code>[]</code>等运算符只能作用于基本类型,不能作用于对象。但是，我们可以在类中对这些运算符进行重载，这样我们就可以将运算符应用于对象了。重载运算符的写法如下——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>返回值类型<span class="token punctuation">]</span> <span class="token keyword">operator</span> <span class="token punctuation">[</span>运算符<span class="token punctuation">]</span><span class="token punctuation">(</span> 形参表<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>下面以<code>+</code>,<code>++</code>两个运算符为例，介绍一下具体的写法——<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> balance<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Account</span><span class="token punctuation">(</span><span class="token keyword">int</span> balance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//重载运算符，返回自身的引用</span>    Account<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>     Account<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//前++</span>    Accoutn <span class="token keyword">operator</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//后+++</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Account</span><span class="token double-colon punctuation">::</span><span class="token function">Account</span><span class="token punctuation">(</span><span class="token keyword">int</span> balance<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>balance <span class="token operator">=</span> balance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Account</span><span class="token double-colon punctuation">::</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>balance <span class="token operator">+=</span> money<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//重载运算符+</span>Account<span class="token operator">&amp;</span> Account<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">save</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//重载运算符++*(前自加)</span>Account<span class="token operator">&amp;</span> Account<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token operator">++</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token operator">-&gt;</span>balance<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span>；<span class="token punctuation">}</span><span class="token comment">//重载运算符++*(后自加)</span>Account Account<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     Account early <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>balance<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> early<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>++</code>这个运算符比较玄学，因为既可以<strong>前自加</strong>，还可以<strong>后自加</strong>。<strong>前自加</strong>我们可以直接使用<code>Object&amp; operator ++{}</code>来进行定义。<strong>后自加</strong>为了与之区分，使用了一个<code>int</code>作为占位参数,即使用<code>Object&amp; operator ++(int) {}</code>来进行定义（注意只能是<code>int</code>，不能是<code>char</code>或者其他）。<p></p><p>注意在后自加的函数定义中，有一句是<code>Account early = *this;</code>,这句话实际上<strong>是通过传值来进行拷贝</strong>，会默认调用一个<strong>拷贝构造</strong>（在上一节课的笔记中讲过）。本来，这种写法是不推荐的，但是，为了配合后自加"<strong>先返回原值，再自加</strong>"这一变态的要求，我们又不得不这样写……</p><hr><blockquote><p>作业：使用SQLite，实现一个借书、还书的流程。<br>ORMapping</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-OS」 Lab0：Linux基础操作</title>
      <link href="/2022/03/21/os/os-lab0-shi-yan-bao-gao/"/>
      <url>/2022/03/21/os/os-lab0-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验思考题">实验思考题</h2><h3 id="thinking-0.1">Thinking 0.1</h3><p><strong>Q：</strong> <strong>使用 cat Modified.txt ，观察它和第一次add 之前的 status 一样吗，思考一下为什么？</strong><br><strong>A：</strong>这两个status不一样。第一次add之前是的status是<code>Untracked files</code>,修改README.txt之后的status是<code>Changes not staged for commit</code>，并提示<code>modified: README.txt</code>。<br>原因是，第一次add之前我们刚刚在工作区新建README.md文件，该文件没有被add过，即在暂存区中没有README.txt,所以显示该文件没有被追踪（<code>untracked</code>）。而修改README.txt后，这时候在工作区和暂存区都存在file，即该文件已被追踪到，因此会显示该文件已被修改（<code>mofified</code>）而不是<code>untracked</code>。</p><h3 id="thinking-0.2">Thinking 0.2</h3><p><strong>Q：</strong> <strong>思考一下箭头中的<code>add the file</code> 、 <code>stage the file</code>和<code>commit</code> 分别对应的是 Git 里的哪些命令呢？</strong><br><img src="git.png"><br><strong>A：</strong> <code>add the file</code>对应得是<code>git add</code>和<code>git commit</code>,表示新建的文件被加入暂存区，并加入到本地版本库。<code>staged the file</code>对应的也是<code>git add</code>，表示的是把在版本库中有备份的，且已被修改的文件加入暂存区。<code>commit</code>对应的是<code>git commit</code>表示的是将暂存区中的文件加入本地版本库。</p><h3 id="thinking-0.3">Thinking 0.3</h3><p><strong>Q1：</strong><strong>困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。你该怎样帮他把代码文件恢复呢？</strong><br><strong>A1：</strong>此时小明没有把修改<code>add</code>到暂存区，只需要使用<code>git checkout -- printf.c</code>即可恢复。</p><p><strong>Q2：</strong> <strong>小红很爽快地在键盘上敲下了<code>git rm printf.c</code>，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？</strong><br><strong>A2：</strong>此时小红把暂存区中的printf.c也删去了，只需要<code>git reset HEAD printf.c</code>命令即可将文件在暂存区中恢复，然后再<code>git checkout -- printf.c</code>即可。</p><p><strong>Q3：</strong> <strong>突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被 git commit指令提交到版本库？</strong><br><strong>A3：</strong>我们只需要使用<code>git rm --cached Tucao.txt</code>命令即可将暂存区里的Tucao.txt中删除。</p><h3 id="thinking-0.4">Thinking 0.4</h3><p><strong>Q：</strong><strong>对<code>git reset --hard</code>使用的理解？</strong><br><strong>A：</strong><code>git reset --hard</code>实际上是用来改变当前的仓库状态，使用该指令，我们可以将当前仓库的状态变为以前任一次<code>commit后的状态</code>，即可以实现版本回退。此时我们既可以使用<code>git reset --hard HEAD^</code>也可以使用<code>git reset --hard &lt;Hash-code&gt;</code>。hashcode我们需要通过<code>git log</code>指令获取。<br><code>git reset --hard</code>可退也可回。我们只需要记住后面某一次commit时的hashcode，再通过<code>git reset --hard &lt;Hash-code&gt;</code>即可从未来会到现在</p><h3 id="thinking-0.5">Thinking 0.5</h3><p><strong>Q：</strong><strong>指出下面的描述哪些正确那些错误——</strong><br><strong>1. 克隆时所有分支均被克隆，但只有 HEAD指向的分支被检出。</strong><br><strong>2. 克隆出的工作区中执行 git log、 git status、 git checkout、git commit 等操作不会去访问远程版本库。</strong><br><strong>3. 克隆时只有远程版本库 HEAD 指向的分支被克隆。</strong><br><strong>4. 克隆后工作区的默认分支处于 master 分支。</strong></p><p><strong>A：</strong><br><strong>1.正确。</strong>我们可以做一个实验。首先我们可以在家目录下新建一个文件夹learnGit，然后进入该文件夹。在该文件夹下使用命令<code>git clone git@git.os.buaa.edu.cn:os2022/20373379.git</code>之后我们可以在看到出现了新文件夹20373379。</p><p><img src="git%20clone.png"></p><p>之后我们进入该文件夹，使用<code>git branch -a</code>查看当前所有分支——</p><p><img src="git%20branch.png"><br>从中可以发现，本地分支(绿色)只有<code>main</code>被检出。虽然其他分支没有出现，但我们实际上已经将其clone下来了，只需要使用<code>git checkout</code>命令即可将其检出。例如我们使用<code>git checkout lab0</code>，<code>lab0</code>分支即可被检出。</p><p><strong>2.正确。</strong>在<code>git</code>中，只有<code>git pull</code>，<code>git push</code>,<code>git remote</code>等命令和远程库有关。</p><p><img src="git%20checkout.png"></p><p><strong>3.错误。</strong> 解析同第一问。<br><strong>4.正确。</strong>我们在第一问的实验中已经发现，当我们刚刚克隆时，<code>HEAD</code>指向的是远程仓库中的默认分支，即<code>main</code>。实际上<code>main</code>和<code>master</code>是一样的意思，只不过是远程仓库默认分支的两种叫法。</p><h3 id="thinking-0.6">Thinking 0.6</h3><p><strong>Q：</strong> <strong>执行如下命令, 并查看结果</strong></p><ul><li><strong>echo first</strong></li><li><strong>echo second &gt; output.txt</strong></li><li><strong>echo third &gt; output.txt</strong></li><li><strong>echo forth &gt;&gt; output.txt</strong></li></ul><p><strong>A：</strong>命令执行结果如下（对于重定向的命令，我们使用<code>cat</code>来查看<code>output.txt</code>中的结果）</p><p><img src="echo.png"></p><h3 id="thinking-0.7">Thinking 0.7</h3><p><strong>Q：</strong><strong>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为test），将创建该文件的命令序列保存在command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至result 文件中。给出 command 文件和result文件的内容，并对最后的结果进行解释说明（可以从 test文件的内容入手） . 具体实现的过程中思考下列问题:<code>echo echo Shell Start</code> 与<code>echo ‘echo Shell Start’</code> 效果是否有区别;<code>echo echo $c&gt;file1</code> 与<code>echo ‘echo $c&gt;file1’</code> 效果是否有区别.</strong></p><p><img src="thinking0.6.png"></p><p><strong>A：</strong> <strong>command</strong>文件中的内容为</p><p><img src="command.png"></p><p><strong>result</strong> 文件中的内容为</p><p><img src="result.png"></p><p><strong>结果分析</strong>：我们在test中先将a和b分别赋值为1和2，然后令c等于a与b的和，即c的结果为.我们将c，b，a的值分别写入file1、file2、<br>file3，此时这三个文件中的值分别为3, 2,1。然后我们使用cat将这三个文件的值 <strong>追加</strong>写入file4，再把file4中的内容写入result。因此result中的值为3, 2, 1。</p><p>在实验过程中我们还发现，<code>echo echo Shell Start</code> 与<code>echo ‘echo Shell Start’</code> 效果是没有区别的；<code>echo echo $c&gt;file1</code> 与<code>echo ‘echo $c&gt;file1’</code> 效果是有区别的，前者会将"echo$c"重定向到file1，而后者会将"echo$c&gt;file"这一字符串在终端中显示。</p><h2 id="实验难点图示">实验难点图示</h2><p>我认为该实验的难点主要包含以下难点——<strong>git的使用（撤销、版本回退和本地远程同步）、三种文件操作命令的使用（awk、grep、sed）、shell脚本中不同括号的用法。</strong></p><p><img src="实验难点.png"></p><h2 id="体会与感想">体会与感想</h2><p>Lab0主要让我们学习如何使用Linux控制终端来进行文件操作，实验任务难度不大，我花费的时间约六七个小时左右，其中大部分都是在学习新的命令和新的用法。因为指导书所提供的学习内容比较局限，在一些常用的命令介绍上也仅仅是抛砖引玉（例如awk，sed等），所以许多重要的用法还需要在google上查找资料自学。</p><p>终端操作和以往在可视化界面上进行的操作不同，一开始面对这些陌生的命令，以及让人迎接不暇的各种参数，我还并不是很适应，甚至有些望而生畏的感觉。但当我多次在shell里使用后，这些命令逐渐变得熟悉，使用起来也更加得心应手。正如荣文戈老师说的那样——“<strong>程序员的提高是一种体力活</strong>”，诚哉斯言！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec3:引用和拷贝构造</title>
      <link href="/2022/03/20/c/cpp-progranming-lec-3/"/>
      <url>/2022/03/20/c/cpp-progranming-lec-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引用reference">引用（reference）</h2><ul><li><p>引用是一个更安全的指针（a safe pointer),借值之名，行指针之实，实际上表示的是地址。</p></li><li><p>引用必须初始化, 和C语言中<strong>野指针</strong>不同</p><p></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//error</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>引用是常量，一旦定义，不可以再修改。与之不同，指针可以先后指向不同对象。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">//error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li><li><p>引用不可以完全取代指针，例如在<code>malloc</code>和<code>new</code>中返回值只能是指针。</p></li></ul><blockquote><p><strong>补充：内存分区问题</strong></p><ul><li><strong>代码区</strong>：储存我们写的代码，只读常量，无法修改。</li><li><strong>全局变量区（静态区）</strong>：在程序运行开始，程序在内存中开辟一段区域，把这段区域全部置为0，用于存储全局变量。这也是就为什么全局变量不初始化值自动变为0。全局变量的初始化在main函数运行之前。</li><li><strong>运行内存区（runtime memory）</strong>：包括栈区和堆区<ul><li>栈区：用于局部变量<ul><li>栈区内存是连续的</li></ul></li><li>堆区：用于动态内存分配（<code>malloc</code>和<code>new</code>时）。<ul><li>堆区内存是离散的，理论上来无限次使用<code>malloc</code>会导致程序崩溃</li><li>应用场景：1.不能确定内存分配大小需要在运行时确定（例如链表建立）；2.需要人为控制变量的生命周期。</li></ul></li></ul></li></ul></blockquote><h2 id="拷贝构造">拷贝构造</h2><p>C++的类默认支持用一个已存在的类初始化一个新建的类。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>C++中有拷贝有两种类型——</p><ul><li><code>bitwise copy</code>（浅拷贝）</li><li><code>logical copy</code>（深拷贝）</li></ul><p>拷贝构造时默认是<strong>浅拷贝</strong>，即把对象<code>a</code>所在内存空间中所有数据<strong>以字节的形式</strong>拷贝给新建的b对象。如果a对象中有指针成员，则<strong>只会把指针的值拷贝给<code>b</code></strong>，这样会出现<code>a</code>,<code>b</code>两个对象的指针成员指向同一块内存。（编译时不报错，非常恐怖！！！）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> ai<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> ai<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>a <span class="token operator">=</span> ai<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>bi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student <span class="token function">mem1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student <span class="token function">mem2</span><span class="token punctuation">(</span>mem1<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> mem1<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span> <span class="token operator">&lt;&lt;</span> mem2<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//两者指针值值一样的，即值指向同一块内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种情况，我们需要自定义一个拷贝构造函数从而实现<strong>深拷贝</strong>，主要写法为<code>Object::Object(const Object &amp;a) {}</code>,具体例子如下所示<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> ai<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student <span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student <span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>a<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student <span class="token function">mem1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student <span class="token function">mem2</span><span class="token punctuation">(</span>mem1<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> mem1<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span> <span class="token operator">&lt;&lt;</span> mem2<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//这样两者指针值就是不一样的了</span>    <span class="token function">func</span><span class="token punctuation">(</span>mem1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在C/C++中，“<strong>只要传值，就是一次拷贝构造</strong>”，当我们向一个函数传递<strong>实参</strong>，且这个函数的<strong>形参不是引用类型</strong>，此时程序会自动调用<strong>实参类型的拷贝构造函数</strong>。例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> ai<span class="token punctuation">,</span> <span class="token keyword">int</span> bi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student <span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student <span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用自定义拷贝构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>a <span class="token operator">=</span> s<span class="token punctuation">.</span>a<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Student s<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"实参调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">func</span><span class="token punctuation">(</span>mem1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**以上程序执行结果为——调用自定义拷贝构造函数实参调用/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p><strong>什么使用需要深拷贝？？？</strong></p><ul><li>类构造函数中有new（说明有指针成员），一定要深拷贝！</li><li>构造函数中没有new也不一定不需要深拷贝，有可能在其他位置出现new或者malloc</li></ul></blockquote><h2 id="函数参数问题">函数参数问题</h2><ul><li><strong>Pass by value ？</strong></li><li><strong>Pass by address ？</strong></li></ul><p>传值和传地址在功能、性能和其他方面的比较如下——</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th style="text-align: center;">Item</th><th style="text-align: center;">传值</th><th style="text-align: center;">传地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>功能</strong></td><td style="text-align: center;">函数只能input，即只能使用实参的值，不能改变实参的值</td><td style="text-align: center;">函数既能input也能output，即不仅可以使用实参的值，也可以改变实参的值</td></tr><tr class="even"><td style="text-align: center;"><strong>性能</strong></td><td style="text-align: center;">需要传递<code>sizeof(value)</code>大小的数据</td><td style="text-align: center;">只需要传递<code>sizeof(int)</code>大小的数据</td></tr><tr class="odd"><td style="text-align: center;"><strong>其他</strong></td><td style="text-align: center;">只要传值，就需要调用一次拷贝构造</td><td style="text-align: center;">无</td></tr></tbody></table><p><strong>结论</strong>：不要使用<code>pass by value</code>!!!</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec2:C++的类</title>
      <link href="/2022/03/10/c/cpp-progranming-lec-2/"/>
      <url>/2022/03/10/c/cpp-progranming-lec-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="c面向对象">C++面向对象</h2><ul><li>封装（一个类）</li><li>继承（多类之间的父子关系）</li><li>多态（行为关系）</li></ul><h2 id="c结构体---c类">C结构体---&gt;C++类</h2><p>C语言<strong>只可以封装</strong>，<code>struct</code>关键字可以建立结构体</p><ul><li>结构体的最小内存单元以内存最大的成员类型为准<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">double</span> d<span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// sizeof(struct Student) 结果为24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>#pragma pack(1)</code>可强制对齐</li></ul><p>C语言中结构<strong>仅包含成员变量</strong>，与结构有关的函数均独立于结构之外（结构很散！<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Student <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    s<span class="token operator">-&gt;</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>C++在结构体中可以<strong>有成员变量和函数</strong>（attribute datamember + funct member)<p></p><ul><li><p><code>this</code>指针永远自动的指向调用对象。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>C++的结构体把<code>struct</code>改为<code>class</code>,结构体就变成了类</strong>。<p></p></li><li><p>类本身不占用内存空间，只是占用代码空间</p></li></ul><h2 id="c类的特性">C++类的特性</h2><h3 id="访问控制-access-control"><strong>访问控制 </strong>（accesscontrol）****</h3><ul><li>private</li><li>public</li><li>protested<br>通常情况下，需要把成员变量变为private, 函数一般为public；<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//可以省略</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//setter and getter;</span>    <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>struct默认全部共有，class默认全部私有</p></blockquote><h3 id="构造函数constructor">构造函数（<strong>constructor</strong>）</h3><p>初始化尤为重要，每创建一个对象必须初始化；于是我们引入了构造函数;防止调用者不初始化直接调用（constructor），<strong>与类同名，可以传任意参数，没有返回值</strong>。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//setter and getter;</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>类中默认有一个构造函数，于类同名， 没有参数，称为<strong>默认构造函数（defaultconstructor）</strong>。如果我们定义了一个构造函数，则默认构造函数自动会消失。构造函数的调用发生在对象创建之时。<br>有两种写法——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Student <span class="token function">s</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"hyggge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Student <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"hyggge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>一定要注意，如果想要通过默认构造函数或者无参构造函数来实例化对象，以下写法是错误的<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Student <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>Student s<span class="token punctuation">;</span> <span class="token comment">// right</span>Student <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// right</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>临时变量和函数参数在桟上，malloc和new建立在堆区，全局变量建立在静态存储区</p></blockquote><h3 id="析构函数destructor"><strong>析构函数（</strong>destructor<strong>）</strong></h3><p>类中可以定义一个析构函数，开头为<code>~</code>，与类同名,无参数，无返回值。一个类中最多<strong>只有一个析构函数</strong>，如果不定义的话，默认调用<strong>缺省析构函数</strong>。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"generate"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"disappear"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>栈区普通对象会自己主动执行析构函数，而堆区的指针对象不会</strong>。就算运行到主函数结束（<code>return</code>之前）,指针对象的析构函数也不会被执行，只有<code>delete</code>才可以触发析构函数。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student s<span class="token punctuation">;</span> <span class="token comment">//自动执行</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">//只有执行了这一句，才会调用析构函数。</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>当我们在类中有指针变量时，我们需要在自定义的析构函数中<strong>主动为指针变量释放空间</strong>（通过delete实现）。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"generate"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">delete</span> name<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"disappear"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>判断：<br>析构函数可以有多个版本？ No</p></blockquote><hr><blockquote><p>作业：<br>自学udp socket:"hello world"<br>思考类的属性<br>构造例子：构造和析构</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ECS服务器」文件传输和新终端建立</title>
      <link href="/2022/03/04/ecs/ecs-fu-wu-qi-shi-yong-wen-jian-chuan-shu-he-xin-zhong-duan-jian-li/"/>
      <url>/2022/03/04/ecs/ecs-fu-wu-qi-shi-yong-wen-jian-chuan-shu-he-xin-zhong-duan-jian-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇博客介绍一下如何使用<strong>pscp</strong>在本地（Windows）和ECS服务器之间进行文件传输，以及如何在服务器中建立新终端。</p><h2 id="前言">前言</h2><p>今天想把OO第一次作业的自动评测程序放到在阿里云ECS服务器上运行，以减轻笔记本CPU的压力（<del>避免过早更换电脑</del>）。但是理想很丰满，现实很骨感，在一开始便遇到了两个问题——</p><ul><li><strong>如何将本地的文件传到服务器上？</strong></li><li><strong>如何使程序在服务器后台运行？</strong>（一旦关闭服务器前端网页，在当前终端中运行的程序会被中断）</li></ul><p>通过查找资料和请教同学，最终让我找到了解决方案，用本篇博客记录一下。</p><h2 id="文件的传输">文件的传输</h2><p>ECS服务器和本地进行文件传输的方法有很多，主要有以下几种——</p><ul><li><strong>使用Windows中自带的“远程桌面连接”</strong></li><li><strong>通过QQ软件，邮箱等第三方工具进行间接传输</strong></li><li><strong>pscp</strong></li></ul><p>前两种方法相对比较复杂，第三种较为简单，只需要安装pscp软件，即可在cmd中通过命令实现两者之间的文件传输。</p><h3 id="软件的安装">软件的安装</h3><p>在一般情况下，pscp会和putty软件捆绑安装，我们可以直接在putty的安装目录下找到<code>pscp.exe</code>文件。此外，我们还可以在putty官网中单独下载pscp(<a href="https://the.earth.li/~sgtatham/putty/latest/w64/pscp.exe">下载地址</a>)。</p><p>接下来，我们需要将<code>pscp.exe</code>文件放在<code>C:\Windows\system32\</code>路径下。然后在命令行中运行命令<code>pscp</code>,如果终端有以下输出，就说明pscp配置成功了。</p><p><img src="pscp.png"><br>接下来，我们就可以快乐地<strong>通过命令行使用pscp</strong>了。（所以是不是很简单？</p><h3 id="常用命令">常用命令</h3><p>只需要掌握以下pscp命令，即可实现一般的文件传输需求</p><h4 id="将本地文件复制到服务器">将本地文件复制到服务器</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp [file_path] [ECS_user_name]@[ECS_ip]:[target_path]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想把桌面上的<code>test.txt</code>传到服务器<code>root/file</code>文件夹下，命令可以写为<br></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp C:\Users\dell\Desktop\test.txt root@10.10.10.10:/root/file/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h4 id="将本地文件夹和文件夹下的文件复制到服务器">将本地文件夹和文件夹下的文件复制到服务器</h4><p>只需要在<code>pscp</code>后面加入<code>-r</code>即可<br></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp -r [dir_path] [ECS_user_name]@[ECS_ip]:[target_path]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>如果想把桌面上的<code>test</code>文件夹传到服务器<code>root/file</code>文件夹下，命令可以写为<br><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp -r C:\Users\dell\Desktop\test root@10.10.10.10:/root/file/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h4 id="将远程服务器中的文件复制到本地">将远程服务器中的文件复制到本地</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp [ECS_user_name]@[ECS_ip] [ECS_file_path] [targt_path]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想把服务器<code>root/file</code>文件夹中<code>test.txt</code>传到本地<code>desktop</code>上，命令可以写为<br></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp root@10.10.10.10:/root/file/test.txt C:\Users\dell\Desktop\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h4 id="将远程服务器中的文件夹和文件夹下的文件复制到本地">将远程服务器中的文件夹和文件夹下的文件复制到本地</h4><p>同样，只需要在<code>pscp</code>后面加入<code>-r</code>即可<br></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp -r [ECS_user_name]@[ECS_ip] [ECS_file_path] [targt_path]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>如果想把服务器<code>root/file</code>文件夹传到本地<code>desktop</code>上，命令可以写为<br><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pscp -r root@10.10.10.10:/root/file/ C:\Users\dell\Desktop\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><hr><p>补充：后来我又发现了一个<strong>有UI界面</strong>的文件传输软件——<code>WinSCP</code>（<a href="https://winscp.net/eng/docs/lang:chs">下载地址</a>）这个软件可以直接通过鼠标拖动来复制文件，比命令行快太多了，效果如下图所示。<br><img src="WinSCP.png"></p><h2 id="建立新终端">建立新终端</h2><p>为了使程序能够在服务器后台运行，我们可以先建立一个新终端，在这个新终端下运行我们的程序，然后暂时退出该终端即可。这样，即使服务器前端网页关闭，我们建立的新终端也不会被中断，我们的程序也会正常运行。常用命令如下——</p><ul><li>建立新终端 <code>screen -S [terminal_name]</code></li><li>暂时退出新终端 <code>Ctrl+A+D</code></li><li>查看已经创建的终端 <code>screen -ls</code></li><li>进入已创建的终端 <code>screen -r [terminal_id]</code>(中端的id可以在<code>screen -ls</code> 中看到)</li><li>关闭新终端 <code>exit</code></li></ul><p>如果shell提示<code>screen</code>命令不存在，可以输入下面的命令进行安装<br></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">//第一种方法yum install screen//第二种方法apt install screen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> ECS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-C++」Lec1:C++函数的特性和常用的宏</title>
      <link href="/2022/03/02/c/cpp-programing-lec-1/"/>
      <url>/2022/03/02/c/cpp-programing-lec-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="c函数">C++函数</h2><h3 id="函数重载overloading">函数重载(overloading)</h3><ul><li>函数重载就是<strong>允许在同一作用域中声明几个类似的同名函数</strong>，这些同名函数的形参列表（参数个数，类型，顺序）必须不同，即“<strong>同名函数，不同参数</strong>”，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>“<strong>同名函数，相同参数，返回值不同</strong>”不能成为重载函数，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>也就是说，不能通过返回值类型区分同名函数</li></ul><h3 id="默认参数default-parameter">默认参数(default parameter)</h3><ul><li>在C++函数中，可以为函数的形参设定一个默认值，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>函数调用时，如果需要使用默认参数，那么该位置<strong>不传参</strong>即可，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">funct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用默认参数 k = 3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>注意：</strong><ol type="1"><li><strong>“默认”之后必须“默认”</strong>，也就是说，如果一个形参使用的默认参数，则它后面的形参也必须使用默认参数。例如下面的写法是不允许的<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">funct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//本意是想仅使用形参b=2，但是这样写是不允许的</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>头文件中定义了默认参数，则源文件中不允许再次定义，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*.h文件*/</span><span class="token keyword">void</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*.cpp文件*/</span><span class="token keyword">void</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误，重新定义的默认参数</span><span class="token keyword">void</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><h3 id="占位参数">占位参数</h3><p>占位参数就是，函数<strong>声明或定义</strong>时，某个形参只有类型声明，而没有参数名。</p><ul><li><p>一种情况是，<strong>函数在声明时有占位参数，而定义时补全了这个占位参数的名字</strong>，这样函数体内部时可以使用这个参数的。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//声明</span><span class="token keyword">int</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token comment">//定义</span><span class="token keyword">int</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>另一种情况是，函数的定义中仍然有占位参数，那么<strong>函数体内部是无法使用占位参数的</strong>（没有名字怎么使用？）。但即使不能使用，在函数调用是占位参数也必须填补（<del>流氓行为</del>）。<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//虽然这个3没有什么用，但是也要加上</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>当然可以在占位参数那里运用<strong>默认参数</strong>，这样在调用函数是就可以不用补全占位参数了。（但是好像并没有什么用...）<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//虽然这个3没有什么用，但是也要加上</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><h2 id="宏macro">宏(macro)</h2><ul><li><strong>常量宏</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.14</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><strong>宏函数</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ARRAY_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ADD</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>预编译控制宏</strong><br>一种是类似于<code>if-else</code>的写法，以<code>#if</code>,<code>#ifdef</code>,<code>#ifndef</code>开头，<code>elif</code>和<code>else</code>作为衔接，以<code>#endif</code>作为结尾<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>还有其他常用的宏，可以见叶焯仁学长的<a href="https://coekjan.github.io/2021/03/28/Preprocessing-Directive/">博客</a>。</li></ul><h3 id="头文件的写法">头文件的写法</h3><p>为了解决重复包含的问题，我们可以采用预编译宏来进行控制。以满足<code>one-defination rule</code>的原则。头文件的常用写法如下——<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*my.h文件*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MY_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MY_H</span> </span><span class="token comment">//头文件体</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样就可以保证头文件只被包含一次。<p></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Maven」生命周期与插件</title>
      <link href="/2022/01/25/maven/maven-sheng-ming-zhou-qi-yu-cha-jian/"/>
      <url>/2022/01/25/maven/maven-sheng-ming-zhou-qi-yu-cha-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="生命周期与插件.png"></p><hr><h2 id="maven项目构建的生命周期">Maven项目构建的生命周期</h2><p>Maven的生命周期就是为<strong>了对所有的构建过程进行抽象和统一</strong>，这个生命周期包含了项目的<strong>清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成</strong>等几乎所有构建步骤，由相互独立三套生命周期组成——</p><ul><li><strong>clean</strong>：清理项目</li><li><strong>default</strong>：构建项目</li><li><strong>site</strong>：构建项目站点</li></ul><p>当执行某一独立的生命周期的一个阶段时，实际上<strong>在该阶段之间</strong>的、<strong>和该阶段在同一生命周期</strong>的<strong>其他阶段</strong>也会被执行。</p><h3 id="clean生命周期">clean生命周期</h3><p>clean生命周期包含<strong>三个阶段</strong>：</p><ul><li><strong>pre-clean</strong>：执行一些清理前需要完成的工作；</li><li><strong>clean</strong>：清理上一次构建生成的文件；</li><li><strong>post-clean</strong>：执行一些清理后需要完成的工作；</li></ul><h3 id="default生命周期">default生命周期</h3><p><code>default</code>生命周期定义了真正构建项目需要执行的所有步骤，它是所有生命周期中最核心的部分</p><ul><li>validate（校验）</li><li>initializer（初始化）<br></li><li>generate-sources（生成源代码）<br></li><li>process-sources（处理源代码）<br></li><li>generate-resources（生成资源文件）<br></li><li>process-resources（处理资源文件）</li><li><strong>compile（编译项目的源码，一般来说编译的是src/main/java目录下的java文件至项目输出的主classpath目录中）</strong><br></li><li>process-classes（处理类文件）<br></li><li>generate-test-sources（生成测试源代码）<br></li><li>process-test-sources（处理测试源代码）</li><li>generate-test-resources（生成测试资源文件）</li><li>process-test-resources（处理测试资源文件）<br></li><li><strong>test-compile（编译测试源代码到目标目录）</strong></li><li>process-test-classes（处理测试类文件）</li><li><strong>test（测试）</strong><br></li><li>prepare-package（准备打包）</li><li><strong>package（打包， 把编译好的代码打包成可发布的格式，如JAR，WAR，EAR）</strong><br></li><li>pre-integration-test（集成测试前）<br></li><li>integration-test（集成测试）<br></li><li>post-integration-test（集成测试后）<br></li><li>verify（验证）<br></li><li><strong>install（安装项目包本地仓库，这样项目包可以做其他本地项目的依赖）</strong><br></li><li>deploy（部署，将最终的包复制到远程的仓库，以让其它开发人员与项目共享。）</li></ul><h3 id="site生命周期">site生命周期</h3><p><code>site</code>生命周期的目的是建立和发布项目站点，maven能够基于pom文件所包含的项目信息，自动生成一个友好站点，方便团队交流和发布项目信息。</p><ul><li><strong>pre-site</strong>：执行一些需要在生成站点文档之后完成的工作</li><li><strong>site</strong>：生成项目的站点文档</li><li><strong>post-site</strong>：执行一些需要在生成站点文档之后完成的工作，并为部署作准备</li><li><strong>site-deploy</strong>：将生成的站点文档部署到特定服务器上</li></ul><h2 id="插件">插件</h2><p><strong>插件与生命周期内的阶段相绑定</strong>，到执行对应的生命周期时执行对应的插件功能（<strong>每个生命周期的行为靠插件实现</strong>）。在默认情况下，maven在各个生命周期上绑定有预设的功能，我们也可以<strong>使用插件自定义其他的功能</strong>，使用插件需要在<code>pom.xml</code>中做以下配置<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-site-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.7.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!-- 执行行为的配置 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>          <span class="token comment">&lt;!-- 执行的工作/目标 --&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>          <span class="token comment">&lt;!-- 执行的生命周期 --&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">&gt;</span></span>generate-test-resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>查找插件的<a href="https://maven.apache.org/plugins/index.html">官网</a>为：https://maven.apache.org/plugins/index.html<p></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Maven」依赖与依赖管理</title>
      <link href="/2022/01/25/maven/maven-yi-lai-yu-yi-lai-guan-li/"/>
      <url>/2022/01/25/maven/maven-yi-lai-yu-yi-lai-guan-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pom.xml文件中的依赖声明">pom.xml文件中的依赖声明</h2><p>所有的依赖写在<code>&lt;dependnecies&gt;</code>框架中，每当声名一个新的依赖时，需要新建一个<code>&lt;dependnecy&gt;</code>，中间至少包含三个内容——<code>groupId</code><code>artifactId</code> <code>version</code>,可以直接在<a href="https://mvnrepository.com/">官网</a>中查找。<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体的依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--依赖所属群组id--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--依赖所属项目id--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--依赖版本号--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="依赖管理">依赖管理</h2><h3 id="依赖传递">依赖传递</h3><ul><li><strong>直接依赖：</strong>在当前项目中通过<strong>依赖配置</strong>建立的依赖关系（直接在<code>pom.xml</code>中配置的依赖）</li><li><strong>间接依赖：</strong>当被依赖的资源如果依赖其他资源，则当前项目<strong>间接依赖</strong>其他的资源。例如项目A依赖资源B，资源B又依赖资源C，则A间接依赖C……以此类推，类似于继承。</li></ul><h3 id="冲突问题的解决">冲突问题的解决</h3><p>如果一个项目<strong>直接和间接依赖的资源中</strong>有相同的（版本号不要求相同），则会产生冲突。冲突的解决依赖于以下三个原则——</p><ul><li><strong>路径优先</strong>：当依赖中出现相同的资源时，层级越深则优先级越低，层级越浅则优先级越高——即<strong>遵循就近原则</strong>。</li><li><strong>声明优先</strong>：当资源在相同层级被依赖时，<strong>配置顺序靠前</strong>的覆盖<strong>配置顺序靠后</strong>的。</li><li><strong>特殊优先</strong>：当同级配置了相同资源的不同版本，<strong>后配置的覆盖先配置的</strong></li></ul><h3 id="可选依赖">可选依赖</h3><p>可选依赖是指<strong>对外隐藏当前所依赖的资源</strong>。例如，项目A依赖了资源B，资源B依赖了资源C，但是B对C的依赖时被隐藏的，那么项目A不会间接依赖资源C。</p><p>可选依赖的设置方法如下——<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体的依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--可选依赖选项 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="排除依赖">排除依赖</h3><p>排除依赖是指<strong>主动断开依赖的资源</strong>，被排除的资源无需指定版本。例如，项目A依赖了资源B，资源B依赖了资源C，但是我们又不想让项目A间接依赖资源C，那么这时候就需要在项目A中将对资源C的依赖排除。</p><p>排除依赖的设置方法如下——<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体的依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>project_C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>project_C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--排除依赖选项 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="依赖范围">依赖范围</h2><p>依赖的<code>jar</code>在默认情况下可以在任何地方使用，也可以通过scope标签设定其作用范围。</p><h3 id="依赖范围分类">依赖范围分类</h3><ul><li>主程序范围有效（main文件夹）</li><li>测试程序范围有效（test文件夹）</li><li>是否参与打包（package指令范围）</li></ul><table><thead><tr class="header"><th style="text-align: center;">scope</th><th style="text-align: center;">主代码</th><th style="text-align: center;">测试代码</th><th style="text-align: center;">打包</th><th style="text-align: center;">资源范例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">compile</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">log4j</td></tr><tr class="even"><td style="text-align: center;">test</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">junit</td></tr><tr class="odd"><td style="text-align: center;">provided</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">servlet-api</td></tr><tr class="even"><td style="text-align: center;">runtime</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td><td style="text-align: center;">jdbc</td></tr></tbody></table><h3 id="依赖范围设置">依赖范围设置</h3><p>需要使用<code>scope</code>关键字设置依赖的范围——<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体的依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>project_C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>project_C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--依赖范围选项 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="依赖范围传递">依赖范围传递</h3><p>带有依赖范围的资源进行传递时，作用范围会受到影响，并未严格传递。如下表所示（注："行"为<strong>直接依赖</strong>，"列"为<strong>间接依赖</strong>）</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">compile</th><th style="text-align: center;">test</th><th style="text-align: center;">provided</th><th style="text-align: center;">runtime</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>compile</strong></td><td style="text-align: center;">compile</td><td style="text-align: center;">test</td><td style="text-align: center;">provided</td><td style="text-align: center;">runtime</td></tr><tr class="even"><td style="text-align: center;"><strong>test</strong></td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="odd"><td style="text-align: center;"><strong>provided</strong></td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="even"><td style="text-align: center;"><strong>runtime</strong></td><td style="text-align: center;">runtime</td><td style="text-align: center;">test</td><td style="text-align: center;">provided</td><td style="text-align: center;">runtime</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Maven」基础知识</title>
      <link href="/2022/01/24/maven/maven-ji-chu-zhi-shi/"/>
      <url>/2022/01/24/maven/maven-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Maven 是一个<strong>项目管理工具</strong>，可以对 Java项目进行构建、依赖管理。Maven的核心功能是合理叙述项目间的依赖关系，通俗点 就是<strong>“通过pom.xml文件的配置获取jar包不用手动的去添加jar包”</strong>。该工具的原理图如下所示——<br><img src="生命周期与插件.png"></p><h2 id="仓库">仓库</h2><p>仓库可以储存资源，包含各种<code>jar</code>包。仓库分为两种：<strong>本地仓库和远程仓库</strong></p><ul><li><strong>本地仓库</strong>：是在本机电脑上储存资源的仓库，可以从远程仓库中获取资源。</li><li><strong>远程仓库</strong>：非本机仓库，可以为本地仓库获取资源，又包含两种——<strong>中央仓库</strong>（apache公司的开发者维护的资源包）和<strong>私服</strong>（包括从中央仓库）</li></ul><h2 id="坐标">坐标</h2><p>如果我们本地的maven项目想从远程仓库中获取的maven资源包并使用（也叫<strong>依赖</strong>），需要在<code>pom.xml</code>中提供该资源包的坐标，坐标至少包括三个内容——<code>groupId</code><code>artifactId</code> <code>version</code>，可以直接在<a href="https://mvnrepository.com/">官网</a>中查找。<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--依赖所属群组id--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--依赖所属项目id--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--依赖版本号--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们在本地新建maven项目时也需要在<code>pom.xml</code>中提供该项目的坐标，以方便其他人使用我们的项目成果（准确来说，是使用该<strong>项目打包后形成<code>jar</code>包</strong>）。<p></p><h2 id="maven项目的工程目录">maven项目的工程目录</h2><p>maven项目的<strong>java工程</strong>目录如下所示——<br><img src="maven工程目录.png"></p><p>如果这是一个<strong>web工程</strong>，则需要在main中增加一个文件夹<code>webapp</code>，如下图——<br><img src="web工程目录.png"></p><h2 id="pom.xml写法">pom.xml写法</h2><p><code>pom.xml</code>在项目的根目录下（例如上文中的<code>java01</code>文件夹），作用是<strong>对maven项目进行配置</strong>。必须包括<strong>maven的版本号</strong>，<strong>当前项目的坐标</strong>，还可以包含<strong>依赖</strong>（<code>dependencies</code>）、<strong>插</strong>件（<code>plugins</code>）等等。<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- maven的版本号 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--所属群组id--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.hyggge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--项目id--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>java01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--版本号--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 依赖 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--具体的依赖--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>          <span class="token comment">&lt;!--依赖所属群组id--&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>          <span class="token comment">&lt;!--依赖所属项目id--&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>          <span class="token comment">&lt;!--依赖版本号--&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 插件 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-site-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.7.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">&gt;</span></span>generate-test-resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」包(Package)</title>
      <link href="/2022/01/24/java/java-xue-xi-bi-ji-bao-package/"/>
      <url>/2022/01/24/java/java-xue-xi-bi-ji-bao-package/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="包的定义">包的定义</h2><ul><li>在笔者看来，包其实就是一个<strong>文件夹</strong>，包含者我们定义的<strong>功能相似或相关</strong>的<strong>类、接口、枚举和注释</strong>，可以看成一种<strong>特殊的封装</strong>。</li><li>一个包中的类名字是<strong>不同的</strong>，不同的包中的类的名字是可以<strong>相同的</strong>，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。</li><li><strong>包的作用</strong>：防止命名冲突，访问控制，提供搜索和定位类（<code>class</code>）、接口(<code>interface</code>)、枚举（<code>enumerations</code>）和注释（<code>annotation</code>）等。</li></ul><h2 id="包的创建package">包的创建（package）</h2><p>包的创建需要使用<code>package</code>关键词，在源文件的第一行进行声明。需要注意的是，每个源文件只能有一个包声明。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="包的命名规范">包的命名规范</h3><p>本部分内容参考该<a href="https://segmentfault.com/a/1190000008711718">博客</a><br>Java的包名都有小写单词组成，应该避免使用与系统发生冲突的名字，如java.lang、java.swing等。多数开发人员采用自己公司在互联网上的域名称作为自己程序包的唯一前缀（如上例）。<br><strong>个人和组织包命名规则如下：</strong></p><ul><li><p><strong>indi</strong>：个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。<br>包名为“indi.发起者名.项目名.模块名.……”。</p></li><li><p><strong>pers</strong>：个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人。<br>包名为“pers.个人名.项目名.模块名.……”。</p></li><li><p><strong>priv</strong>：私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。<br>包名为“priv.个人名.项目名.模块名.……”。</p></li><li><p><strong>onem</strong> ：与“indi”相同，推荐使用“indi”。</p></li><li><p><strong>team</strong>：团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。<br>包名为“team.团队名.项目名.模块名.……”。</p></li><li><p><strong>com</strong>：公司项目，copyright由项目发起的公司所有。<br>包名为“com.公司名.项目名.模块名.……”。</p></li></ul><h3 id="空包">空包</h3><p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamedpackage）中。这也是为什么即使我们没有在源文件中使用<code>import</code>,也能调用相同路径下的其他源文件。</p><h2 id="包的导入import">包的导入（import）</h2><h3 id="不同包之间的导入">不同包之间的导入</h3><p>不同包之间的使用通常有以下3种方法——</p><ol type="1"><li>使用全名<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span>Animal</span> ani <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span>Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>导入该类<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span><span class="token class-name">Animal</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Animal</span> ani <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>导入整个包(使用通配符<code>*</code>)<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Animal</span> ani <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>注意点</strong></li></ol><ul><li>如果两个包（<code>com.hyggge</code> 和<code>com.czh</code>）都有<code>Animal</code>类，即使把两个包都导入，访问<code>Animal</code>类时仍然需要<strong>使用全名</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>czh<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span>Animal</span> ani <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span></span>Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span></span>Animal</span> ani <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>czh<span class="token punctuation">.</span></span>Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用通配符<code>*</code>并不意味者将把包下的类、接口等都导入，而是按需求导入，即“用则导，不用则不导”。</li></ul><h3 id="有包的类和无包的类互相访问">有包的类和无包的类互相访问</h3><p>有包的类和无包的类互相访问有以下规则：</p><ol type="1"><li><strong>无包的类可以访问有包的类</strong>, 直接导入即可；</li><li>有包的类无法访问无包的类, 直接访问是找同一个包中的,由于不同包需要导入, 而无包的类无法导入（包的类属于无名包）；</li><li>在定义类的时候, 为了让别人都能使用到, 所以一定要定义一个包。</li></ol><h3 id="包的无等级性">包的无等级性</h3><p>例如我们现在有两个包<code>com.hyggge</code>和<code>com.hyggge.czh</code>。从路径上看，这两个包时有等级的，但是实际上包和包之间没有包含关系。当需要使用这两个包中的类时，需要同时导入——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">impot com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span>*<span class="token punctuation">;</span>impot com<span class="token punctuation">.</span>hyggge<span class="token punctuation">.</span>czh<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h3 id="静态导入">静态导入</h3><p>当我们需要频繁的访问某个类的常量或静态方法时，可以采用静态导入，即使用<code>import static</code>将类中的常量和静态方法导入。见下例（摘自该<a href="https://blog.csdn.net/sinat_30973431/article/details/82386978?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164298826316780265425850%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164298826316780265425850&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-82386978.pc_search_result_cache&amp;utm_term=Java%E5%8C%85&amp;spm=1018.2226.3001.4187">博客</a>）<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token static">PI</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token static">cos</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> r1 <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> r2 <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>r1<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>也可以使用通配符<code>*</code><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h2 id="包的路径">包的路径</h2><ul><li><p>包的中<strong>java源文件的目录</strong>和<strong>编译后class文件的目录</strong>应该和包的名字对应起来，但是并不要求两者路径一样，可以分开来安排。如下所示——<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li><li><p>类的目录的绝对路径叫做 <code>class path</code>。设置在系统变量<code>CLASSPATH</code> 中。编辑器和java虚拟机将 <code>package</code>名字加到<code>class path</code> 后来构造 .class 文件的路径</p></li><li><p>设置CLASSPATT系统变量，方法见该<a href="https://blog.csdn.net/weixin_42361112/article/details/114421658?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164299544416780264048339%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164299544416780264048339&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-114421658.pc_search_result_cache&amp;utm_term=%E8%AE%BE%E7%BD%AE+CLASSPATH+%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8Fjavaa&amp;spm=1018.2226.3001.4187">博客</a></p></li><li><p>如果我们的文件都在运行目录下时，也可以不设置<code>CLASSPATH</code>。也就是说在没有配置<code>CLASSPATH</code>环境变量时，java命令在找class文件时是默认在当前目录下寻找的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」接口</title>
      <link href="/2022/01/23/java/java-xue-xi-bi-ji-jie-kou/"/>
      <url>/2022/01/23/java/java-xue-xi-bi-ji-jie-kou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="接口和类">接口和类</h2><p>《Thinking inJava》一书在《接口》一节中讲到——“<strong>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法</strong>”。我认为接口其实是<strong>一组抽象方法的集合</strong>，是一种<strong>极度抽象的类</strong>，但是他和类又有许多不同点。</p><h3 id="接口与类的相似点">接口与类的相似点</h3><ul><li>接口中可以有多个方法（也仅限于方法）</li><li>接口文件保存在 .java结尾的文件中，文件名使用接口名，遵循类的命名方法。</li></ul><h3 id="接口与类的不同点">接口与类的不同点</h3><ul><li>接口<strong>不能用于实例化对象</strong>，因此没有且<strong>无法定义构造方法</strong>。但接口中的方法可以被对象实现（类似于继承，但不是继承）。</li><li>接口中所有的方法都是<strong>抽象方法</strong>，即不能在接口中实现（无方法体）。每一个方法都是隐式抽象的，接口中的方法被隐式的指定为<code>public abstract</code>（只能是<code>public abstract</code>，其他修饰符都会报错）。</li><li>接口中<strong>不能包含有成员变量</strong>（<strong><code>static</code>和<code>final</code>型变量除外</strong>）。如果在接口中定义变量，则会被隐式地定义为<code>public static final</code>变量（并且只能是<code>public</code>，用 <code>private</code> 修饰会报编译错误）。</li><li>接口中不能含有<strong>静态代码块</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>以及<strong>静态方法</strong>(用<code>static</code>修饰的方法)，而类（包括抽象类）是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，但一个类却可以实现多个接口，并且接口支持多<strong>重继承</strong>。</li></ul><h2 id="接口的声明">接口的声明</h2><p>声明接口需要使用<code>interface</code>关键字——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span>可见度<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名称 <span class="token punctuation">{</span>    <span class="token comment">// 声明变量</span>    <span class="token comment">// 抽象方法</span><span class="token punctuation">}</span><span class="token comment">//例如</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnimalInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不需要写{}，可省略abstract</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li><strong>接口</strong>是<strong>隐式抽象</strong>的，当声明一个接口的时候，不必使用<code>abstract</code>关键字。</li><li><strong>接口中每一个方法</strong>也是<strong>隐式抽象</strong>的，声明时同样不需要<code>abstract</code>关键字。</li><li>接口中的方法都是<code>public</code><strong>公有的</strong>。</li></ul><h2 id="接口的实现">接口的实现</h2><p>当一个类实现接口时，需要用<code>implements</code> 关键字。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">implements</span> 接口名称<span class="token punctuation">[</span><span class="token punctuation">,</span> 其他接口名称<span class="token punctuation">,</span> 其他接口名称<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//例如</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnimalInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不需要写{}，可省略abstract</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> dog <span class="token keyword">implements</span> <span class="token class-name">AnimalInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fight"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>需要注意以下规则——</p><ul><li>一个类只能继承一个类，但是能实现多个接口。</li><li>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类（使用<code>abstract</code>）。</li><li>类在重写方法时要<strong>保持一致的方法名</strong>，并且应该保持相同或者相兼容的<strong>返回值类型</strong>。</li><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。（暂时还不理解...）</li></ul><h2 id="接口的继承">接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似，使用<code>extends</code>关键字。继承和被继承的两个接口是可以定义相同的抽象方法的（不会报错...）。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span>可见度<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名称 <span class="token keyword">extends</span> 其他的接口名 <span class="token punctuation">{</span>    <span class="token comment">// 声明变量</span>    <span class="token comment">// 抽象方法</span><span class="token punctuation">}</span><span class="token comment">//例如</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnimalInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不需要写{}，可省略abstract</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DogInterface</span> <span class="token keyword">extends</span> <span class="token class-name">AnimalInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tailShake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 此时如果一个类需要实现 DogInterface 接口的话需要总共实现五个方法。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>虽然类的<strong>多重继承</strong>是不合法的，但是接口却可是实现<strong>多重继承</strong>。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="标记接口">标记接口</h2><p>我们把<strong>不包含任何方法和变量的接口</strong>定义为<strong>标记接口</strong>。标记接口作用是是给某个对象打个标（盖个戳），<strong>使对象拥有某个或某些特权</strong>。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flag</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>标记接口用于以下两个目的——<p></p><ul><li><strong>建立一个公共的父接口</strong>：正如<code>java.util.EventListener</code>接口，这是由几十个其他接口扩展的JavaAPI，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了<code>EventListener</code>接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li><li><strong>向一个类添加数据类型</strong>：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li></ul><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><strong>静态代码块</strong>，在虚拟机加载<strong>类</strong>的时候就会加载执行，而且<strong>只执行一次</strong>；<strong>非静态代码块</strong>，在创建<strong>对象</strong>的时候(即new一个对象的时候)执行，<strong>每次创建对象都会执行一次</strong>。详见<a href="https://blog.csdn.net/weixin_44519124/article/details/103363548">博客</a>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」重写(Override)</title>
      <link href="/2022/01/23/java/java-xue-xi-bi-ji-chong-xie-override/"/>
      <url>/2022/01/23/java/java-xue-xi-bi-ji-chong-xie-override/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>重写</strong>是子类对父类的允许访问的方法的实现过程进行重新编写,<strong>返回值和形参都不能改变</strong>。</p><p><strong>重写的好处</strong>在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p><h2 id="重写父类中的方法">重写父类中的方法</h2><h3 id="概念">概念</h3><p>当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。例如<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment">//输出英文欢迎</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"GoodByene"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment">//输出中文欢迎  </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> myfirst <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//创建子类B的一个实例对象，使用默认构造方法</span>    b<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">//调用子类中重写的方法</span>    b<span class="token punctuation">.</span><span class="token function">sayBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">//调用父类中的方法</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="重写规则"><strong>重写规则</strong></h3><ol type="1"><li><p>参数列表与被重写方法的<strong>参数列表必须完全相同</strong>。</p></li><li><p>返回类型与被重写方法的<strong>返回类型可以不相同</strong>，但是必须是父类返回值的派生类（java5及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限<strong>不能比父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 <code>final</code> 的方法不能被重写。</p></li><li><p>声明为 <code>static</code>的方法不能被重写，但是能够<strong>被再次声明</strong>。</p></li><li><p>子类和父类<strong>在同一个包</strong>中，那么子类可以重写父<strong>类所有方法</strong>，除了声明为<code>private</code> 和 <code>final</code> 的方法。</p></li><li><p>子类和父类<strong>不在同一个包</strong>中，那么子类只能够重写父类的声明为<code>public</code> 和 <code>protected</code> 的非 <code>fina</code>l方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ol><ul><li><strong>子类可以通过<code>super()</code>访问被重写的父类中的方法</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment">//输出英文欢迎</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayhello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">//输出中文欢迎  </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//创建子类B的一个实例对象，使用默认构造方法</span>    b<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">//调用子类中重写的方法</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="隐藏父类中的方法">隐藏父类中的方法</h2><p>如果一个子类定义了一个<strong>静态类方法</strong>，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。</p><ul><li>当调用被重写的方法时，调用的版本是子类的方法；</li><li>当调用被隐藏的方法时，调用的版本取决于是从父类中调用还是从子类中调用。</li></ul><p>下面有一个例子(取材于该<a href="https://blog.csdn.net/weixin_52122271/article/details/114285424">博客</a>)，我暂时还没看懂,先挂一下...<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//原文链接：https://blog.csdn.net/weixin_52122271/article/details/114285424</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">//静态类方法</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，这是A的静态类方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">//实例方法</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，这是A中的实例方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">//静态类方法</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，这是B的静态类方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">//实例方法</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大家好，这是B的实例方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> myfirst <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//创建B类的实例对象b</span>    <span class="token class-name">A</span> a<span class="token operator">=</span>b<span class="token punctuation">;</span>                                 <span class="token comment">//隐式对象类型转换</span>    <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//调用A类的静态类方法</span>    a<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//调用a对象的静态类方法</span>    <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//调用B类的静态方法</span>    a<span class="token punctuation">.</span><span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//调用a对象的实例方法</span>    b<span class="token punctuation">.</span><span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//调用b对象的的实例方法</span>    <span class="token class-name">A</span> a2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//创建A类的实例对象a2</span>    a2<span class="token punctuation">.</span><span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//调用a2对象的实现方法</span><span class="token punctuation">}</span><span class="token comment">/*运行结果  大家好，这是A的静态类方法  大家好，这是A的静态类方法  大家好，这是B的静态类方法  大家好，这是B的实例方法  大家好，这是B的实例方法  大家好，这是A中的实例方法*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="覆盖父类的中的变量">覆盖父类的中的变量</h2><p>如果子类中重新定义了一个<strong>与父类中已有变量同名</strong>的变量，那么父类中的变量就被“覆盖”。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Name"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Cat"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/*运行结果:cat*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="关于override">关于<code>@Override</code></h2><p><code>@Override</code>是<strong>伪代码</strong>，表示重写，在“<strong>子类重写父类</strong>”或“<strong>某类实现某接口</strong>”时使用。写上有如下好处:（详见该<a href="https://blog.csdn.net/baidu_32885165/article/details/102779323">博客</a>）</p><ul><li>可以当注释用,方便阅读；</li><li>编译器可以给你验证<code>@Override</code>下面的方法名是否是你父类中所有的，<strong>如果没有则报错</strong>。<br>例如，你如果没写<code>@Override</code>，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」继承</title>
      <link href="/2022/01/22/java/java-xue-xi-bi-ji-ji-cheng/"/>
      <url>/2022/01/22/java/java-xue-xi-bi-ji-ji-cheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="继承">继承</h2><h3 id="语法和概念">语法和概念</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符 <span class="token keyword">class</span> 子类名 <span class="token keyword">extends</span> 父类名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>子类从它的父类中继承所有的<strong>数据域和方法</strong>，也可以添加<strong>新的数据域和新的方法</strong>。</li><li>如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A，<ul><li><strong>称类 A 为"父类</strong>"，也称为超类、基类；</li><li><strong>称类 B 为"子类"</strong>，也称为次类、扩展类、派生类。</li></ul></li></ul><h3 id="继承的注意点"><strong>继承的注意点</strong></h3><ol type="1"><li><p>子类不是父类的子集，<strong>子类一般比父类包含更多的数据域和方法</strong>，子类可以对父类进行扩展，也可以用自己的方式<strong>实现父类的方法</strong>（即下面要讲的重写）</p></li><li><p>子类对象确实拥有父类对象中的所有属性和方法,但是父类对象中的<code>private</code>属性和方法,子类是<strong>无法访问到的</strong>,只是拥有,但不能使用。<br>若想访问<code>private</code>属性，则需要在父类中提供用来<strong>访问其私有字段的public或protected方法</strong></p></li><li><p>Java的继承是<strong>单继承</strong>，但是可以<strong>多层继承</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。Java<strong>不允许多重继承</strong>（和C++不同），即<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//错误写法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p>在继承关系之中，如果要实例化子类对象，会默认<strong>先调用父类构造</strong>，为父类之中的属性初始化，之后<strong>再调用子类构造</strong>，为子类之中的属性初始化。<strong>在任何的情况下，子类都逃不出父类构造的调用</strong></p><ul><li><strong>子类和父类的构造函数均无参数</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// 父类无参构造</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************************"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// 子类构造</span>        <span class="token comment">//这里会自动补充一句super();</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"#########################"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>   <span class="token comment">// 实例化子类对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/*输出为*************************#########################*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>父类的构造函数有参数，子类无参数</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 父类构造</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*************************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 子类构造</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类构造，这一句不可省略</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"#########################"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/*输出为*************************#########################*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="super-关键字">super 关键字</h2><ul><li><p><code>super</code> 表示使用它的类的父类。<code>super</code>可用于：</p><ul><li><strong>调用父类的构造方法</strong></li><li><strong>调用父类的方法（在子类需要重写父类时使用</strong>）</li><li><strong>访问父类的数据域</strong></li></ul></li></ul><h3 id="调用父类的构造方法">调用父类的构造方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">super</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>super</code>语句<strong>必须是子类构造方法的第一条语句</strong>。</li><li>父类的构造方法<strong>不被子类继承</strong>,<strong>不能</strong>在子类中使用父类构造方法名来调用父类构造方法，调用父类的构造方法的唯一途径是使用<code>super</code> 关键字。</li><li>如果子类中没显式调用，则编译器自动将 <code>super();</code>作为子类构造方法的第一条语句。也就是说如果父类构造器没有参数，则在子类的构造方法中不需要使用<code>super</code>关键字调用父类构造方法，系统会<strong>自动调用父类的无参构造方法</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//有参数</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token keyword">int</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> animal<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//无参数</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> animal<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//也可以不写；</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="调用父类的实例方法">调用父类的实例方法</h3><ul><li>如果是继承的方法，是<strong>没有必要</strong>使用 <code>super</code>来调用，直接即可调用。</li><li>如果子类<strong>覆盖或重写了父类的方法</strong>，则只有使用<code>super</code> 才能在子类中调用父类中的被重写的方法。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>parameter list<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//重新定义方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="访问父类的数据域">访问父类的数据域</h3><ul><li>如果是继承的数据，是<strong>没有必要</strong>使用 <code>super</code>来调用，直接即可调用。</li><li>如果子类<strong>覆盖或重写了父类的数据</strong>，则只有使用<code>super</code> 才能在子类中调用父类中的被重写的数据。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">.</span>variableName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="this-关键字">this 关键字</h2><p><code>this</code>关键字表示当前<strong>对象</strong>(实例)，可用于：</p><ul><li>调用当前类的<strong>构造方法</strong>（调用类方法不能用<code>this</code>）</li><li>限定当前对象的<strong>数据域变量</strong><br>### 调用当前类的<strong>构造方法</strong><br>通过<code>this</code>调用当前类的<strong>构造方法</strong>时必须是<strong>方法的第一条语句</strong>。（和调用父类使用的<code>super</code>用法相似）<ul><li><code>this();</code> 调用默认构造方法。</li><li><code>this(参数);</code> 调用带参构造方法。</li><li>使用规则：（参考该<a href="https://blog.csdn.net/Return_head/article/details/80744056">博客</a>）<ul><li><p>假如在一个构造方法中使用了<code>this</code>语句，那么它必须作为构造方法的<strong>第一条语句</strong>。</p></li><li><p>只能在一个<strong>构造方法</strong>中使用<code>this</code>语句来调用类的其他构造方法，而<strong>不能在实例方法</strong>中用<code>this</code>语句来调用类的其他构造方法。</p></li><li><p>只能用<code>this</code>语句来调用其他构造方法，而不能<strong>通过方法名</strong>来直接调用构造方法。<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> animal<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        animal cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul></li></ul></li></ul><h3 id="限定当前对象的数据域变量">限定当前对象的<strong>数据域变量</strong></h3><ul><li>一般用于方法内的局部变量与对象的数据域变量同名的情况，将成员变量和局部变量进行区分（和C++相似）<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//注:可以使用this进行区分成员变量和局部变量</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="多态的初步介绍">多态的初步介绍</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力；是同一个接口，使用不同的实例而执行不同操作。多态的好处是——可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><ul><li><strong>多态的必要条件</strong><ul><li><strong>继承</strong></li><li><strong>重写</strong></li><li><strong>父类引用指向子类对象：<code>Parent p = new Child()</code>;</strong></li></ul></li><li><strong>多态调用方法的流程</strong>：当使用多态方式调用方法时，<strong>首先检查父类中是否有该方法</strong>，如果没有，则编译错误；如果有，再去调用子类的同名方法。</li></ul><p>下面我们重点理解一下第三个必要条件——<strong>父类引用指向子类对象</strong>。例如以下程序——<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Animal move!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog move!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog bark!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Animal 对象</span>        <span class="token class-name">Animal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog 对象</span>    a<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行 Animal 类的方法</span>    b<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行 Dog 类的方法</span>    b<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译错误!!!!!!!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>最后一行编译错误原因是——<p></p><p>因为此时<code>Animal b = new Dog();</code>满足<strong>父类引用指向子类对象</strong>的情况，首先检查在父类中是否有该方法。因为父类<code>Animal</code>并没有<code>bark（）</code>方法，因此会报错。</p><p>如果将<code>Animal b = new Dog();</code>改为<code>Dog b = new Dog();</code>的话，以上程序会被正常编译。</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><strong>单继承</strong>就是一个子类只能继承一个父类；<strong>多重继承</strong>就是，B类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B类的父类。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」数组</title>
      <link href="/2022/01/22/java/java-xue-xi-bi-ji-shu-zu/"/>
      <url>/2022/01/22/java/java-xue-xi-bi-ji-shu-zu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数组的创建的访问">数组的创建的访问</h2><h3 id="一维数组的创建">一维数组的创建</h3><ul><li>一维数组的创建有以下几种方法——<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//先声明后定义</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//直接定义</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//列表定义</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="多维数组的创建">多维数组的创建</h3><ul><li>下面以二维数组为例介绍多维数组的创建方法<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//直接为每一维分配空间</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//从最高维开始，分别为每一维分配空间</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Good"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Luck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"to"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组的访问">数组的访问</h3><ul><li>数组的访问直接使用下标即可</li><li>一般使用循环遍历数组<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> it <span class="token operator">:</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>length()</code> 方法，<code>length</code> 属性和<code>size()</code>方法的区别:<ul><li><code>length()</code>方法是针对字符串来说的，要求一个字符串的长度就要用到它的<code>length()</code>方法；</li><li><code>length</code> 属性是针对 Java中的数组来说的，要求数组的长度可以用其 <code>length</code> 属性；</li><li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素, 就调用此方法来查看.</li></ul></li></ul><h2 id="数组作为函数参数和返回值">数组作为函数参数和返回值</h2><ul><li>数组作为<strong>函数参数</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>数组作为<strong>函数返回值</strong><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> result<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="arrays类">Arrays类</h2><p><code>java.util.Arrays</code>类能方便地操作数组，它提供的所有方法都是静态方法（即归属于Arrays类）。</p><h4 id="常用方法">常用方法</h4><p>Arrays类中有以下常用方法——</p><ul><li><strong><code>int binarySearch(Object[] a, Object key)</code></strong><br>用<strong>二分查找算法</strong>在给定数组中搜索给定值的对象(<code>Byte</code>,<code>Int</code>,<code>double</code>等)。数组在调用前<strong>必须排序好</strong>的。如果查找值包含在数组中，则<strong>返回搜索键的索引</strong>；否则返回(-(插入点) - 1)。</li><li><strong><code>boolean equals(long[] a, long[] a2)</code></strong><br>如果两个指定的 <strong>long 型数组</strong>彼此相等，则返回<code>true</code>。<strong>如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的</strong>。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（<code>Byte</code>，<code>short</code>，<code>Int</code>等）。</li><li><strong><code>void fill(int[] a, int val)</code></strong><br>将指定的 <code>int</code> 值<strong>分配</strong>给指定 <code>int</code>型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（<code>Byte</code>，<code>short</code>，<code>Int</code>等）。</li><li><strong><code>void sort(Object[] a)</code></strong><br>对指定对象数组根据其元素的自然顺序进行<strong>升序排列</strong>。同样的方法适用于所有的其他基本数据类型（<code>Byte</code>，<code>short</code>，<code>Int</code>等）。</li><li><strong><code>copy(Object[] e,newLength)</code></strong><br>其第一个形参指的是需要扩容的数组，后面是扩容后的大小，其内部实现其实是使用了<code>System.arrayCopy()</code>; 在内部重新创建一个长度为<code>newLength</code> 类型是<code>Object</code>的数组。</li><li><strong><code>toString(Object[] arr)</code></strong><br>将数组<code>arr</code>以字符串的形式输出到终端。</li></ul><h4 id="方法调用">方法调用</h4><p>因为Arrays类中的方法都是静态的，因此调用时应该使用<code>Arrays.methodName</code><br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」字符串</title>
      <link href="/2022/01/22/java/java-xue-xi-bi-ji-zi-fu-chuan/"/>
      <url>/2022/01/22/java/java-xue-xi-bi-ji-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中和字符串相关类有以下3种——</p><ul><li><strong>String类</strong></li><li><strong>StringBuild类</strong></li><li><strong>StringBuffer类</strong></li></ul><h2 id="string类">String类</h2><h3 id="对象创建">对象创建</h3><ul><li>例程<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s_1 <span class="token operator">=</span> <span class="token string">"Hyggge"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s_2 <span class="token operator">=</span> s_1<span class="token punctuation">;</span><span class="token class-name">String</span> s_3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Czh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s_4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'Z'</span><span class="token punctuation">,</span> <span class="token char">'H'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">String</span> s_5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>s_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>需要注意的是，String类对象是不可变的(本质上用<code>final</code>修饰)，如以下程序<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"Hyggge"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"Czh"</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>虽然程序最后<code>a</code>引用的对象是"Czh",但是一开始创建的"Hyggge"对象并没有消失。相当于以下C++程序<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// C++</span>string s_1 <span class="token operator">=</span> <span class="token string">"Hyggge"</span><span class="token punctuation">;</span>string <span class="token operator">&amp;</span>a <span class="token operator">=</span> s_1<span class="token punctuation">;</span>string s_2 <span class="token operator">=</span> <span class="token string">"Czh"</span><span class="token punctuation">;</span>string <span class="token operator">&amp;</span>a <span class="token operator">=</span> s_2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串连接">字符串连接</h3><ul><li>第一种方法——使用<code>concat()</code>函数<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"Hyggge is "</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"Czh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">"Hyggge is "</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"Czh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>第二种方法——使用<code>+</code><br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"Hyggge is "</span> <span class="token operator">+</span> <span class="token string">"Czh "</span> <span class="token operator">+</span> <span class="token string">"!!!"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="创建格式化字符串">创建格式化字符串</h3><ul><li>格式化输出和已通过printf和format实现。其中，format是String类中的静态方法。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span><span class="token comment">//method one</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hyggge's age is %d\n"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//method two</span><span class="token class-name">String</span> s<span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Hyggge's age is %d\n"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="string-类中的常用方法">String 类中的常用方法</h3><ul><li><strong><code>int length()</code></strong> 字符串长度</li><li><strong><code>boolean isEmpty()</code></strong>检查字符串是否非空</li><li><strong><code>int compareTo(String anotherString)</code></strong>字符串比较（字典序）</li><li><strong><code>int indexOf(int ch)</code></strong>返回指定字符第一次出现处的索引</li><li><strong><code>int indexOf(String str)</code></strong>返回指定子字符串在此字符串中第一次出现处的索引</li><li><strong><code>String concat(String str)</code></strong>字符串连接（原对象不变，需要使用中间对象，严重消耗内存，<strong>不推荐使用</strong>）</li><li><strong><code>boolean equals(Object anObject)</code></strong>将字符串和一个对象进行比较</li><li><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">其他方法</a></li></ul><h2 id="stringbuffer-和-stringbuilder-类">StringBuffer 和 StringBuilder类</h2><p>和 <code>String</code> 类不同的是，<code>StringBuffer</code> 和<code>StringBuilder</code>类的对象能够被多次的修改，并且不产生新的未使用对象。他们的区别是——</p><ul><li><code>StringBuffer</code> 线程安全 <code>StringBuilder</code>线程不安全</li><li><code>StringBuilder</code> 相较于 <code>StringBuffer</code>有速度优势（绝大多数情况下使用<code>StringBuilder</code>）<br>类</li></ul><h3 id="对象创建以stringbuilder类为例">对象创建（以StringBuilder类为例）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">StringBuilder</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以显式的规定大小</span><span class="token class-name">StringBuilder</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"Hyggge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以显式的规定大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="常用方法以stringbuilder类为例">常用方法（以StringBuilder类为例）</h3><ul><li><strong><code>StringBuilder append(String str)</code></strong>将指定的字符串追加到此字符序列</li><li>** <code>StringBuilder insert(int offset, String str)</code>** 将str 参数的字符串插入此序列中</li><li><strong><code>String substring(int start)</code></strong>返回一个新的 String，它包含此字符序列当前所包含的字符子序列</li><li><strong><code>StringBuilder reverse(String str)</code></strong>翻转字符串</li><li><strong><code>StringBuilder delete(int start, int end)</code></strong>注意左闭右开</li><li><strong><code>StringBuilder replace((int start, int end, String str)</code></strong>使用给定 String 中的字符替换此序列的子字符串中的字符</li><li><strong><code>String toString()</code></strong>返回此序列中数据的字符串表示形式</li><li><strong><code>int indexOf(String str)</code></strong>返回第一次出现的指定子字符串在该字符串中的索引。</li><li><strong><code>int length()</code></strong> 返回长度（字符数）。</li><li><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html">其他方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java SE」变量类型和修饰符</title>
      <link href="/2022/01/21/java/java-xue-xi-bi-ji-bian-liang-lei-xing-he-xiu-shi-fu/"/>
      <url>/2022/01/21/java/java-xue-xi-bi-ji-bian-liang-lei-xing-he-xiu-shi-fu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="java的变量类型">Java的变量类型</h2><p>Java中的变量类型有以下三种——</p><ul><li><strong>类变量</strong></li><li><strong>实例变量</strong></li><li><strong>局部变量</strong></li></ul><h3 id="类变量静态变量">类变量(静态变量)</h3><ul><li>类变量是属于所在的类，而不属于任何<strong>由该类定义的对象</strong>。换句话说，不管实例化了多少对象，类变量都只有一个。类变量是由static修饰的，这一点和C++相似。</li><li>一般情况下和<code>final</code>一起声明常量，很少单独使用<code>static</code>声明变量。而且，大多数静态变量被声明为<code>public</code>类型。因此，经常会见到<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token constant">CONST</span> <span class="token operator">=</span> <span class="token number">0x7fffffff</span> <span class="token comment">//一般常量定义使用全大写命名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>默认值和实例化变量相似，数值型变量默认值是<code>0</code>，布尔型默认值是<code>false</code>，引用类型默认值是<code>null</code>。变量的值可以在声明的时候指定，也可以在<code>构造方法</code>中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>访问时使用<code>ClassName.VariableName</code></li><li><strong>可以</strong>被访问修饰符<code>public</code>,<code>private</code>,<code>protected</code>,<code>defualt</code>修饰</li><li>例程如下<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> countValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        countValue<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"countValue = "</span> <span class="token operator">+</span> countValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出 countValue = 100</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="实例变量">实例变量</h3><ul><li>与类变量不同，实例变量是属于<strong>实例化的对象</strong>，也就是说如果实例化100个对象，那就有100的实例变量的值被确定。</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的，而且实例变量的值应该至少被一个方法、构造方法或者语句块引用。</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。</li><li>访问时使用<code>ObjectName.VariableName</code>。</li><li><strong>可以</strong>被访问修饰符<code>public</code>,<code>private</code>,<code>protected</code>,<code>defualt</code>修饰。</li></ul><h3 id="局部变量">局部变量</h3><ul><li>局部变量必须要在局部变量声明在<strong>方法、构造方法或者语句块</strong>中，作用域是它所在的<strong>方法、构造方法或者语句块</strong>，并且只在作用域中可见。</li><li>实例变量没有默认值，因此在声明后必须初始化。</li><li><strong>不可以</strong>被访问控制修饰符<code>public</code>,<code>private</code>,<code>protected</code>,<code>defualt</code>修饰。</li><li><strong>不可以</strong>被非访问访问修饰符<code>static</code>修饰。</li><li>例程如下<br><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Adder{    public add(int a, int b){        int sum = a + b;        return sum;    }    public static void main(String[] args){        System.out.println(add(1, 2));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="java-访问控制修饰符">Java 访问控制修饰符</h2><p>Java中的访问控制修饰符有以下4种——</p><ul><li><strong>public</strong></li><li><strong>protected</strong></li><li><strong>default</strong></li><li><strong>private</strong></li></ul><table><thead><tr class="header"><th style="text-align: center;">修饰符</th><th style="text-align: center;">当前类</th><th style="text-align: center;">同一包内</th><th style="text-align: center;">子孙类（同一个包）</th><th style="text-align: center;">子孙类（不同包）</th><th style="text-align: center;">其他包</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>public</strong></td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td></tr><tr class="even"><td style="text-align: center;"><strong>protected</strong></td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y/N</td><td style="text-align: center;">N</td></tr><tr class="odd"><td style="text-align: center;"><strong>default</strong></td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td></tr><tr class="even"><td style="text-align: center;"><strong>private</strong></td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td></tr></tbody></table><h3 id="public">public</h3><ul><li><strong>适用范围</strong>：类、接口、变量、方法，构造方法。</li><li><strong>访问权限</strong>：被声明为 <code>public</code>的类、方法、构造方法和接口<strong>能够被任何其他类访问（包括同一包和不同包）</strong></li><li>如果几个相互访问的 <code>public</code>类分布在不同的包中，则需要导入相应 <code>public</code>类所在的包再使用。</li><li>类所有的<code>public</code>方法和变量都能被其子类继承。</li><li><code>main()</code> 必须设置为共有。</li><li>一个Java文件中可以定义多个类，但是最多只有一个类被<code>public</code>修饰，并且这个类的类名与文件名必须相同。</li></ul><h3 id="protected">protected</h3><ul><li><strong>适用范围</strong>：变量、方法，构造方法。<strong>类（内部类除外）和接口不能声明为<code>protected</code></strong>。</li><li><strong>访问权限</strong>：<code>protected</code>修饰的变量，方法，构造方法可以<strong>被同一包内的所有类访问（即<code>defualt</code>的访问权限）</strong>，也可以<strong>被不同包内的子孙类部分访问</strong>，讨论如下——<ul><li><strong>子类与基类在同一包中</strong>：被声明为<code>protected</code>的变量、方法和构造方法能被同一个包中的任何其他类访问；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的<code>protected</code> 方法，而不能访问基类实例的 <code>protected</code>方法。</li></ul></li><li>子类能访问和重写 <code>protected</code>修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量(这就是为什么叫做<code>protected</code>的原因)</li><li><strong>构造方法</strong>使用修饰符，则默认为<code>protected</code>;</li></ul><h3 id="default">default</h3><ul><li><strong>适用范围</strong>：类、接口、变量、方法，构造方法。</li><li><strong>访问权限</strong>：使用默认访问修饰符声明的变量和方法，对<strong>同一个包内的类</strong>是可见的</li></ul><h3 id="private">private</h3><ul><li><strong>适用范围</strong>：变量、方法，构造方法。<strong>类（内部类除外）和接口不能声明为<code>private</code></strong>。</li><li><strong>访问权限</strong>：被声明为 <code>private</code>的方法、变量和构造方法<strong>只能被所属类访问</strong></li><li>声明为<code>private</code>的变量只能通过类中<code>public</code>方法被外部类访问，因此可以实现类数据的保护和类实现细节多隐藏。</li></ul><h2 id="java-中的非访问修饰符">Java 中的非访问修饰符</h2><p>Java中的非访问修饰符有以下6种——</p><ul><li><strong>static</strong></li><li><strong>final</strong></li><li><strong>abstract</strong></li><li><strong>synchronized</strong></li><li><strong>transient</strong></li><li><strong>volatile</strong>（后三种与多线程和序列化有关，不在此介绍）</li></ul><h3 id="static">static</h3><ul><li>意为“静态的”，归属于类。</li><li><strong>适用范围</strong>：变量和方法<ul><li><code>static</code>变量：即静态变量。独立于对象，只归属于整个类。<ul><li><code>static</code>不可以修饰局部变量！！！</li><li>访问时使用<code>ClassName.variableName</code>。</li></ul></li><li><code>static</code>方法：即静态方法。独立于对象，只归属于整个类。<ul><li>静态方法不能使用所在类的<strong>非静态变量</strong>。</li><li>静态方法只能从<strong>参数列表</strong>中获取数据，然后计算这些数据。</li><li>访问时使用<code>ClassName.methodName</code>。</li></ul></li></ul></li></ul><h3 id="final">final</h3><ul><li>意为“最终的”，一旦定义后，不能被重新定义</li><li><strong>适用范围</strong>：变量，方法和类<ul><li><code>final</code>变量：一旦赋值后，不能被重新赋值。<ul><li>被<code>final</code>修饰的实例变量<strong>必须显式指定初始值</strong>（因为它不能再次被赋值）</li><li><code>final</code>修饰符通常和<code>static</code>修饰符一起使用来创建<strong>类常量</strong>（上文已经提到了）</li></ul></li><li><code>final</code>方法：可以被子类继承，但是不能被子类重写。<ul><li>用<code>final</code>修饰方法可以防止方法的内容被子类修改。</li></ul></li><li><code>final</code>类：<code>final</code>类<strong>不能被继承</strong>，没有类能够继承<code>final</code>类的任何特性。</li></ul></li></ul><h3 id="abstract">abstract</h3><ul><li>意为“抽象的”，目的是为了将来可以对<code>abstract</code>的修饰目标进行扩充</li><li><strong>适用范围</strong>：方法和类<ul><li><code>abstract</code>类：抽象类<strong>不能用来实例化对象</strong>,声明抽象类的唯一目的是为了将来对该类进行扩充。<ul><li>有抽象方法的类一定要定义成抽象类，但抽象类可以不包含抽象方法。</li><li>只有抽象类的非抽象子类可以创建对象<br><pre class="line-numbers language-none"><code class="language-none">        <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><code>abstract</code>方法：是一种<strong>没有任何实现的方法</strong>（抽象类中的抽象方法只是声明，不包含方法体），该方法的具体实现由<strong>子类</strong>提供。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentNum</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//realize...</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>构造方法</strong>，<strong><code>static</code>方法（类方法）</strong>，<strong><code>final</code>方法</strong>不能声明为抽象方法</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类最终。<strong>必须有子类实现该抽象方法</strong>，否则，从最初的父类到最终的子类都不能用来实例化对象。</li><li>有抽象方法的类一定要定义成抽象类，但抽象类可以不包含抽象方法。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Cpp」引用和指针</title>
      <link href="/2022/01/19/c/cpp-yin-yong-he-zhi-zhen/"/>
      <url>/2022/01/19/c/cpp-yin-yong-he-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="序言">序言</h2><p>本文介绍C++中<strong>引用</strong>，<strong>指针</strong>，<strong>const限定符</strong>和<strong>常量表达式</strong>等几个部分的内容。对应原书<strong>45页——60页</strong>。</p><h2 id="引用">引用</h2><blockquote><p>引用为对象起了另外一个名字，引用类型可以引用另外一种类型。通常情况下可以将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p></blockquote><ul><li>举例如下<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//b是a的引用，需要在b前加引用符&amp;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>     <span class="token comment">//错误，没有初始化！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>引用的实质：<strong>引用并不是对象，而是对象的一个新名字，所有对引用的操作实际是都是在对源对象进行操作</strong>。</li><li>引用的定义：允许在一行中定义多个引用但是每个引用前必须有&amp;限定，例如<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="指针">指针</h2><blockquote><p>指针是“指向”另外一种类型的复合类型，可以像引用一样实现对其他对象的间接引用。但是它有两点和引用不同——<br>-指针本身是对象，可以对指针本身进行赋值和访问，而且可以在指针的生命周期内先后指向不同的对象<br>-指针在定义的时候无需赋初值。和其他类型相似，如果在快作用域中的指针没有被初始化，则会拥有一个不确定的值。</p></blockquote><h3 id="指针基础知识">指针基础知识</h3><ol type="1"><li><p><strong>举例如下</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//指针定义</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//用取地址符&amp;取得a的地址，并将地址赋值给b</span><span class="token keyword">int</span> <span class="token operator">*</span>c <span class="token operator">=</span> b<span class="token punctuation">;</span>   <span class="token comment">//此时b和c其实是一样的</span>  <span class="token comment">//用指针访问对象（仅适用于有效指针）</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>   <span class="token comment">//用解引用符*得到原指针指向的对象的值</span><span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span>  <span class="token comment">//此时a的值被赋成0x7fff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>指针的定义</strong>：允许一行对多个指针类型进行声明和定义<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p></li><li><p><strong>空指针</strong></p><ul><li>一般要用<code>nullptr</code>进行初始化</li><li>空指针不能使用解引用符进行解引用</li></ul></li><li><p><strong>关于<code>void</code></strong></p><ul><li><code>void</code>是一种比较特殊的指针类型，可以<strong>指向任意对象</strong>，存放任意对象的地址，但是也仅限于存放，<strong>不能进行访问</strong>，也不可以直接操作<code>void*</code>所指的对象。</li><li>void可以做的事：<strong>和其他指针进行比较</strong>、<strong>作为函数的输入和输出</strong>、<strong>或者赋值给另外一个<code>void*</code>指针</strong>。</li></ul></li><li><p><strong>指向指针的指针</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token comment">//b指向的是“int型”</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment">//c指向的是“指向int的指针”</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p></li><li><p><strong>对指针的引用</strong><br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p></li></ol><h3 id="指针数组和数组指针">指针数组和数组指针</h3><ol type="1"><li><p><strong>基本解释</strong>（参考这篇<a href="https://blog.csdn.net/men_wen/article/details/52694069">博客</a>)</p><blockquote><p><strong>指针数组</strong>：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。</p><p><strong>数组指针</strong>：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。`</p></blockquote></li><li><p><strong>指针数组</strong></p><ul><li>指针数组的定义<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>函数形参使用指针数组<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//first method</span><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token comment">//second method</span><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>数组指针</strong></p><ul><li>数组指针的定义(<strong>注意此时是<code>(*p)</code></strong>)<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//p1和p2都是指向二维数组a的首地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>函数形参使用二维数组可用数组指针<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token function">f1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">f2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>### 指针函数，函数指针和函数指针数组</li></ul></li><li><p><strong>指针函数</strong></p><ul><li>定义：指针函数就是<strong>返回指针值的函数</strong>，本质是一个函数。所以指针函数等价于“返回值为指针的函数”</li><li>用法：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">GetNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//指针函数声明形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>由此可以看出，指针函数的本质仍然是函数，可以把它当作一般函数来声明和使用。</li></ul></li><li><p><strong>函数指针</strong></p><ul><li>定义：函数指针就是一个<strong>指向函数的指针</strong>。每个函数在编译时，会被分配一个入口地址，一般用函数名来表示，这个地址就是该函数的指针。</li><li>用法1：（基础用法）<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">&gt;</span>b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//定义一个指向该函数形式的指针变量</span>    func <span class="token operator">=</span> max<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>用法2：（typedef）<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">&gt;</span>b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    func newfunc <span class="token operator">=</span> max<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">newfunc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>函数指针数组</strong></p><ul><li>定义：顾名思义，就是每个元素都是函数指针的数组，直接在函数指针名后面加上数组符号[]即可。</li><li>用法<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f3"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//定义三个函数指针</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>f1<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>f2<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pf3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>f3<span class="token punctuation">;</span>    <span class="token comment">//接下来就是定义一个数组把他们三个装进去。</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pfarr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pfunarr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfunarr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pfun<span class="token punctuation">;</span>    pfunarr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pfun2<span class="token punctuation">;</span>    pfunarr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> pfun3<span class="token punctuation">;</span>    <span class="token comment">/*  或者这样赋值    pfunarr[0] = &amp;fun1;    pfunarr[1] = &amp;fun2;    pfunarr[2] = &amp;fun3;    */</span>    pfunarr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfunarr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfunarr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*  或者这样调用    (*pfunarr[0])();    (*pfunarr[1])();    (*pfunarr[2])();}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>从上述代码中也可以看出来，函数名实际上就是函数地址，这一点与数组有异曲同工之妙。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P8_MIPS微系统（板级验证）</title>
      <link href="/2021/12/25/co/co-p8-mips-wei-xi-tong-ban-ji-yan-zheng/"/>
      <url>/2021/12/25/co/co-p8-mips-wei-xi-tong-ban-ji-yan-zheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mips微系统设计方案">MIPS微系统设计方案</h2><h3 id="设计概述">设计概述</h3><p>本文设计的是由Verilog实现的MIPS微系统，该微系统支持45条MIPS汇编指令（不含乘除指令），支持系统中断，最终实现在FPGA（可编程逻辑门阵列）上的系统验证。</p><p><img src="xlinx.png" alt="xlinx"></p><p>为了实现该功能，我们需要对P7工程代码进行一定修改，包括删除乘除指令模块和系统任务使其可综合、增加Tube、UART、GPIO等外设驱动模块、对系统桥Bridge进行调整等等。</p><p><img src="P8结构模型.png" alt="P8结构模型"></p><h3 id="实现指令说明">实现指令说明</h3><p>我们将本CPU实现的指令分为以下几类：</p><ul><li><p><strong>calc_R</strong>: add,sub,addu, subu, and, or, nor, xor,slt, sltu</p></li><li><p><strong>calc_I</strong>: addi,addiu, andi, ori, xori, slti,sltiu</p></li><li><p><strong>shift</strong>: sll, sra, srl</p></li><li><p><strong>shiftv</strong>: sllv, srav, srlv</p></li><li><p><strong>load</strong>: lw, lh, lhu, lb, lbu</p></li><li><p><strong>store</strong>: sw, sh, sb</p></li><li><p><strong>B类</strong>：beq,bne,bgtz,blez,bgez,bltz</p></li><li><p><strong>J类</strong>：j, jal, jr, jalr</p></li><li><p><strong>特殊</strong>：lui</p></li><li><p><strong>CP0相关指令</strong>：mfc0，mtc0</p></li><li><p><strong>异常中断返回：</strong> eret</p></li></ul><h2 id="工程模块定义">工程模块定义</h2><p>该部分我们仅介绍与P7不同的模块——Bridge，Tube，UART，GPIO</p><h3 id="fpga_top顶层模块">fpga_top（顶层模块）</h3><p>该模块替代P7中的mips模块，增加了和外设（数码管、LED等等）通信的IO接口。</p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk_in</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>sys_rstn</td><td>I</td><td>1</td><td>低电平同步复位信号</td></tr><tr class="odd"><td>dip_swithc0</td><td>I</td><td>8</td><td>第0组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc1</td><td>I</td><td>8</td><td>第1组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc2</td><td>I</td><td>8</td><td>第2组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc3</td><td>I</td><td>8</td><td>第3组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc4</td><td>I</td><td>8</td><td>第4组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc5</td><td>I</td><td>8</td><td>第5组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc6</td><td>I</td><td>8</td><td>第6组拨码开关控制信号</td></tr><tr class="even"><td>dip_switch7</td><td>I</td><td>8</td><td>第7组拨码开关控制信号</td></tr><tr class="odd"><td>user_key</td><td>I</td><td>8</td><td>用户按键开关控制信号</td></tr><tr class="even"><td>led_light</td><td>O</td><td>31</td><td>LED灯控制信号</td></tr><tr class="odd"><td>digital_tube2</td><td>O</td><td>8</td><td>第2组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel2</td><td>O</td><td>1</td><td>第2组四段数码管片选信号</td></tr><tr class="odd"><td>digital_tube1</td><td>O</td><td>8</td><td>第1组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel1</td><td>O</td><td>3</td><td>第1组四段数码管片选信号</td></tr><tr class="odd"><td>digital_tube0</td><td>O</td><td>8</td><td>第0组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel0</td><td>O</td><td>3</td><td>第0组四段数码管片选信号</td></tr><tr class="odd"><td>uart_rxd</td><td>I</td><td>1</td><td>UART接收信号</td></tr><tr class="even"><td>uart_txd</td><td>O</td><td>1</td><td>UART发送信号</td></tr></tbody></table><h3 id="bridge系统桥">Bridge（系统桥）</h3><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>高电平同步复位信号</td></tr><tr class="odd"><td>A_in</td><td>I</td><td>32</td><td>写入/读取的外设单元的地址</td></tr><tr class="even"><td>WD_in</td><td>I</td><td>32</td><td>写入外设单元的数据</td></tr><tr class="odd"><td>byteen</td><td>I</td><td>4</td><td>写入外设单元的使能</td></tr><tr class="even"><td>DM_RD</td><td>I</td><td>32</td><td>DM读取值的输入</td></tr><tr class="odd"><td>Timer_RD</td><td>I</td><td>32</td><td>Timer读取值的输入</td></tr><tr class="even"><td>UART_RD</td><td>I</td><td>32</td><td>UART读取值的输入</td></tr><tr class="odd"><td>Tube_RD</td><td>I</td><td>32</td><td>Tube读取值的输入</td></tr><tr class="even"><td>GPIO_RD</td><td>I</td><td>32</td><td>GPIO读取值的输入</td></tr><tr class="odd"><td>A_out</td><td>O</td><td>32</td><td>写入/读取的外设单元的地址</td></tr><tr class="even"><td>WD_out</td><td>O</td><td>32</td><td>写入外设单元的数据</td></tr><tr class="odd"><td>RD_out</td><td>O</td><td>32</td><td>外设单元的读取值输出</td></tr><tr class="even"><td>DM_WE</td><td>O</td><td>4</td><td>DM写入使能</td></tr><tr class="odd"><td>Timer_WE</td><td>O</td><td>1</td><td>Timer写入使能</td></tr><tr class="even"><td>UART_WE</td><td>O</td><td>1</td><td>UART写入使能</td></tr><tr class="odd"><td>Tube_WE</td><td>O</td><td>4</td><td>Tube写入使能</td></tr><tr class="even"><td>GPIO_WE</td><td>O</td><td>4</td><td>GPIO写入使能</td></tr><tr class="odd"><td>UART_STB</td><td>O</td><td>1</td><td>UART片选信号</td></tr></tbody></table><h3 id="tube数码管驱动模块">Tube（数码管驱动模块）</h3><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>高电平同步复位信号</td></tr><tr class="odd"><td>A</td><td>I</td><td>32</td><td>读/写数码管的地址</td></tr><tr class="even"><td>WD</td><td>I</td><td>32</td><td>写入数码管的数据</td></tr><tr class="odd"><td>WE</td><td>I</td><td>1</td><td>数码管写入使能</td></tr><tr class="even"><td>RD</td><td>I</td><td>32</td><td>数码管读取数据</td></tr><tr class="odd"><td>digital_tube2</td><td>O</td><td>8</td><td>第2组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel2</td><td>O</td><td>1</td><td>第2组四段数码管片选信号</td></tr><tr class="odd"><td>digital_tube1</td><td>O</td><td>8</td><td>第1组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel1</td><td>O</td><td>3</td><td>第1组四段数码管片选信号</td></tr><tr class="odd"><td>digital_tube0</td><td>O</td><td>8</td><td>第0组四段数码管驱动信号</td></tr><tr class="even"><td>digital_tube_sel0</td><td>O</td><td>3</td><td>第0组四段数码管片选信号</td></tr></tbody></table><h3 id="gpio通用io驱动模块">GPIO（通用IO驱动模块）</h3><p>该模块位于CPU模块中，主要用于获取外部中断信息和内部异常信息，进行判断后输出异常/中断请求。同时该模块中设有四个寄存器——SR，Cause，EPC和PRIP。</p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr class="odd"><td>A</td><td>I</td><td>32</td><td>读GPIO的地址</td></tr><tr class="even"><td>WD</td><td>I</td><td>32</td><td>写入GPIO的数据</td></tr><tr class="odd"><td>WE</td><td>I</td><td>1</td><td>GPIO写入使能</td></tr><tr class="even"><td>dip_swithc0</td><td>I</td><td>8</td><td>第0组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc1</td><td>I</td><td>8</td><td>第1组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc2</td><td>I</td><td>8</td><td>第2组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc3</td><td>I</td><td>8</td><td>第3组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc4</td><td>I</td><td>8</td><td>第4组拨码开关控制信号</td></tr><tr class="odd"><td>dip_swithc5</td><td>I</td><td>8</td><td>第5组拨码开关控制信号</td></tr><tr class="even"><td>dip_swithc6</td><td>I</td><td>8</td><td>第6组拨码开关控制信号</td></tr><tr class="odd"><td>dip_switch7</td><td>I</td><td>8</td><td>第7组拨码开关控制信号</td></tr><tr class="even"><td>user_key</td><td>I</td><td>8</td><td>用户按键开关控制信号</td></tr><tr class="odd"><td>RD</td><td>O</td><td>8</td><td>GPIO的读取数据</td></tr><tr class="even"><td>led_light</td><td>O</td><td>32</td><td>LED灯控制信号</td></tr></tbody></table><h3 id="uart模块">UART模块</h3><p>该模块为系统桥，实际上是区分地址的组合逻辑模块，用于CPU和DM、Timer1、Timer0之间的的数据交换。</p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CLK_I</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>RST_I</td><td>I</td><td>1</td><td>高电平同步复位信号</td></tr><tr class="odd"><td>ADD_I</td><td>I</td><td>3（[4:2]）</td><td>读/写UART的地址</td></tr><tr class="even"><td>WE_I</td><td>I</td><td>1</td><td>UART写使能信号（和CPU交互）</td></tr><tr class="odd"><td>DAT_I</td><td>I</td><td>32</td><td>UART写入数据（和CPU交互）</td></tr><tr class="even"><td>STB_I</td><td>I</td><td>1</td><td>UART片选信号输入</td></tr><tr class="odd"><td>RxD</td><td>I</td><td>1</td><td>UART接收数据（和外设交互）</td></tr><tr class="even"><td>DAT_O</td><td>O</td><td>32</td><td>UART读取数据（和CPU交互）</td></tr><tr class="odd"><td>ACK_O</td><td>O</td><td>1</td><td>UART片选信号输出</td></tr><tr class="even"><td>TxD</td><td>O</td><td>1</td><td>UART发送数据（和外设交互）</td></tr><tr class="odd"><td>inter</td><td>O</td><td>1</td><td>中断请求信号</td></tr></tbody></table><h2 id="重要机制实现方法">重要机制实现方法</h2><h3 id="ip-core-的使用和相关调整">IP Core 的使用和相关调整</h3><p>因为在P8实验中，为了使得我们的微系统是“可综合的”，我们需要将<strong>用常规方法描述的DM和IM</strong>删去，同时用FPGA内封装好的特殊功能部件——“<strong>块储存器</strong>”（<strong>“IP核”的一种</strong>）来替换。我们在ISE中生成后，直接在我们的微系统中调用即可。调用模板如</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">IM <span class="token function">u_IM</span><span class="token punctuation">(</span><span class="token comment">//input</span>        <span class="token punctuation">.</span>clka           <span class="token punctuation">(</span> clk_in                    <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input clka</span>        <span class="token punctuation">.</span>addra          <span class="token punctuation">(</span> IM_A               <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input [11 : 0] addra</span>        <span class="token comment">//output</span>        <span class="token punctuation">.</span>douta          <span class="token punctuation">(</span> IM_RD              <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>  <span class="token comment">// output [31 : 0] douta</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>DM u_DM <span class="token punctuation">(</span><span class="token comment">//input</span>        <span class="token punctuation">.</span>clka           <span class="token punctuation">(</span> clk_in                    <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input clka</span>        <span class="token punctuation">.</span>wea            <span class="token punctuation">(</span> Bridge_DM_WE       <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input [3 : 0] wea</span>        <span class="token punctuation">.</span>addra          <span class="token punctuation">(</span> DM_A               <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input [11 : 0] addra</span>        <span class="token punctuation">.</span>dina           <span class="token punctuation">(</span> Bridge_RD_out      <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input [31 : 0] dina</span>        <span class="token comment">//output</span>        <span class="token punctuation">.</span>douta          <span class="token punctuation">(</span> DM_RD              <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>  <span class="token comment">// output [31 : 0] douta</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与我们之前使用的IM和DM不同，P8中使用的块储存器是<strong>“同步读出”</strong>，这种行为差异造成了数据读出的时机不同，为了适应这一变化，需要对流水线的结构作出一定的修改。笔者采用的是<strong>修改流水寄存器</strong>的方法，即<strong>短接法</strong>。教程中的描述为——</p><blockquote><p><strong>修改流水级寄存器</strong>。由于 Block RAM/ROM的读端口可以抽象成组合逻辑与寄存器的连接，而 P6/P7的流水线则是将组合逻辑读出的值输入 M/W 级流水寄存器；因此若将 M/W级流水寄存器中的流水m_data_rdata的寄存器短接，就等价于将 Block RAM读出端的"寄存器"移到了 M/W流水寄存器上。这样修改后，流水线的结构与修改前几乎是相同的。</p></blockquote><p>此外，我们该需要对D级流水寄存器和Bridge进行相应调整</p><ul><li><p><strong>D级寄存器</strong>的调整：为保证D级发生阻塞时，指令被正确地 stall 在 D级，我们需要D级流水寄存器中增加一个l临时寄存器来存储<strong>上一次在D级的instruction</strong>。然后再通过一个选择信号来选择当前进入D级的instruction是<strong>IM同步读出的instrcution</strong>还是<strong>临时寄存器中的instruction</strong>。清空延迟槽时<strong>将D级instruction置0</strong>的操作也类似。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//D级流水寄存器</span><span class="token keyword">reg</span>        stall_tag<span class="token punctuation">;</span>    <span class="token keyword">reg</span>        clr_tag<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> last_instr_reg<span class="token punctuation">;</span>    <span class="token keyword">assign</span> D_instr <span class="token operator">=</span> clr_tag   <span class="token operator">?</span> <span class="token number">32'd0</span> <span class="token punctuation">:</span>                     stall_tag <span class="token operator">?</span> last_instr_reg <span class="token punctuation">:</span>                                  F_instr<span class="token punctuation">;</span>                                        <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token keyword">begin</span>            last_instr_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>             stall_tag      <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>             clr_tag        <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>         <span class="token keyword">else</span> <span class="token keyword">begin</span>            last_instr_reg <span class="token operator">&lt;=</span> D_instr<span class="token punctuation">;</span>            stall_tag      <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>en<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>            clr_tag        <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>reset <span class="token operator">|</span> req <span class="token operator">|</span> BD_clr<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Bridge</strong>的调整：由于Bridge沟通的外设既有同步读的DM，也有异步读的Timer，Tube，UART，GPIO等设备，这样在Bridge向CPU传数据的时候会产生冲突。因此笔者将他们的读方式统一成“同步读”，方法是——在Bridge为每一个外设设置一个数据寄存器（DM除外），每个时钟上升沿更新<strong>从这些外设中异步读出的值</strong>。此外，我们还需要将<strong>被访问的外设的地址</strong>存进一个临时寄存器，每次根据这个<strong>临时寄存器</strong>的地址从若干<strong>数据寄存器</strong>中选择相应的值，返回到CPU中。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//read</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Timer_RD_reg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> UART_RD_reg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Tube_RD_reg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> GPIO_RD_reg<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A_reg<span class="token punctuation">;</span>                <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        Timer_RD_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>          UART_RD_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>         Tube_RD_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        GPIO_RD_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        A_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        Timer_RD_reg <span class="token operator">&lt;=</span> Timer_RD<span class="token punctuation">;</span>          UART_RD_reg <span class="token operator">&lt;=</span> UART_RD<span class="token punctuation">;</span>         Tube_RD_reg <span class="token operator">&lt;=</span> Tube_RD<span class="token punctuation">;</span>        GPIO_RD_reg <span class="token operator">&lt;=</span> GPIO_RD<span class="token punctuation">;</span>        A_reg <span class="token operator">&lt;=</span> A_in<span class="token punctuation">;</span>     <span class="token keyword">end</span><span class="token keyword">end</span> <span class="token keyword">assign</span> RD_out <span class="token operator">=</span> <span class="token punctuation">(</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h0</span>    <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h2fff</span><span class="token punctuation">)</span> <span class="token operator">?</span> DM_RD <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h7f00</span> <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h7f0b</span><span class="token punctuation">)</span> <span class="token operator">?</span> Timer_RD_reg <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h7f20</span> <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h7f3b</span><span class="token punctuation">)</span> <span class="token operator">?</span> UART_RD_reg <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h7f40</span> <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h7f47</span><span class="token punctuation">)</span> <span class="token operator">?</span> Tube_RD_reg <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h7f50</span> <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h7f5b</span> <span class="token operator">||</span>A_reg <span class="token operator">&gt;=</span> <span class="token number">32'h7f60</span> <span class="token operator">&amp;&amp;</span> A_reg <span class="token operator">&lt;=</span> <span class="token number">32'h7f63</span><span class="token punctuation">)</span> <span class="token operator">?</span> GPIO_RD_reg <span class="token punctuation">:</span> <span class="token number">32'd0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数码管驱动设计">数码管驱动设计</h3><p>数码管驱动中有两个寄存器，和对其他外设的操作一样，我们需要实现CPU对寄存器的读写。代码比较简单，如下所示</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tube_0_data<span class="token punctuation">;</span>   <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tube_1_data<span class="token punctuation">;</span>   <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  tube_2_data<span class="token punctuation">;</span>   <span class="token comment">//read</span>   <span class="token keyword">assign</span> RD <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f40</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f43</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span>tube_1_data<span class="token punctuation">,</span> tube_0_data<span class="token operator">}</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f44</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f47</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span><span class="token number">28'd0</span><span class="token punctuation">,</span>  tube_2_data<span class="token operator">}</span> <span class="token punctuation">:</span>                                                   <span class="token number">32'd0</span><span class="token punctuation">;</span>      <span class="token comment">//write</span>   <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>       <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token keyword">begin</span>           tube_0_data <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>            tube_1_data <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>           tube_2_data <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">end</span>       <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">|</span> WE<span class="token punctuation">)</span> <span class="token keyword">begin</span>           <span class="token function">if</span><span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f40</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f43</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tube_0_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tube_0_data<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tube_1_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tube_1_data<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>                 <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f44</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f47</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tube_2_data <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">end</span>       <span class="token keyword">end</span>   <span class="token keyword">end</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在数码管驱动设计中，我们不仅要能够向驱动中的寄存器读写数据，还要根据驱动内部寄存器的值向真正的数码管传递对应的电平信号，来控制数码管的亮灭。四段数码管为一组，每组数码管由一个驱动信号、一个片选信号控制。原理如下</p><p><img src="八段数码管png.png"></p><p>一段数码管显示的16进制数与控制信号的关系如下表所示(注意：实验中采用的是共阳极数码管，低电平时亮，高电平时灭)</p><table><thead><tr class="header"><th style="text-align: center;">数码管显示的16进制数</th><th style="text-align: center;">数码管控制信号{DP,G,F,E,D,C,B,A}</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0xC0</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">0xF9</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">0xA4</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">0xB0</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">0x99</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">0x92</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">0x82</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">0xF8</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">0x80</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">0x90</td></tr><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">0x88</td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">0x83</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">0xC6</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">0xA1</td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">0x86</td></tr><tr class="even"><td style="text-align: center;">F</td><td style="text-align: center;">0x8E</td></tr></tbody></table><p>为实现该功能，笔者设计了单独的模块<code>Monitor</code>来对一组数码管的亮灭进行控制，直接在<code>Tube</code>模块中调用即可。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Moniter</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>             clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>             reset<span class="token punctuation">,</span>    <span class="token keyword">input</span>      <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tube_data<span class="token punctuation">,</span>    <span class="token keyword">output</span>     <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  tube_disp<span class="token punctuation">,</span>    <span class="token keyword">output</span>     <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  sel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span>        <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span>    <span class="token keyword">reg</span>        <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  sel_reg<span class="token punctuation">;</span>    <span class="token keyword">reg</span>               reset_tag<span class="token punctuation">;</span>    <span class="token keyword">wire</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> E<span class="token punctuation">,</span> F<span class="token punctuation">,</span> G<span class="token punctuation">,</span> DP<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sel_data <span class="token operator">=</span> <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">4'b0001</span><span class="token punctuation">)</span> <span class="token operator">?</span> tube_data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token punctuation">:</span>                          <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">4'b0010</span><span class="token punctuation">)</span> <span class="token operator">?</span> tube_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token punctuation">:</span>                          <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">4'b0100</span><span class="token punctuation">)</span> <span class="token operator">?</span> tube_data<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token punctuation">:</span>                                             tube_data<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">assign</span> sel <span class="token operator">=</span> reset_tag <span class="token operator">?</span> <span class="token number">4'b1111</span> <span class="token punctuation">:</span> sel_reg<span class="token punctuation">;</span>     <span class="token keyword">assign</span> tube_disp <span class="token operator">=</span> reset_tag <span class="token operator">?</span> <span class="token number">8'b1111_1110</span> <span class="token punctuation">:</span> <span class="token operator">{</span>DP<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> E<span class="token punctuation">,</span> F<span class="token punctuation">,</span> G<span class="token operator">}</span><span class="token punctuation">;</span>     <span class="token keyword">assign</span> <span class="token operator">{</span>DP<span class="token punctuation">,</span> G<span class="token punctuation">,</span> F<span class="token punctuation">,</span> E<span class="token punctuation">,</span> D<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token operator">}</span> <span class="token operator">=</span>  <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'hc0</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'hf9</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'ha4</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h3</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'hb0</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h4</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h99</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h5</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h92</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h6</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h82</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h7</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'hf8</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h8</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h80</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'h9</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h90</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'ha</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h88</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'hb</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h83</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'hc</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'hc6</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'hd</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'ha1</span> <span class="token punctuation">:</span>                                        <span class="token punctuation">(</span>sel_data <span class="token operator">==</span> <span class="token number">4'he</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">8'h86</span> <span class="token punctuation">:</span>                                                             <span class="token number">8'h8e</span> <span class="token punctuation">;</span>        <span class="token comment">//reset_reg fsm</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> reset_tag <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>      reset_tag <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token comment">//sel_reg fsm</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> sel_reg <span class="token operator">&lt;=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token constant">`MAX</span> <span class="token operator">-</span> <span class="token number">32'd1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            sel_reg <span class="token operator">&lt;=</span> <span class="token operator">{</span>sel_reg<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sel_reg<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token comment">//cnt fsm</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> cnt <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span>            <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token constant">`MAX</span> <span class="token operator">-</span> <span class="token number">32'd1</span><span class="token punctuation">)</span> cnt <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">32'd1</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">endmodule</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通用io驱动设计">通用IO驱动设计</h3><p>通用IO包括三部分——<strong>64 位用户输入微动开关</strong>、 <strong>8个通用按键开关和LED</strong>、<strong>LED</strong>。前两个是输入设备，只有LED是输出设备。</p><ul><li><p>对于输入设备（<strong>64 位用户输入微动开关</strong>、 <strong>8个通用按键开关</strong>）而言，外部传来的数据只有在<strong>CPU读取该设备数据的时候</strong>才是有效的，也就是说，在CPU读其他外设时，无论该输入设备输进什么值，都是无效值，也就没有必要用寄存器将外界读取的值存储下来，只需要将输入设备的引脚直接连接到控制模块的读数据端口，使CPU 将它们当作一个只读的寄存器。</p></li><li><p>对于输出设备（<strong>LED</strong>）而言，每次CPU写进设备驱动的数据都应该保存下来，这样才能保证CPU读写其他外设时，该驱动仍然向<strong>真正的输出外设</strong>稳定地输出数据。</p></li></ul><p>整体写法也比较简单，如下所示——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led_reg<span class="token punctuation">;</span>      <span class="token comment">//led display</span>   <span class="token keyword">assign</span> led_light <span class="token operator">=</span> <span class="token operator">~</span>led_reg<span class="token punctuation">;</span>       <span class="token comment">//read</span>   <span class="token keyword">assign</span> RD <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f50</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f53</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">~{</span>dip_switch3<span class="token punctuation">,</span> dip_switch2<span class="token punctuation">,</span> dip_switch1<span class="token punctuation">,</span> dip_switch0<span class="token operator">}</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f54</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f57</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">~{</span>dip_switch7<span class="token punctuation">,</span> dip_switch6<span class="token punctuation">,</span> dip_switch5<span class="token punctuation">,</span> dip_switch4<span class="token operator">}</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f58</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f5b</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span><span class="token number">24'd0</span><span class="token punctuation">,</span> <span class="token operator">~</span>user_key<span class="token operator">}</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>A <span class="token operator">&gt;=</span> <span class="token number">32'h7f60</span> <span class="token operator">&amp;&amp;</span> A <span class="token operator">&lt;=</span> <span class="token number">32'h7f63</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span>led_reg<span class="token operator">}</span> <span class="token punctuation">:</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>   <span class="token comment">//write</span>   <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>       <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> led_reg <span class="token operator">&lt;=</span> <span class="token number">32'hffff_ffff</span><span class="token punctuation">;</span>       <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">|</span> WE<span class="token punctuation">)</span> <span class="token keyword">begin</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> led_reg<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> led_reg<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>  <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> led_reg<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token function">if</span><span class="token punctuation">(</span>WE<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> led_reg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> WD<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>   <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="uart的修改">UART的修改</h3><p>为了实现UART中断功能，即<strong>接收到一次完整的数据后向CPU产生中断信号，CPU对其进行响应</strong>，我们需要对UART进行一定的修改。其实也比较简单，仔细阅读高老板的代码后就知道，只需要两行代码即可实现。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">output</span> inter<span class="token punctuation">;</span><span class="token keyword">assign</span> inter <span class="token operator">=</span> rs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实现串口通信的mips代码也比较简单</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">.</span>textli<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f20li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">0</span>xfff1mtc0<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>loop<span class="token punctuation">:</span>beq<span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> loopnop<span class="token punctuation">.</span>ktext <span class="token number">0</span>x4180lw<span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span> eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Warning:一定要修改UART的头文件中有关时钟频率的宏定义（根据教程来，一般是将时钟频率改为50MHz）！否则会导致波特率不匹配！</li></ul><h3 id="软件代码编写计算器和计数器">软件代码编写——计算器和计数器</h3><p>硬件搭好后，我们可以编写mips程序（即软件），将机器码加载进IM中，这样就可以通过软硬件的交互实现一定的功能。下面说明<strong>计算器</strong>和<strong>计数器</strong>两个题目的软件代码的编写</p><p><strong>1.计算器</strong></p><ul><li><p>题目描述</p><blockquote><p>用 64 个拨码开关输入 2 个操作数，其中第 7~4 组代表第一个操作数，第3~0 组代表第二个操作数。用 8 个用户按键代表 8种二元运算（可自行定义）。每次按下一个用户按键后（假设同一时刻至多有 1个用户按键会被按下），将对应的运算结果输出至数码管。当没有用户按键按下时，保持之前的结果。</p></blockquote></li><li><p>mips代码<br></p><pre class="line-numbers language-mips" data-language="mips"><code class="language-mips">li$s0, 0x7f58li$s1, 0x7f54li$s2, 0x7f50li$s3, 0x7f40loop:    lw$t1, 0($s1)    lw$t2, 0($s2)    lbu$t0, 0($s0)    #li$v0, 5    #syscall    #move  $t1, $v0    #li$v0, 5    #syscall    #move  $t2, $v0    #li$v0, 5    #syscall    #move  $t0, $v0        switch:        op_1:        li$t3, 1        bne$t0, $t3, op_2        nop        add$t4, $t1, $t2        jswitch_end                op_2:        li$t3, 2        bne$t0, $t3, op_3        nop        sub$t4, $t1, $t2        jswitch_end                op_3:        li$t3, 4        bne$t0, $t3, op_4        nop        and$t4, $t1, $t2        jswitch_end                op_4:        li$t3, 8        bne$t0, $t3, op_5        nop        or$t4, $t1, $t2        jswitch_end                op_5:        li$t3, 16        bne$t0, $t3, op_6        nop        xor$t4, $t1, $t2        jswitch_end                op_6:        li$t3, 32        bne$t0, $t3, op_7        nop        sllv$t4, $t1, $t2        jswitch_end                op_7:        li$t3, 64        bne$t0, $t3, op_8        nop        srlv$t4, $t1, $t2        jswitch_end                op_8:        li$t3, 128        bne$t0, $t3, switch_end        nop        srav$t4, $t1, $t2            switch_end:                sw$t4, 0($s3)        #move$a0, $t4        #li$v0, 1        #syscall    jloop    nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul><p><strong>2.计数器的实现</strong><br>- 题目描述<br>&gt;用第 3~0组拨码开关输入一个初始值。当系统复位后，程序读取拨码开关的值并从这个值开始向下计数（每秒减1）至0，你需要使用 timer来实现此功能。当程序运行时，若拨码开关的值发生变化，则重新从拨码开关读取初值，并重新计数。<br>- mips代码<br></p><pre class="line-numbers language-mips" data-language="mips"><code class="language-mips">.ktext 0x4180handler:beq$t2, $0, endnopaddi$t2, $t2, -1end: eret.text#interrupt  enableori$s0, 0xfff1mtc0$s0, $12li$s0, 0x7f50    #inputli$s1, 0x7f40    #displayli$s2, 0x7f00li$s3, 0x7f04li$s4, 0xbli$s5, 25000000li$s5, 25# t0 is input-value# t1 is max-value# t2 is value counterloop: lw$t0, 0($s0)sw$t2, 0($s1)beq$t0, $t1, loopnopbegin:sw$0, 0($s2)move$t1, $t0move$t2, $t0sw$s5, 0($s3)sw$s4, 0($s2)jloopnop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="自动化生成coe文件">自动化生成coe文件</h2><p>当我们写完软件部分的代码时，需要将其转换成机器码，同时还需要根据coe文件格式进行一定处理——文件开头加相应前缀，每行机器码后面需要加逗号。如果手动进行修改的话费时费力，可以通过下面的python脚本自动生成coe文件。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> osmips_code_path <span class="token operator">=</span> <span class="token string">"uart.asm"</span>mips_handler_path <span class="token operator">=</span> <span class="token string">"mips_handler.asm"</span><span class="token keyword">def</span> <span class="token function">run_mars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar Mars_perfect.jar nc a db mc CompactDataAtZero dump 0x00003000-0x0000417c HexText text.txt "</span> <span class="token operator">+</span> mips_code_path<span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar Mars_perfect.jar nc a db mc CompactDataAtZero dump 0x00004180-0x00004f00 HexText ktext.txt "</span> <span class="token operator">+</span> mips_handler_path<span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">r"text.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> textfile<span class="token punctuation">:</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">r"ktext.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ktextfile<span class="token punctuation">:</span>            <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">r"code.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> codefile<span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0x3000</span><span class="token punctuation">,</span><span class="token number">0x4180</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>                    ret1 <span class="token operator">=</span>textfile<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>ret1<span class="token punctuation">)</span><span class="token punctuation">:</span>                        codefile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>ret1<span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        codefile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"00000000\n"</span><span class="token punctuation">)</span>                codefile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>ktextfile<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">"ktext.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    run_mars<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        data <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">",\n"</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">";\n"</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>mips_code_path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"coe"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"memory_initialization_radix=16;\nmemory_initialization_vector=\n"</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P7_MIPS微系统（异常中断）</title>
      <link href="/2021/12/15/co/co-p7-mips-wei-xi-tong-yi-chang-zhong-duan/"/>
      <url>/2021/12/15/co/co-p7-mips-wei-xi-tong-yi-chang-zhong-duan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mips微系统设计方案">MIPS微系统设计方案</h2><h3 id="设计概述">设计概述</h3><p>​本文设计的是由Verilog实现的MIPS微系统，该微系统支持53条MIPS汇编指令，为了实现该功能，笔者设计了IFU，GRF，NPC，CMP，EXT，ALU，D_Reg，E_Reg，M_Reg，W_Reg，MCU，HCU，MDU，BE，DE，CP0，Bridge，TC等关键模块。为实现微系统，我们需要对P6中CPU的结构层次进行一定的调整——将P6设计的CPU单独封装成一个模块，然后再设计Bridge、Timer0、Timer1三个外设，和CPU处于同一层次上。此外我们还需要在CPU的M流水级设计一个CP0模块用于中断异常处理。结构层次如下所示——</p><p><img src="微系统.png"></p><h3 id="实现指令说明">实现指令说明</h3><p>我们将本CPU实现的指令分为以下几类：</p><ul><li><p><strong>calc_R</strong>: add,sub,addu, subu, and, or, nor, xor,slt, sltu</p></li><li><p><strong>calc_I</strong>: addi,addiu, andi, ori, xori, slti,sltiu</p></li><li><p><strong>shift</strong>: sll, sra, srl</p></li><li><p><strong>shiftv</strong>: sllv, srav, srlv</p></li><li><p><strong>load</strong>: lw, lh, lhu, lb, lbu</p></li><li><p><strong>store</strong>: sw, sh, sb</p></li><li><p><strong>B类</strong>：beq,bne,bgtz,blez,bgez,bltz</p></li><li><p><strong>J类</strong>：j, jal, jr, jalr</p></li><li><p><strong>特殊</strong>：lui</p></li><li><p><strong>md类</strong>：mult, multu, div, divu</p></li><li><p><strong>mf类</strong>：mfhi, mflo</p></li><li><p><strong>mt类</strong>：mthi, mtlo</p></li><li><p><strong>CP0相关指令</strong>：mfc0，mtc0</p></li><li><p><strong>异常中断返回：</strong> eret</p></li></ul><h2 id="工程模块定义">工程模块定义</h2><p>该部分我们不再介绍P6中已经实现的模块，只介绍新增模块CPU（封装P6CPU），CP0，Bridge，TC（用于实例化Timer1，Timer0）。但是原有模块需要根据异常处理的实现需要进行微调。</p><h3 id="cpu模块">CPU模块</h3><p>该模块用于封装P6中的已经设计好的CPU（包括新模块CP0）</p><table><colgroup><col style="width: 20%"><col style="width: 6%"><col style="width: 6%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>lk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>同步复位信号</td></tr><tr class="odd"><td>inter_out</td><td>I</td><td>1</td><td>外部输入的中断信号</td></tr><tr class="even"><td>inter_T0</td><td>I</td><td>1</td><td>Timer0产生的中断信号</td></tr><tr class="odd"><td>inter_T1</td><td>I</td><td>1</td><td>Timer1产生的中断信号</td></tr><tr class="even"><td>i_inst_rdata</td><td>I</td><td>32</td><td>i_inst_addr队形的32位指令</td></tr><tr class="odd"><td>m_data_addr</td><td>I</td><td>32</td><td>m_data_addr 对应的 32 位数据</td></tr><tr class="even"><td>i_inst_addr</td><td>O</td><td>32</td><td>需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr class="odd"><td>m_data_addr</td><td>O</td><td>32</td><td>数据存储器待写入地址</td></tr><tr class="even"><td>m_data_wdata</td><td>O</td><td>32</td><td>数据存储器待写入数据</td></tr><tr class="odd"><td>m_data_byteen</td><td>O</td><td>4</td><td>字节使能信号（相当于之前的MenWrite信号）</td></tr><tr class="even"><td>m_inst_addr</td><td>O</td><td>32</td><td>M级PC</td></tr><tr class="odd"><td>w_grf_we</td><td>O</td><td>1</td><td>grf 写使能信号</td></tr><tr class="even"><td>w_grf_addr</td><td>O</td><td>5</td><td>grf 中待写入寄存器编号</td></tr><tr class="odd"><td>w_grf_wdata</td><td>O</td><td>32</td><td>grf 中待写入数据</td></tr><tr class="even"><td>w_inst_addr</td><td>O</td><td>32</td><td>W 级 PC</td></tr><tr class="odd"><td>spj_7f20</td><td>O</td><td>32</td><td>响应外部中断的标记寄存器</td></tr></tbody></table><h3 id="cp0模块">CP0模块</h3><p>该模块位于CPU模块中，主要用于获取外部中断信息和内部异常信息，进行判断后输出异常/中断请求。同时该模块中设有四个寄存器——SR，Cause，EPC和PRIP。</p><table><colgroup><col style="width: 13%"><col style="width: 5%"><col style="width: 10%"><col style="width: 31%"><col style="width: 38%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th><th>产生来源和机制</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td><td></td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>复位信号</td><td></td></tr><tr class="odd"><td>A1</td><td>I</td><td>5</td><td>读 CP0 寄存器编号</td><td>执行 <code>mfc0</code> 指令时产生</td></tr><tr class="even"><td>A2</td><td>I</td><td>5</td><td>写 CP0 寄存器编号</td><td>执行 <code>mtc0</code> 指令时产生</td></tr><tr class="odd"><td>D_in</td><td>I</td><td>32</td><td>CP0 寄存器的写入数据</td><td>执行 <code>mtc0</code> 指令时产生</td></tr><tr class="even"><td>pc</td><td>I</td><td>32</td><td>中断/异常时的 PC(M级pc)</td><td></td></tr><tr class="odd"><td>ExcCode_in</td><td>I</td><td>5</td><td>中断/异常的类型</td><td>异常功能部件</td></tr><tr class="even"><td>BD_in</td><td>I</td><td>1</td><td>分支延迟槽指令标志</td><td>M_BD输入</td></tr><tr class="odd"><td>HWInt</td><td>I</td><td>6([7:2])</td><td>6 个设备中断</td><td>外部设备</td></tr><tr class="even"><td>WE</td><td>I</td><td>1</td><td>CP0 寄存器写使能</td><td>执行 <code>mtc0</code> 指令时产生</td></tr><tr class="odd"><td>EXLClr</td><td>I</td><td>1</td><td>置 0 SR 的EXL 位</td><td>Eret_M控制信号输入</td></tr><tr class="even"><td>req</td><td>O</td><td>1</td><td>异常/中断请求</td><td>由 CP0 模块确认响应异常/中断</td></tr><tr class="odd"><td>EPC_out</td><td>O</td><td>32</td><td>EXC 寄存器输出</td><td>CP0 模块中的EPC寄存器</td></tr><tr class="even"><td>D_out</td><td>O</td><td>32</td><td>CP0 寄存器的输出数据</td><td>执行 <code>mfc0</code> 指令时产生</td></tr></tbody></table><h3 id="bridge模块">Bridge模块</h3><p>该模块为系统桥，实际上是区分地址的组合逻辑模块，用于CPU和DM、Timer1、Timer0之间的的数据交换。</p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>A_in</td><td>I</td><td>32</td><td>写入/读取的外设单元的地址</td></tr><tr class="even"><td>WD_in</td><td>I</td><td>32</td><td>写入外设单元的数据</td></tr><tr class="odd"><td>byteen</td><td>I</td><td>4</td><td>写入外设单元的使能</td></tr><tr class="even"><td>DM_RD</td><td>I</td><td>32</td><td>DM读取值的输入</td></tr><tr class="odd"><td>T1_RD</td><td>I</td><td>32</td><td>Timer1读取值的输入</td></tr><tr class="even"><td>T0_RD</td><td>I</td><td>32</td><td>Timer0读取值的输入</td></tr><tr class="odd"><td>A_out</td><td>O</td><td>32</td><td>写入/读取的外设单元的地址</td></tr><tr class="even"><td>WD_out</td><td>O</td><td>32</td><td>写入外设单元的数据</td></tr><tr class="odd"><td>RD_out</td><td>O</td><td>32</td><td>外设单元的读取值输出</td></tr><tr class="even"><td>DM_WE</td><td>O</td><td>4</td><td>DM写入使能</td></tr><tr class="odd"><td>T1_WE</td><td>O</td><td>1</td><td>Timer1写入使能</td></tr><tr class="even"><td>T0_WE</td><td>O</td><td>1</td><td>Timer2写入使能</td></tr></tbody></table><h3 id="tc模块">TC模块</h3><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr class="odd"><td>addr</td><td>I</td><td>30（[31:2]）</td><td>Timer写入地址</td></tr><tr class="even"><td>WE</td><td>I</td><td>1</td><td>Timer写入使能</td></tr><tr class="odd"><td>Din</td><td>I</td><td>32</td><td>Timer写入数据</td></tr><tr class="even"><td>Dout</td><td>O</td><td>32</td><td>Timer读取数据</td></tr><tr class="odd"><td>IRQ</td><td>O</td><td>1</td><td>中断请求</td></tr></tbody></table><h2 id="重要机制实现方法">重要机制实现方法</h2><h3 id="cp0响应机制">CP0响应机制</h3><p>CP0是检测异常和中断的重要部件，异常和中断通过以下接口传入——</p><ul><li><p><strong>中断信息</strong>通过 <strong>HWInt[7:2]</strong>接口进入，其中HWInt[2]连接Timer0的终端请求，HWInt[3]连接Timer1的终端请求，HWInt[4]连接外部的中断请求。</p></li><li><p><strong>异常信息</strong>通过<strong>ExcCode_in</strong>和<strong>BD_in</strong>两个接口传入，ExcCode_in传入的是异常代码（ADEL，ADES，RI，OV），BD_in传入的是延迟槽指令标志（有效则表示当前指令为延迟槽指令）。</p></li></ul><p>检测到中断或者异常时，CP0会进行判断并响应，决定是否将req(<strong>CP0向CPU发出的中断请求</strong>)置1。判断逻辑如下——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> inter_req  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>HWInt <span class="token operator">&amp;</span> IM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> IE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>EXL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中断有效判断</span><span class="token keyword">wire</span> exc_req    <span class="token operator">=</span> <span class="token punctuation">(</span>ExcCode_in <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>EXL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//异常有效判断</span><span class="token keyword">assign</span> req      <span class="token operator">=</span> inter_req <span class="token operator">|</span> exc_req<span class="token punctuation">;</span><span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当req有效，CP0还需要完成以下任务——</p><ul><li>EXL置1</li><li>将M级PC存入EPC（延迟槽指令中存入EPC-4）</li><li>如果当前响应中断，ExcCode寄存器写入0；若响应异常，ExcCode寄存器写入外部传入的异常代码ExcCode_in</li><li>BD寄存器写入外部传入的BD_in信号</li></ul><p>代码如下——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>       <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>       <span class="token comment">//………………………………………………………… </span>       <span class="token keyword">end</span>          <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token keyword">begin</span>           EXL <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>           EPC <span class="token operator">&lt;=</span> BD_in <span class="token operator">?</span> <span class="token punctuation">(</span>pc <span class="token operator">-</span> <span class="token number">32'd4</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> pc<span class="token punctuation">;</span>            ExcCode <span class="token operator">&lt;=</span> inter_req <span class="token operator">?</span> <span class="token number">5'd0</span> <span class="token punctuation">:</span> ExcCode_in<span class="token punctuation">;</span>           BD <span class="token operator">&lt;=</span> BD_in<span class="token punctuation">;</span>       <span class="token keyword">end</span>    <span class="token comment">//…………………………………………</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，无论是否发出中断请求，在每一周期均需要将HWInt[6:2]写入Cause寄存器中的的IP域</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>       <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>      <span class="token comment">//………………………………………………………… </span>       <span class="token keyword">end</span>       <span class="token keyword">else</span> <span class="token keyword">begin</span>           IP <span class="token operator">&lt;=</span> HWInt<span class="token punctuation">;</span>           <span class="token comment">//…………………………………………………………</span>       <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统桥设计">系统桥设计</h3><p>系统桥其实是充当一个“交换机”的角色，将CPU传来的地址写入相应的外设（DM、Timer0、Timer1），只需要组合逻辑便可实现。代码如下——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> A_out  <span class="token operator">=</span> A_in<span class="token punctuation">;</span>   <span class="token keyword">assign</span> WD_out <span class="token operator">=</span> WD_in<span class="token punctuation">;</span><span class="token keyword">assign</span> DM_WE  <span class="token operator">=</span> <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h0</span>    <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h2fff</span><span class="token punctuation">)</span> <span class="token operator">?</span> byteen  <span class="token punctuation">:</span> <span class="token number">4'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> T0_WE  <span class="token operator">=</span> <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h7f00</span> <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h7f0b</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>byteen <span class="token punctuation">:</span> <span class="token number">1'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> T1_WE  <span class="token operator">=</span> <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h7f10</span> <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h7f1b</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>byteen <span class="token punctuation">:</span> <span class="token number">1'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> RD_out <span class="token operator">=</span> <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h0</span>    <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h2fff</span><span class="token punctuation">)</span> <span class="token operator">?</span> DM_RD   <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h7f00</span> <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h7f0b</span><span class="token punctuation">)</span> <span class="token operator">?</span> T0_RD   <span class="token punctuation">:</span>                <span class="token punctuation">(</span>A_in <span class="token operator">&gt;=</span> <span class="token number">32'h7f10</span> <span class="token operator">&amp;&amp;</span> A_in <span class="token operator">&lt;=</span> <span class="token number">32'h7f1b</span><span class="token punctuation">)</span> <span class="token operator">?</span> T1_RD   <span class="token punctuation">:</span>                                                         <span class="token number">32'd0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常识别">异常识别</h3><p>P7中我们考虑的异常情况有以下几种——</p><ul><li>F级异常：<ul><li>PC地址没有字对齐（AdEL）</li><li>PC地址超过0x3000 ~ 0x6ffc（AdEL）</li></ul></li><li>D级异常：<ul><li>未知的指令码（RI）</li></ul></li><li>E级异常：<ul><li>addi、add、sub计算溢出（Ov）</li><li>load类指令计算地址时加法溢出（AdEL）</li><li>store类指令计算地址时加法溢出（AdES）</li></ul></li><li>M级异常：<ul><li>lw取数地址未 4 字节对齐（AdEL）</li><li>lh、lhu取数地址未与 2 字节对齐（AdEL）</li><li>lh、lhu、lb、lbu取 Timer 寄存器的值（AdEL）</li><li>load型指令取数地址超出 DM、Timer0、Timer1 的范围（AdEL）</li><li>sw存数地址未 4 字节对齐（AdES）</li><li>sh存数地址未 2 字节对齐（AdES）</li><li>sh、sb存 Timer 寄存器的值（AdES）</li><li>sw向计时器的 Count 寄存器存值（AdES）</li><li>store型指令存数地址超出 DM、Timer0、Timer1 的范围（AdES）</li></ul></li></ul><p>针对以上列出的异常情况，我们在每一个流水级对异常进行检测。由于教程提出了以下要求——</p><ul><li><p>发生取指异常后视为 <code>nop</code> 直至提交到 CP0。</p></li><li><p>发生 <code>RI</code> 异常后视为 <code>nop</code> 直至提交到CP0。</p></li><li><p><code>load</code> 与 <code>store</code> 类算址溢出按照<code>AdEL</code> 与 <code>AdES</code> 处理。</p></li></ul><p>因此不会出现<strong>一个指令在多级出现异常</strong>的情况。如果某个流水级出现了新的异常，我们将这个异常流水到下一级即可，而不是流水上一级传来的异常；如果这个流水级没有出现新的异常，则将上一级传来的异常继续流水给下一级即可。代码如下——<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//F级异常检测</span><span class="token keyword">assign</span> F_ExcCode <span class="token operator">=</span> <span class="token punctuation">(</span>F_pc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2'b00</span> <span class="token operator">||</span> F_pc <span class="token operator">&lt;</span> <span class="token number">32'h3000</span> <span class="token operator">||</span> F_pc <span class="token operator">&gt;</span> <span class="token number">32'h6ffc</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span> <span class="token number">5'd0</span><span class="token punctuation">;</span><span class="token comment">//D级异常检测（Invalid_D有效表示当前指令非法）</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_ExcCode_fixed <span class="token operator">=</span> <span class="token punctuation">(</span>Invalid_D<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`RI</span> <span class="token punctuation">:</span> D_ExcCode<span class="token punctuation">;</span>  <span class="token comment">//E级异常检测（IsAriOv_E表示当前指令是addi、add、sub中的一种，E_overflow表示ALU出现溢出）</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_ExcCode_fixed <span class="token operator">=</span>    <span class="token punctuation">(</span>E_overflow <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_LW</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_LH</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_LHU</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_LB</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_LBU</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span>                                    <span class="token punctuation">(</span>E_overflow <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_SW</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_SH</span> <span class="token operator">||</span> LSOp_E <span class="token operator">==</span> <span class="token constant">`LS_SB</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                           <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                    <span class="token punctuation">(</span>E_overflow <span class="token operator">&amp;&amp;</span> IsAriOv_E<span class="token punctuation">)</span>     <span class="token comment">//M级异常检测 </span><span class="token keyword">wire</span> lhlb_tag   <span class="token operator">=</span> <span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LH</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LHU</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LB</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LBU</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> load_tag   <span class="token operator">=</span> <span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LH</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LHU</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LB</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LBU</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LW</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> store_tag  <span class="token operator">=</span> <span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SW</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SH</span>  <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SB</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> timer_addr <span class="token operator">=</span> <span class="token punctuation">(</span>M_AO <span class="token operator">&gt;=</span> <span class="token number">32'h7f00</span> <span class="token operator">&amp;&amp;</span> M_AO <span class="token operator">&lt;=</span> <span class="token number">32'h7f0b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>M_AO <span class="token operator">&gt;=</span> <span class="token number">32'h7f10</span> <span class="token operator">&amp;&amp;</span> M_AO <span class="token operator">&lt;=</span> <span class="token number">32'h7f1b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">wire</span> DM_addr    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M_AO <span class="token operator">&gt;=</span> <span class="token number">32'h0</span> <span class="token operator">&amp;&amp;</span> M_AO <span class="token operator">&lt;=</span> <span class="token number">32'h2fff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Excption</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> M_ExcCode_fixed  <span class="token operator">=</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LW</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_AO<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2'b0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LH</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_LHU</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_AO<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1'b0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span>lhlb_tag <span class="token operator">&amp;&amp;</span> timer_addr<span class="token punctuation">)</span>                                       <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span>load_tag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer_addr <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>DM_addr<span class="token punctuation">)</span>                          <span class="token operator">?</span> <span class="token constant">`ADEL</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SW</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_AO<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2'b0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SH</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_AO<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1'b0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SH</span> <span class="token operator">||</span> LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SB</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> timer_addr<span class="token punctuation">)</span>         <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>LSOp_M <span class="token operator">==</span> <span class="token constant">`LS_SW</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> timer_addr <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_AO<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4'h8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                <span class="token punctuation">(</span>store_tag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer_addr <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>DM_addr<span class="token punctuation">)</span>                         <span class="token operator">?</span> <span class="token constant">`ADES</span> <span class="token punctuation">:</span>                                                                                                 M_ExcCode<span class="token punctuation">;</span>           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="测试方案">测试方案</h2><h3 id="handler设计">handler设计</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">.</span>ktext <span class="token number">0</span>x4180_main_handler<span class="token punctuation">:</span>mfc0 <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span>mfc0 <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span>ori <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x007c<span class="token keyword">and</span><span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$k0</span>beq <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> _returnnopmfc0<span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span>addu<span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token number">4</span>mtc0<span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span>j_return nop_return<span class="token punctuation">:</span>eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试数据样例">测试数据样例</h3><ul><li><p><strong>MIPS机器码样例</strong></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">textla<span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> pos_1addi<span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>ori<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">100</span>ori<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">200</span> #invalidpos_1<span class="token punctuation">:</span> addi<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">20</span> #invalidaddi<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">50</span>                   #F_exc_AdELnop                  #you can change it <span class="token number">0</span>xf000000fli<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">13</span>mfc0<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t1</span>     #D_exc_RIlui<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>x7ffflui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffadd<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>    #E_exc_Ov_add<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>lui<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffaddi<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffffff      #E_exc_Ov_addi<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>lui<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>x7ffflui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x8fffsub<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>    #E_exc_Ov_sub<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x12345678sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x8fffffffsw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">1</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x80000000sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">1</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">10</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7010li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">10</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x2800sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x12ab34cdsw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>xabcdsh<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">1</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f10li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">10</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f10li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">10</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>    #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>x8ff0li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">100</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>   #D_exc_AdEL<span class="token keyword">and</span><span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>testbench样例</strong></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token constant">`include</span> <span class="token string">"mips.v"</span><span class="token keyword">module</span> mips_txt_int<span class="token punctuation">;</span><span class="token keyword">reg</span> clk<span class="token punctuation">;</span><span class="token keyword">reg</span> reset<span class="token punctuation">;</span><span class="token keyword">reg</span> interrupt<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> macroscopic_pc<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_addr<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_rdata<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_addr<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_rdata<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_wdata<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_byteen<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_inst_addr<span class="token punctuation">;</span><span class="token keyword">wire</span>w_grf_we<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span> <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_addr<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_wdata<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_inst_addr<span class="token punctuation">;</span>mips <span class="token function">uut</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span>interrupt<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">macroscopic_pc</span><span class="token punctuation">(</span>macroscopic_pc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">i_inst_addr</span><span class="token punctuation">(</span>i_inst_addr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">i_inst_rdata</span><span class="token punctuation">(</span>i_inst_rdata<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">m_data_addr</span><span class="token punctuation">(</span>m_data_addr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">m_data_rdata</span><span class="token punctuation">(</span>m_data_rdata<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">m_data_wdata</span><span class="token punctuation">(</span>m_data_wdata<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">m_data_byteen</span><span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">m_inst_addr</span><span class="token punctuation">(</span>m_inst_addr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">w_grf_we</span><span class="token punctuation">(</span>w_grf_we<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">w_grf_addr</span><span class="token punctuation">(</span>w_grf_addr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">w_grf_wdata</span><span class="token punctuation">(</span>w_grf_wdata<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">w_inst_addr</span><span class="token punctuation">(</span>w_inst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>clk <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>reset <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">#20</span> reset <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">integer</span> i<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> fixed_addr<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> fixed_wdata<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4095</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> inst<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">5119</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// ----------- For Instructions -----------</span><span class="token keyword">assign</span> m_data_rdata <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">(</span>m_data_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5120</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">assign</span> i_inst_rdata <span class="token operator">=</span> inst<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i_inst_addr <span class="token operator">-</span> <span class="token number">32'h3000</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5120</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span><span class="token kernel-function property">$readmemh</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5120</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// ----------- For Data Memory -----------</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>fixed_wdata <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">(</span>m_data_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">4095</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fixed_addr <span class="token operator">=</span> m_data_addr <span class="token operator">&amp;</span> <span class="token number">32'hfffffffc</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">7</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">7</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">|</span>m_data_byteen <span class="token operator">&amp;&amp;</span> fixed_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>data<span class="token punctuation">[</span>fixed_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> fixed_wdata<span class="token punctuation">;</span><span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"%d@%h: *%h &lt;= %h"</span><span class="token punctuation">,</span> <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> m_inst_addr<span class="token punctuation">,</span> fixed_addr<span class="token punctuation">,</span> fixed_wdata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// ----------- For Registers -----------</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>w_grf_we <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>w_grf_addr <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"%d@%h: $%d &lt;= %h"</span><span class="token punctuation">,</span> <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> w_inst_addr<span class="token punctuation">,</span> w_grf_addr<span class="token punctuation">,</span> w_grf_wdata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">// ----------- For Interrupt -----------</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> fixed_macroscopic_pc<span class="token punctuation">;</span><span class="token keyword">assign</span> fixed_macroscopic_pc <span class="token operator">=</span> macroscopic_pc <span class="token operator">&amp;</span> <span class="token number">32'hfffffffc</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> interrupt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>reset <span class="token operator">&amp;&amp;</span> interrupt <span class="token operator">&amp;&amp;</span> <span class="token operator">|</span>m_data_byteen<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fixed_addr <span class="token operator">==</span> <span class="token number">32'h7F20</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> need_interrupt <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd100</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3010</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd99</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3014</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd98</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3018</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd97</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h301c</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd96</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3020</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd95</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3024</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd94</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3028</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd93</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h302c</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd92</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3030</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd91</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3034</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd90</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3038</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd89</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h303c</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd87</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3044</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd86</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3048</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd85</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h304c</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>need_interrupt <span class="token operator">==</span> <span class="token number">32'd84</span> <span class="token operator">&amp;&amp;</span> fixed_macroscopic_pc <span class="token operator">==</span> <span class="token number">32'h3050</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>interrupt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>need_interrupt <span class="token operator">&lt;=</span> need_interrupt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span>            <span class="token comment">//………………………………………………</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="思考题">思考题</h2><ul><li><p><strong>Q：我们计组课程一本参考书目标题中有“硬件/软件接口”接口字样，那么到底什么是“硬件/软件接口”？(Tips：什么是接口？和我们到现在为止所学的有什么联系？)</strong></p><p><strong>A：</strong>硬件/软件接口是指软件和硬件之间数据交互的接口。在我看来，这个应该指的是操作系统，操作系统将外部软件程序的机器码传入core，由core执行；而core执行后产生的数据又通过操作系统传给软件。</p></li><li><p><strong>Q：BE 部件对所有的外设都是必要的吗？</strong></p><p><strong>A：</strong>我认为没有必要，BE部件是为了实现DM按字节访存设置的，而其他的部件例如Timer仅仅支持按字访存，因此不需要BE部件。</p></li><li><p><strong>Q：请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU知晓的？</strong></p><p><strong>A：</strong>鼠标和键盘等外设并不是直接与CPU相连的，中间需要通过软件来连接，这个软件也就是我们熟知的驱动。驱动和硬件之间通过操作系统进行处理。</p></li><li><p><strong>Q:</strong>请开发一个主程序以及定时器的 exceptionhandler。整个系统完成如下功能：</p><p>（1）定时器在主程序中被初始化为模式 0；</p><p>（2）定时器倒计数至 0 产生中断；</p><p>（3）handler 设置使能 Enable 为 1 从而再次启动定时器的计数器。(2) 及(3) 被无限重复。</p><p>（4）主程序在初始化时将定时器初始化为模式0，设定初值寄存器的初值为某个值，如 100 或1000。（注意，主程序可能需要涉及对 CP0.SR的编程，推荐阅读过后文后再进行。）</p><p><strong>A:</strong></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">主程序<span class="token punctuation">:</span><span class="token punctuation">.</span>textori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>xfc01mtc0 <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x0sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">288</span>sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f04ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00addi <span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">1</span>loop<span class="token punctuation">:</span>add <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>j loop异常处理程序<span class="token punctuation">:</span><span class="token punctuation">.</span>ktext <span class="token number">0</span>x00004180ori <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x1ori <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9sw <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00sw <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P5&amp;P6_课上测试总结</title>
      <link href="/2021/12/06/co/co-p5-p6-ke-shang-ce-shi-zong-jie/"/>
      <url>/2021/12/06/co/co-p5-p6-ke-shang-ce-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="增添指令一般步骤">增添指令一般步骤</h2><h3 id="明确指令rtl">明确指令RTL</h3><ul><li>该步骤需要结合题目弄懂指令行为，包括<strong>明确指令类型</strong>（R型？I型？J型？即明确读和写的目标）、<strong>opcode和funct域数据</strong>、<strong>执行功能</strong>（计算？跳转？访存？）</li><li>最好可以先用MARS模拟下，以免对指令行为理解不到位。</li></ul><h3 id="明确非转发数据通路">明确非转发数据通路</h3><ul><li>在该步骤中，可以在<strong>单周期</strong>中思考新指令的行为，构思出该新指令的数据通路，然后修改控制器中的相关控制信号——包括<strong>使能信号</strong>（P5中的DM和GRF的写使能、P6中的GRF写使能和新加的byteen）、<strong>功能MUX的选择信号</strong>（GRF写入地址的选择、ALU的B端口数据的选择、GRF写入数据的选择等等）和<strong>模块功能的选择信号</strong>（ALU功能选择、NPC功能选择）。</li></ul><h3 id="考虑转发">考虑转发</h3><ul><li>考虑新指令作为<strong>提供者</strong>：<ul><li>首先考虑它是否及时将<strong>已经计算出来</strong>的<strong>将要被写入GRF</strong>的数据<strong>转发</strong>；<ul><li>例如，<strong>计算类指令</strong>在E级ALU会生成<strong>GRF写入数据</strong>，那么需要在后面的M级、W级的流水寄存器设置接口这个数据转发</li><li>例如，<strong>跳转并链接类指令</strong>在D级就可以生成<strong>GRF写入数据</strong><code>pc+8</code>,那么需要E级、M级和W级的流水寄存器设置接口将这个数据转发</li></ul></li><li>然后考虑GRF的5位写入地址是否正确。<ul><li>一般在第2步已经调整完毕，但是像<code>lwer</code>、<code>lhso</code>等条件存储类指令只有在M级从DM中取出数据后才能明确写入地址，需要在<strong>M级</strong>将GRF写入地址再次修改</li></ul></li></ul></li><li>考虑新指令作为<strong>接受者</strong>：明确需要使用<code>GPR[rs]</code>、<code>GPR[rt]</code>的功能部件和相应接口（CMP的D1和D2？ALU的A和B？乘除模块的A和B？DM的WD？），课上可能需要设置新的接口。</li></ul><h3 id="考虑暂停">考虑暂停</h3><ul><li>明确新指令的<code>Tuse_rs</code>、<code>Tuse_rt</code>以及在各级流水的<code>Tnew</code>，直接在主控制器中修改即可（<strong>千万不要忘记</strong>）。</li></ul><h2 id="课上测试题型分析">课上测试题型分析</h2><p>注：笔者课下cpu设计采用的是<strong>集中式译码</strong>和<strong>暴力转发</strong>。</p><h3 id="计算类">计算类</h3><p><strong>P5中一般只需要增加ALU的功能，但一定要看清楚新指令的计算行为，最好在MARS里先模拟一下。</strong></p><ul><li>一般来说新指令的计算行为会稍微复杂一点，用<code>always @（*）</code>写会比较简单，用<code>assign</code>的话可以定义一个<code>function</code>。</li><li>一般情况下，<code>Tnew</code>和<code>Tuse</code>与<strong>calc_R型指令</strong>保持一致即可。</li><li>循环移位可以采用以下写法——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//以循环左移为例</span><span class="token function">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> out <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token keyword">else</span> out <span class="token operator">=</span> A <span class="token operator">&lt;&lt;</span> B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|</span> A <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">5'd31</span> <span class="token operator">-</span> B<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">5'd1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><strong>P6的计算会涉及到乘除模块，也相对比较简单。需要注意madd、maddu、msub、msubu等指令（roife博客<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>有讲到）。</strong><ul><li>以<code>madd</code>为例（将两个数有符号相乘，计算结果与之前的HI、LO寄存器中的值相加，而不是覆盖），如果是以下写法会出现问题<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//错误写法1</span><span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误写法2</span><span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>错误写法1</strong>出现问题的原因是：位拼接<code>{HI, LO}</code>默认被当做无符号数，<strong>无符号性</strong>传递到<code>$signed(A) * $signed(B)</code>，因此即使使用了<code>$signed()</code>还是会被当成无符号数进行乘法运算</li><li><strong>错误写法2</strong>出现问题的原因是：虽然使用了<code>$signed()</code>屏蔽了外界符号性的传入，但是也屏蔽了<strong>位宽</strong>信息的传入，所以<code>$signed($signed(A) * $signed(B))</code>的结果实际上是32位(因为<code>$signed(A)</code>和<code>$signed(B)</code>都是32位，又没有外界位宽信息的传入，因此结果被强制规定为32位)，即<strong>高32位的数据被截去</strong>，在参与后续运算时自然会出现问题。</li></ul></li><li>为了避免上述情况，我们需要在<strong>错误写法2</strong>的最外层<code>$signed()</code>中人为传入64位位宽信息，学长博客的写法如下——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//正确写法1</span><span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token number">64'd0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确写法2</span><span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token operator">{{</span><span class="token number">32</span><span class="token operator">{</span>A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token operator">{{</span><span class="token number">32</span><span class="token operator">{</span>B<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>我认为还可以对<strong>错误写法1</strong>进行修改——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//正确写法3</span><span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token kernel-function property">$sigend</span><span class="token punctuation">(</span><span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="条件跳转类">条件跳转类</h3><p>一般跳转类指令有以下几种要求——</p><ol type="1"><li><strong>条件跳转+无条件链接</strong></li><li><strong>条件跳转+条件链接</strong></li><li><strong>条件跳转+条件（无条件）链接+不跳转时清空延迟槽</strong></li></ol><ul><li><strong>条件跳转</strong>比较好做，一般只需增加<strong>CMP模块</strong>中的判断功能即可。</li><li>如果是<strong>无条件链接</strong>的话也比较简单，可以直接在D级将<code>RFWrite</code>（GRF写入使能）置<strong>1</strong>并让它流水，并更改一下<code>A3</code>(GRF写入地址，一般是要链接到31号寄存器)，最后在W级将GRF写入数据选择成<strong>PC+8</strong>即可。</li><li>如果是<strong>条件链接</strong>，则需要在D级根据CMP模块的输出结果判断<code>RFWrite</code>是否有效，写法如下——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//为了确定当前指令是新指令，我们设置一个check信号随新指令一起流水，check有效则表示当前指令是新指令</span><span class="token comment">//D_RFWrite是从D级主控制器输出的信号</span><span class="token keyword">wire</span> D_RFWrite_new <span class="token operator">=</span> check_D <span class="token operator">?</span> <span class="token punctuation">(</span>D_CMP_out <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> D_RFWrite<span class="token punctuation">;</span><span class="token comment">//这时我们流水到下一级的就是D_RFWrite_new，而不是D_RFWrite</span>E_Reg  u_E_Reg <span class="token punctuation">(</span><span class="token comment">//input</span>                <span class="token comment">//…………………………………………</span>                <span class="token punctuation">.</span>RFWrite_D               <span class="token punctuation">(</span> RFWrite_D_new      <span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">//output</span>                <span class="token comment">//…………………………………………</span>                <span class="token punctuation">.</span>RFWrite_E               <span class="token punctuation">(</span> RFWrite_E          <span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果题目要求<strong>不跳转时清空延迟槽</strong>，则需要根据当前<strong>CMP模块输出结果</strong>判断是否清空<strong>D级流水寄存器</strong>。<strong>需要注意的是</strong>，如果当前正在处于<code>stall</code>状态时，不能清空延迟槽（<code>stall</code>说明前面指令的<code>Tnew</code>大于新指令的<code>Tuse</code>，即需要传入CMP模块的两个值的<strong>最新值</strong>还没有计算出来，因此还无法转发到CMP中）。写法如下——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> D_Reg_clr <span class="token operator">=</span> check_D <span class="token operator">&amp;</span> <span class="token operator">~</span>D_CMP_out <span class="token operator">&amp;</span> <span class="token operator">~</span>stall<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>### 条件存储类<br><strong>条件存储，也就是从DM取出值之后，根据这个值是否满足某个condition，再判断要往哪个寄存器写。</strong>和前两种题型相比更复杂，但是总结下来也就只有以下<strong>三种类型</strong>——</li></ul><ol type="1"><li><strong>condition成立：</strong>将DM中的值写入<strong>A号</strong>寄存器<br><strong>condition不成立：</strong> 写入<strong>B号</strong>寄存器</li><li><strong>condition成立：</strong>将DM中的值写入<strong>A号</strong>寄存器<br><strong>condition不成立：</strong> 不写入</li><li><strong>写入目标完全取决于DM的读取值</strong>（如将DM读取值的低5位作为写入目标）</li></ol><p>对于第二种不写入的情况，我们可以将写入地址<strong>设置为0号寄存器</strong>。因此这三种类型本质上是一种。</p><p><strong>对于条件存储类指令，我们只有到M级才知道写入目标是什么</strong>，这对会我们的转发和暂停造成影响。我们需要对<strong><code>stall</code>信号的生成逻辑</strong>进行修改，引用学长的话说就是——<strong>“如果D 级的指令要读寄存器，而且后面的新指令</strong><strong><em>可能</em></strong> <strong>要写这个寄存器，那么就<code>stall</code>”</strong>。代码如下——<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//笔者采用的命名方法是——A1和A2表示该流水级指令的GRF读地址,A3表示指令的GRF写地址</span><span class="token comment">//例如，如果E级指令为addu，则E_A1为rs域数据，E_A2为rt域数据，E_A3为rd域数据</span><span class="token comment">//RFWrite表示GRF写入使能信号</span><span class="token comment">//check信号有效则表示该流水级指令为新指令</span><span class="token comment">////////////////////////////////////////////////////</span><span class="token comment">//第一种题型(eg：condition满足向rt号写，否则写31号)</span>    <span class="token keyword">assign</span>   stall_rs_E <span class="token operator">=</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_E <span class="token operator">?</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3 <span class="token operator">|</span> D_A1 <span class="token operator">==</span> <span class="token number">5'd31</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rs <span class="token operator">&lt;</span> Tnew_E<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span>   stall_rs_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_M <span class="token operator">?</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3 <span class="token operator">|</span> D_A1 <span class="token operator">==</span> <span class="token number">5'd31</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rs <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span>   stall_rt_E <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_E <span class="token operator">?</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> E_A3 <span class="token operator">|</span> D_A2 <span class="token operator">==</span> <span class="token number">5'd31</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> D_A2 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_E<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span>   stall_rt_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_M <span class="token operator">?</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> M_A3 <span class="token operator">|</span> D_A2 <span class="token operator">==</span> <span class="token number">5'd31</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二种题型 (eg：condition满足向31号写，否则不写) </span><span class="token comment">//按照第一种题型以写成  (check_M ? (D_A2 == 5'd31 | D_A2 == 5'd0): D_A2 == M_A3),因为前面有条件 D_A2 != 5'd0，所以可以简化</span>    <span class="token keyword">assign</span>   stall_rt_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_M <span class="token operator">?</span> D_A2 <span class="token operator">==</span> <span class="token number">5'd31</span> <span class="token punctuation">:</span> D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第三种题型 (eg：condition满足时写入位置为DM的读取值的低五位)   </span>    <span class="token keyword">assign</span>   stall_rt_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>check_M <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此外我们还需要在M级根据DM取出的值修改<code>A3</code>(GRF写入地址),代码如下——<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//第一种题型(eg：condition满足向rt号写，否则写31号)</span>    <span class="token keyword">wire</span> M_A3_new <span class="token operator">=</span> check_M <span class="token operator">?</span> <span class="token punctuation">(</span>condition <span class="token operator">?</span> <span class="token constant">`rt</span> <span class="token punctuation">:</span> <span class="token number">5'd31</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> M_A3<span class="token punctuation">;</span> <span class="token comment">//第二种题型 (eg：condition满足向31号写，否则不写) </span>    <span class="token keyword">wire</span> M_A3_new <span class="token operator">=</span> check_M <span class="token operator">?</span> <span class="token punctuation">(</span>condition <span class="token operator">?</span> <span class="token number">5'd31</span> <span class="token punctuation">:</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> M_A3<span class="token punctuation">;</span> <span class="token comment">//第三种题型 (eg：写入位置为DM的读取值的低五位)  </span>    <span class="token keyword">wire</span> M_A3_new <span class="token operator">=</span> check_M <span class="token operator">?</span> DM_out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> M_A3<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样一来，我们在M级就将可以将正确的GRF写入地址修改，然后再传入下一级流水寄存器(W_Reg)和冒险控制器(HCU)即可。<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">W_Reg  u_W_Reg <span class="token punctuation">(</span><span class="token comment">//input</span>              <span class="token comment">//…………………………………………</span>              <span class="token punctuation">.</span>M_A3               <span class="token punctuation">(</span> M_A3_new      <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token comment">//output</span>              <span class="token comment">//…………………………………………</span>              <span class="token punctuation">.</span>W_A3               <span class="token punctuation">(</span> W_A3          <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">)</span><span class="token punctuation">;</span>  HCU  u_HCU <span class="token punctuation">(</span><span class="token comment">//input</span>              <span class="token comment">//…………………………………………</span>              <span class="token punctuation">.</span>M_A3                 <span class="token punctuation">(</span> M_A3_new         <span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token comment">//output</span>              <span class="token punctuation">.</span>FwdCMPD1             <span class="token punctuation">(</span> FwdCMPD1   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">.</span>FwdCMPD2             <span class="token punctuation">(</span> FwdCMPD2   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">.</span>FwdALUA              <span class="token punctuation">(</span> FwdALUA    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">.</span>FwdALUB              <span class="token punctuation">(</span> FwdALUB    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">.</span>FwdDM                <span class="token punctuation">(</span> FwdDM            <span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token punctuation">.</span>stall                <span class="token punctuation">(</span> stall            <span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>如果你是到W级才修改写入地址（也就是说，<code>M_A3_new</code>只传入了W_Reg而没有传入HCU，HCU的输入端仍然是<code>M_A3</code>）,这样会有一定问题</strong>。通过下面的例子说明——<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">lhso    <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">1024</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span> sw      <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">4096</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>当<code>lhso</code>在M级的时候，M级写入地址还没有被及时更新。因此这时候<strong>冒险控制器</strong>中<code>lhso</code>的写地址（<code>$s1</code>）和sw的读地址（<code>$s1</code>）还是相等的，所以会向处于E级的sw指令转发一个数据（即教程中采用的暴力转发）。<strong>下一时钟上升沿来临时</strong>，<code>lhso</code>进入W级，如果这时候lhso的写入地址不再是<code>$s1</code>,而是根据<strong>condition</strong>修改成了<code>31</code>号寄存器，那么我们在上一周期向sw指令转发的值就是一个错误值。<p></p><p>为了避免这种情况，我们需要<strong>对转发信号做一些调整</strong>，策略是：<strong>既然我们在<code>lhso</code>进入W级之前不知道要往哪个寄存器写值，那么我们就不向前转发</strong>。转发信号的调整如下——<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> FwdCMPD1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_E<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_M<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                     <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdCMPD2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_E<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_M<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdALUA  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_M<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> FwdALUB  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>check_M<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdDM    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>M_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'd1</span> <span class="token punctuation">:</span>                                                                     <span class="token number">1'd0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样对于新指令，我们就不再是<strong>暴力转发</strong>，而是<strong>条件转发</strong>。我个人还是建议采用第2种方法，我认为这种方法的正确性比第一种更容易证明。另外，建议在课下可以提前设置好一个<strong>check信号</strong>并让它流水，这样在课上会节省很多时间。<p></p><p>实际上，我们也可以把所有指令的转发都更改为<strong>条件转发</strong>——即<strong>所有的指令只有得到要写入寄存器的结果后才会向前转发</strong>，这样只需要将<code>Tnew == 0</code>加入判断条件即可。<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//Tnew == 0 表示当前指令已经产生要写入寄存器的结果</span><span class="token comment">//因为W级指令的Tnew都为0，因此不需要再添加(Tnew_W == 0)</span><span class="token keyword">assign</span> FwdCMPD1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_E <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_M <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                     <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdCMPD2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_E <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_M <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdALUA  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_M <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> FwdALUB  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tnew_M <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                    <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdDM    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>M_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'd1</span> <span class="token punctuation">:</span>                                                                     <span class="token number">1'd0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>Q:条件转发会有问题吗？</strong></p><p><strong>A:不会。</strong>因为有<strong>暂停机制</strong>把关，保证了指令<strong>获得要写入寄存器的值</strong>之前，前面的正常执行的（<strong>即不被stall的</strong>）指令都不会用到相关寄存器的值，或恰好将要使用，即<strong>Tnew&lt;= Tuse</strong>，因此不会带来新的问题。</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>roife学长的博客链接：https://roife.github.io/2021/01/02/buaa-co-lab-p7/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P6_流水线cpu（Plus）</title>
      <link href="/2021/11/26/co/co-p6-liu-shui-xian-cpu-plus/"/>
      <url>/2021/11/26/co/co-p6-liu-shui-xian-cpu-plus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="流水线cpu设计方案">流水线CPU设计方案</h2><h3 id="设计概述">设计概述</h3><p>​本文所设计的CPU为Verilog实现的流水线MIPS架构CPU，该CPU支持43条MIPS汇编指令，为了实现该功能，笔者设计了IFU，GRF，NPC，CMP，EXT，ALU，D_Reg，E_Reg，M_Reg，W_Reg，MCU，HCU，MDU，BE，DE等关键模块。整个搭建过程通过自下而上的方式完成——先根据应实现的指令对功能部件进行设计与搭建，然后对各个功能部件进行连接，形成完整的数据通路。</p><h3 id="实现指令说明">实现指令说明</h3><p>我们将本CPU实现的指令分为以下几类：</p><ul><li><p><strong>calc_R</strong>: add,sub,addu, subu, and, or, nor, xor,slt, sltu</p></li><li><p><strong>calc_I</strong>: addi,addiu, andi, ori, xori, slti,sltiu</p></li><li><p><strong>shift</strong>: sll, sra, srl</p></li><li><p><strong>shiftv</strong>: sllv, srav, srlv</p></li><li><p><strong>load</strong>: lw, lh, lhu, lb, lbu</p></li><li><p><strong>store</strong>: sw, sh, sb</p></li><li><p><strong>B类</strong>：beq,bne,bgtz,blez,bgez,bltz</p></li><li><p><strong>J类</strong>：j, jal, jr, jalr</p></li><li><p><strong>特殊</strong>：lui</p></li><li><p><strong>md类</strong>：mult, multu, div, divu</p></li><li><p><strong>mf类</strong>：mfhi, mflo</p></li><li><p><strong>mt类</strong>：mthi, mtlo</p></li></ul><h2 id="工程模块定义">工程模块定义</h2><p>在P6实验中，我们将IM（<strong>16KB</strong>(32bit/word×<strong>4096word</strong>)）和DM（<strong>16KB</strong>(32bit/word×<strong>4096word</strong>)）外置，因此在P5的基础上，我们在cpu中删去了这两个部分，同时增加相应的信号与接口与外置的IM和DM进行信息交换。同时，为了评测GRF的读写行为，我们还需要将GRF的读写信息通过相应接口和信号传入外部（testbench）。相关接口如下（在顶层模块mips中定义）</p><table><colgroup><col style="width: 20%"><col style="width: 6%"><col style="width: 6%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>同步复位信号</td></tr><tr class="odd"><td>i_inst_rdata</td><td>I</td><td>32</td><td>i_inst_addr队形的32位指令</td></tr><tr class="even"><td>m_data_addr</td><td>I</td><td>32</td><td>m_data_addr 对应的 32 位数据</td></tr><tr class="odd"><td>i_inst_addr</td><td>O</td><td>32</td><td>需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr class="even"><td>m_data_addr</td><td>O</td><td>32</td><td>数据存储器待写入地址</td></tr><tr class="odd"><td>m_data_wdata</td><td>O</td><td>32</td><td>数据存储器待写入数据</td></tr><tr class="even"><td>m_data_byteen</td><td>O</td><td>4</td><td>字节使能信号（相当于之前的MenWrite信号）</td></tr><tr class="odd"><td>m_inst_addr</td><td>O</td><td>32</td><td>M级PC</td></tr><tr class="even"><td>w_grf_we</td><td>O</td><td>1</td><td>grf 写使能信号</td></tr><tr class="odd"><td>w_grf_addr</td><td>O</td><td>5</td><td>grf 中待写入寄存器编号</td></tr><tr class="even"><td>w_grf_wdata</td><td>O</td><td>32</td><td>grf 中待写入数据</td></tr><tr class="odd"><td>w_inst_addr</td><td>O</td><td>32</td><td>W 级 PC</td></tr></tbody></table><h3 id="功能模块定义">功能模块定义</h3><h4 id="ifu取指令单元">IFU（取指令单元）</h4><p>该模块相当于程序计数器，在时钟上升沿时将npc写入pc，并具有同步复位的功能。同时，为了配合jal，jalr的链接操作，我们同时输出pc+8的值，在后面的流水寄存器中传递。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th style="text-align: center;">信号名</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">时钟信号</td></tr><tr class="even"><td style="text-align: center;">reset</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">异步复位信号</td></tr><tr class="odd"><td style="text-align: center;">en</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">使能信号</td></tr><tr class="even"><td style="text-align: center;">npc</td><td style="text-align: center;">I</td><td style="text-align: center;">32</td><td style="text-align: left;">下一条要被执行的指令的地址</td></tr><tr class="odd"><td style="text-align: center;">pc</td><td style="text-align: center;">O</td><td style="text-align: center;">32</td><td style="text-align: left;">输出当前正在执行的指令的地址</td></tr><tr class="even"><td style="text-align: center;">pc8</td><td style="text-align: center;">O</td><td style="text-align: center;">32</td><td style="text-align: left;">pc+8</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 13%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>当reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr class="even"><td>2</td><td>停止</td><td>当en信号失效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr class="odd"><td>3</td><td>写PC寄存器</td><td>当en信号失效且时钟上升沿来临时，将下一条指令的地址（nextPC）写入PC寄存器</td></tr></tbody></table></li></ul><h4 id="grf通用寄存器组">GRF（通用寄存器组）</h4><p>该模块内部包含32个具有写使能32位寄存器，分别对应MIPS架构中$0 ~$31通用寄存器（其中0号寄存器中的值恒为0，即不具备写使能，因此为了实现该机制，我们不再设置0号寄存器，每次对0进行特判）。GRF可以实现同步复位，同时可以根据输入的5位地址（0~31）向寄存器堆存取数据，实现定向访存寄存器。</p><p>为了实现内部转发，在GRF写入地址与读取地址相同时，我们将当前WD中输入的数据（但没有写入）实时反映到RD1或RD2端口上，用来解决数据冲突。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 80%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>pc</td><td>I</td><td>32</td><td>输出当前正在执行的</td></tr><tr class="odd"><td>reset</td><td>I</td><td>1</td><td>同步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr class="even"><td>A1</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD1</td></tr><tr class="odd"><td>A2</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD2</td></tr><tr class="even"><td>A3</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其作为写入目标</td></tr><tr class="odd"><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="even"><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入失效</td></tr><tr class="odd"><td>RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr class="even"><td>RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 11%"><col style="width: 83%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出A1，A2地址对应的寄存器中储存的数据，将其加载到RD1和RD2</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A3地址对应的寄存器</td></tr></tbody></table></li></ul><h4 id="npc下一指令计算单元">NPC（下一指令计算单元）</h4><p>​该模块根据当前pc（包括D级和F级）和其他控制信号（NPCOp，CMP输出信息），计算出下一指令所在的地址npc，传入IFU模块。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>F_pc</td><td>I</td><td>32</td><td>F级指令地址</td></tr><tr class="even"><td>D_pc</td><td>I</td><td>32</td><td>D级指令地址</td></tr><tr class="odd"><td>offset</td><td>I</td><td>32</td><td>地址偏移量，用于计算B类指令所要跳转的地址</td></tr><tr class="even"><td>imm26</td><td>I</td><td>26</td><td>当前指令数据的前26位（0~25），用于计算jal和j指令所要跳转的地址</td></tr><tr class="odd"><td>ra</td><td>I</td><td>32</td><td>储存在寄存器（$ra或是jalr指令中存储“PC+4”的寄存器）中的地址数据，用于实现jr和jalr指令</td></tr><tr class="even"><td>judge</td><td>I</td><td>1</td><td>B类指令判断结果<br>1：说明当前B类指令的判断结果为真<br>0：说明判断结果为假</td></tr><tr class="odd"><td>NPCOp</td><td>I</td><td>3</td><td>NPC功能选择<br>0x000：顺序执行<br>0x001：B类指令跳转<br>0x010:jal/j跳转<br>0x011: jr/jalr跳转</td></tr><tr class="even"><td>npc</td><td>O</td><td>32</td><td>输出下一指令地址</td></tr></tbody></table></li></ul><h4 id="ext扩展单元">EXT（扩展单元）</h4><p>​该模块对16位立即数进行扩展，可以实现符号扩展，0扩展和加载高位（lui）操作。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>in</td><td>I</td><td>16</td><td>16位立即数</td></tr><tr class="even"><td>EXTOp</td><td>I</td><td>2</td><td>EXT功能选择信号<br>0x000: 0扩展<br>0x001: 符号扩展<br>0x010:加载到高位（lui指令使用）</td></tr><tr class="odd"><td>out</td><td>O</td><td>32</td><td>扩展结果</td></tr></tbody></table></li></ul><h4 id="cmpb类指令比较单元">CMP(B类指令比较单元)</h4><p>​该单元根据输入的CMPOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行相应比较，最后输出结果。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>D1</td><td>I</td><td>32</td><td>输入CMP单元的第一个数据</td></tr><tr class="even"><td>D1</td><td>I</td><td>32</td><td>输入CMP单元的第二个数据</td></tr><tr class="odd"><td>CMPOp</td><td>I</td><td>3</td><td>CMPOp功能选择信号<br>0x000：beq判断<br>0x001：bne判断<br>0x010：blez判断<br>0x011:bgtz判断</td></tr><tr class="even"><td>out</td><td>O</td><td>1</td><td>判断结果输出<br>1: 判断结果为真<br>0：判断结果为假</td></tr></tbody></table></li></ul><h4 id="alu逻辑运算单元">ALU（逻辑运算单元）</h4><p>&nbsp;该模块可实现加，减，按位与，按位或等11种运算，并根据ALUOP信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ALUOp</td><td>I</td><td>4</td><td>ALU功能选择信号</td></tr><tr class="even"><td>src_A</td><td>I</td><td>32</td><td>参与ALU计算的第一个值</td></tr><tr class="odd"><td>src_B</td><td>I</td><td>32</td><td>参与ALU计算的第二个值S</td></tr><tr class="even"><td>shamt</td><td>I</td><td>5</td><td>移位数输入</td></tr><tr class="odd"><td>out</td><td>O</td><td>32</td><td>输出ALU计算结果</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 14%"><col style="width: 8%"><col style="width: 71%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>ALU_Op</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>加</td><td>0b0000</td><td>ALU_Result = Src_A + Src_B</td></tr><tr class="even"><td>2</td><td>减</td><td>0b0001</td><td>ALU_Result = Src_A - Src_B</td></tr><tr class="odd"><td>3</td><td>按位与</td><td>0b0010</td><td>ALU_Result = Src_A &amp; Src_B</td></tr><tr class="even"><td>4</td><td>按位或</td><td>0b0011</td><td>ALU_Result = Src_A | Src_B</td></tr><tr class="odd"><td>5</td><td>按位异或</td><td>0b0100</td><td>ALU_Result = Src_A ⊕ Src_B</td></tr><tr class="even"><td>6</td><td>按位或非</td><td>0b0101</td><td>ALU_Result = ~(Src_A | Src_B)</td></tr><tr class="odd"><td>7</td><td>逻辑左移</td><td>0b0110</td><td>ALU_Result = Src_B &lt;&lt; Shift</td></tr><tr class="even"><td>8</td><td>逻辑右移</td><td>0b0111</td><td>ALU_Result = Src_B &gt;&gt; Shift</td></tr><tr class="odd"><td>9</td><td>算术右移</td><td>0b1000</td><td>ALU_Result = Src_B &gt;&gt;&gt; Shift</td></tr><tr class="even"><td>10</td><td>带符号比较</td><td>0b1001</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（带符号比较）</td></tr><tr class="odd"><td>11</td><td>无符号比较</td><td>0b1010</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（无符号比较）</td></tr></tbody></table></li></ul><h4 id="mdu-乘除模块">MDU （乘除模块）</h4><p>​ 该模块对数据进行访存，容量为容量为<strong>12KB</strong>(32bit/word×<strong>3072word</strong>),不仅可以实现对字的访问和存储，还可以实现对半字和字节的操作。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr class="odd"><td>start</td><td>I</td><td>1</td><td>乘除运算启动信号</td></tr><tr class="even"><td>MDUOp</td><td>I</td><td>4</td><td>乘除模块功能选择<br>0x0000：空指令<br>0x0001：mult指令<br>0x0010：multu指令<br>0x0011：div指令<br>0x0100：divu指令<br>0x0101：mfhi指令<br>0x0110：mflo指令<br>0x0111：mthi指令<br>0x1000：mtlo指令</td></tr><tr class="odd"><td>A</td><td>I</td><td>32</td><td>运算数据</td></tr><tr class="even"><td>B</td><td>I</td><td>32</td><td>运算数据</td></tr><tr class="odd"><td>HI</td><td>O</td><td>32</td><td>HI寄存器输出值</td></tr><tr class="even"><td>LO</td><td>O</td><td>32</td><td>LO寄存器输出值</td></tr><tr class="odd"><td>out</td><td>O</td><td>32</td><td>MDU输出值（HI、LO中选择）</td></tr><tr class="even"><td>busy</td><td>O</td><td>1</td><td>乘除运算进行信号</td></tr></tbody></table></li></ul><h4 id="be字节使能模块">BE（字节使能模块）</h4><p>为了实现外置DM的<strong>按字节访存</strong>，我们需要对字中的每一个字节设置<strong>使能信号</strong>（4位）。在本模块中，我们根据当前执行的<strong>访存指令</strong>（由LSOp传递信息）和<strong>DM写入地</strong>址（addr），计算并输出相应的<strong>4位字节使能信号</strong>。同时，为配合<strong>”官方td“</strong>中<strong>”对应字节写入“</strong>的设置，我们还需要在该模块对写入值进行处理。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>A</td><td>I</td><td>2</td><td>DM写入地址的低2位</td></tr><tr class="even"><td>LSOp</td><td>I</td><td>2</td><td>访存功能信号</td></tr><tr class="odd"><td>WD_in</td><td>I</td><td>32</td><td>未经处理的DM写入数据</td></tr><tr class="even"><td>byteen</td><td>O</td><td>4</td><td>字节使能信号</td></tr><tr class="odd"><td>WD_out</td><td>O</td><td>32</td><td>处理后的DM写入数据</td></tr></tbody></table></li></ul><h4 id="de数据扩展模块">DE（数据扩展模块）</h4><p>外置DM根据<strong>”读取地址“</strong>的高30位将整个字读出，但是为了能够实现字节和半字的读取，我们在该模块中对读出的整个字进行处理，并对需要写入GRF的字节或半字进行扩展。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>A</td><td>I</td><td>2</td><td>DM写入地址的低2位</td></tr><tr class="even"><td>RD_in</td><td>I</td><td>32</td><td>未经处理的DM读出数据</td></tr><tr class="odd"><td>LSOp</td><td>I</td><td>2</td><td>访存功能信号</td></tr><tr class="even"><td>RD_out</td><td>O</td><td>32</td><td>处理后的DM读出数据</td></tr></tbody></table></li></ul><h3 id="流水寄存器模块定义">流水寄存器模块定义</h3><h4 id="d_regifid流水寄存器">D_Reg（IF/ID流水寄存器）</h4><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>en</td><td>1</td><td>D级寄存器使能信号</td><td>HCU中stall信号取反</td></tr><tr class="even"><td>I</td><td>clr</td><td>1</td><td>D级寄存器清空信号</td><td>默认为1‘b0</td></tr><tr class="odd"><td>I</td><td>F_instr</td><td>32</td><td>F级instr输入</td><td>IFU_instr</td></tr><tr class="even"><td>I</td><td>F_pc</td><td>32</td><td>F级pc输入</td><td>IFU_pc</td></tr><tr class="odd"><td>I</td><td>F_pc8</td><td>32</td><td>F级pc8输入</td><td>IFU_pc + 8</td></tr><tr class="even"><td>O</td><td>D_instr</td><td>32</td><td>D级instr输出</td><td></td></tr><tr class="odd"><td>O</td><td>D_pc</td><td>32</td><td>D级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>D_pc8</td><td>32</td><td>D级pc8输出</td><td></td></tr></tbody></table></li></ul><h4 id="e_regidex流水寄存器">E_Reg（ID/EX流水寄存器）</h4><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 6%"><col style="width: 15%"><col style="width: 6%"><col style="width: 35%"><col style="width: 36%"></colgroup><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>clr</td><td>1</td><td>E级寄存器清空信号</td><td>HCU中stall信号</td></tr><tr class="even"><td>I</td><td>D_instr_s</td><td>5</td><td>移位指令的位移数</td><td>D_instr的s域数据</td></tr><tr class="odd"><td>I</td><td>D_V1_f</td><td>32</td><td>D级V1输入（转发值）</td><td>通过MUX_CMP_D1选择的数据</td></tr><tr class="even"><td>I</td><td>D_V2_f</td><td>32</td><td>D级V2输入（转发值）</td><td>通过MUX_CMP_D1选择的数据</td></tr><tr class="odd"><td>I</td><td>D_A1</td><td>5</td><td>D级A1输入</td><td>D_instr的rs域数据</td></tr><tr class="even"><td>I</td><td>D_A2</td><td>5</td><td>D级A2输入</td><td>D_instr的rt域数据</td></tr><tr class="odd"><td>I</td><td>D_A3</td><td>5</td><td>D级A3输入</td><td>通过MUX_A3选择出的数据</td></tr><tr class="even"><td>I</td><td>D_E32</td><td>32</td><td>D级E32输入</td><td>通过EXT模块扩展出的数据</td></tr><tr class="odd"><td>I</td><td>D_pc</td><td>32</td><td>D级pc输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>D_pc8</td><td>32</td><td>D级pc8输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>Tnew_D</td><td>2</td><td>D级指令的Tnew输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>MemWrite_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelEMOut_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelALUS_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelALUB_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>LSOp_D</td><td>3</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>ALUOp_D</td><td>4</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>MUDOp_D</td><td>4</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>O</td><td>E_instr_s</td><td>5</td><td>移位指令的位移数</td><td></td></tr><tr class="even"><td>O</td><td>E_V1</td><td>32</td><td>E级V1输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_V2</td><td>32</td><td>E级V2输出</td><td></td></tr><tr class="even"><td>O</td><td>E_A1</td><td>5</td><td>E级A1输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_A2</td><td>5</td><td>E级A2输出</td><td></td></tr><tr class="even"><td>O</td><td>E_A3</td><td>5</td><td>E级A3输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_E32</td><td>32</td><td>E级E32输出</td><td></td></tr><tr class="even"><td>O</td><td>E_pc</td><td>32</td><td>E级pc输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_pc8</td><td>32</td><td>E级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>Tew_E</td><td>2</td><td>E级指令的Tnew输出</td><td></td></tr><tr class="odd"><td>O</td><td>RFWrite_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="even"><td>O</td><td>MemWrite_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>SelEMOut_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>SelWOut_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>SelALUS_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>SelALUB_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>LSOp_E</td><td>3</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>ALUOp_E</td><td>4</td><td>E级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>MUDOp_D</td><td>4</td><td>E级控制信号输出</td><td></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p><span class="math inline">\(Tnew\_E = (Tnew\_D &gt; 0) ? Tnew\_D - 1:0\)</span></p></li></ul><h4 id="m_regexmem流水寄存器">M_Reg（EX/MEM流水寄存器）</h4><ul><li><p>端口定义</p><table><colgroup><col style="width: 6%"><col style="width: 16%"><col style="width: 6%"><col style="width: 37%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>E_AO</td><td>32</td><td>E级AO输入</td><td>ALU_out数据</td></tr><tr class="even"><td>I</td><td>E_V2_f</td><td>32</td><td>E级V2输入（转发值）</td><td>MUX_ALU选择出来的数据</td></tr><tr class="odd"><td>I</td><td>E_A2</td><td>32</td><td>E级A2输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>E_A3</td><td>5</td><td>E级A3输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>E_pc</td><td>32</td><td>E级pc输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>E_pc8</td><td>32</td><td>E级pc8输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>Tnew_E</td><td>2</td><td>E级Tnew输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelEMOut_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>MemWrite_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>LSOp_E</td><td>3</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>O</td><td>M_AO</td><td>32</td><td>M级AO输出</td><td></td></tr><tr class="even"><td>O</td><td>M_V2</td><td>32</td><td>M级V2输出</td><td></td></tr><tr class="odd"><td>O</td><td>M_A2</td><td>32</td><td>M级A2输出</td><td></td></tr><tr class="even"><td>O</td><td>M_A3</td><td>5</td><td>M级A3输出</td><td></td></tr><tr class="odd"><td>O</td><td>M_pc</td><td>32</td><td>M级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>M_pc8</td><td>32</td><td>M级pc8输出</td><td></td></tr><tr class="odd"><td>O</td><td>Tnew_M</td><td>2</td><td>M级Tnew输出</td><td></td></tr><tr class="even"><td>O</td><td>SelEMOut_M</td><td>1</td><td>D级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>SelWOut_M</td><td>1</td><td>D级控制信号输出</td><td></td></tr><tr class="even"><td>O</td><td>RFWrite_M</td><td>1</td><td>D级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>MemWrite_M</td><td>1</td><td>D级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>LSOp_M</td><td>3</td><td>D级控制信号输出（使用）</td><td></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p><span class="math inline">\(Tnew\_M = (Tnew\_E &gt; 0) ? Tnew\_E - 1:0\)</span></p></li></ul><h4 id="w_regmemwb流水寄存器">W_Reg（MEM/WB流水寄存器）</h4><ul><li><p><strong>接口定义</strong></p><table><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>M_AO</td><td>32</td><td>M级AO输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>M_DR</td><td>32</td><td>M级DR输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>M_A3</td><td>5</td><td>M级A3输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>M_pc</td><td>32</td><td>M级pc输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>M_pc8</td><td>32</td><td>M级pc8输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_M</td><td>1</td><td>M级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_M</td><td>2</td><td>M级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>O</td><td>W_AO</td><td>32</td><td>W级AO输出</td><td></td></tr><tr class="odd"><td>O</td><td>W_DR</td><td>32</td><td>W级DR输出</td><td></td></tr><tr class="even"><td>O</td><td>W_A3</td><td>5</td><td>W级A3输出</td><td></td></tr><tr class="odd"><td>O</td><td>W_pc</td><td>32</td><td>W级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>W_pc8</td><td>32</td><td>W级pc8输出</td><td></td></tr><tr class="odd"><td>O</td><td>RFWrite_W</td><td>1</td><td>W级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>SelWOut_W</td><td>2</td><td>W级控制信号输出（使用）</td><td></td></tr></tbody></table></li></ul><h3 id="控制模块定义">控制模块定义</h3><h4 id="mcu主控制器模块">MCU（主控制器模块）</h4><p>在主控制模块中，我们对指令中Opcode域和Funct域中的数据进行解码，输出ALUOp,MemtoReg等19条控制指令，从而对数据通路进行调整，满足不同指令的需求。为实现该模块，我们又在内部设计了两个子模块——和逻辑（ANDLogic）和或逻辑（ORLogic）。前者的功能是识别，将输入的Opcode和Funct数据识别为对应的指令，后者的功能是生成，根据输入指令的不同产生不同的控制信号。</p><ul><li><p><strong>输入端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>opcode</td><td>I</td><td>6</td><td>输入D_instr_opcode域数据</td></tr><tr class="even"><td>funt</td><td>I</td><td>6</td><td>输入D_instr_funct域数据</td></tr></tbody></table></li><li><p><strong>输出端口（控制信号）定义</strong></p><table><colgroup><col style="width: 10%"><col style="width: 5%"><col style="width: 8%"><col style="width: 49%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>信号名</th><th>位宽</th><th>作用级</th><th>描述</th><th>相关指令</th></tr></thead><tbody><tr class="odd"><td>RFWrite</td><td>1</td><td>W</td><td>GRF写使能信号</td><td></td></tr><tr class="even"><td>MemWrite</td><td>1</td><td>M</td><td>DM写入使能信号</td><td>store型：sw, sb, sh</td></tr><tr class="odd"><td>SelA3</td><td>2</td><td>D</td><td>对MUX_A3的输出进行选择</td><td></td></tr><tr class="even"><td>SelEMOut</td><td>1</td><td>E、M</td><td>对MUX_E_out和MUX_M_out的输出进行选择</td><td>jr、jalr</td></tr><tr class="odd"><td>SelWOut</td><td>2</td><td>W</td><td>对MUX_W_out的输出进行选择</td><td></td></tr><tr class="even"><td>SelALUB</td><td>1</td><td>E</td><td>对MUX_ALU_B的输出进行选择</td><td></td></tr><tr class="odd"><td>SelALUS</td><td>1</td><td>E</td><td>对MUX_ALU_S的输出进行选择</td><td>shift型、shiftv型</td></tr><tr class="even"><td>NPCOp</td><td>3</td><td>D</td><td>NPC模块功能选择信号</td><td></td></tr><tr class="odd"><td>CMPOp</td><td>3</td><td>D</td><td>CMP模块功能选择信号</td><td>B型</td></tr><tr class="even"><td>EXTOp</td><td>2</td><td>D</td><td>EXT模块功能选择信号</td><td></td></tr><tr class="odd"><td>LSOp</td><td>3</td><td>M</td><td>DM模块功能选择信号</td><td>load型、store型</td></tr><tr class="even"><td>ALUOp</td><td>4</td><td>E</td><td>ALU模块功能选择信号</td><td>calc_R型、calc_I型</td></tr><tr class="odd"><td>MDUOp</td><td>4</td><td>E</td><td>MDU模块功能选择信号</td><td>md型、mf型、mt型</td></tr></tbody></table></li><li><p>注：该模块中的“Sel”型信号均作用于功能MUX</p></li></ul><h4 id="hcu冒险控制器模块">HCU（冒险控制器模块）</h4><p>在冒险控制模块中，我们通过对传入的<strong>“A”</strong>（A1，A2，A3）和<strong>“T”</strong>（Tnew，Tuse）进行分析，判断当前需要进行转发（<strong>forward</strong>）还是暂停（<strong>stall</strong>），并通过组合逻辑生成相应控制信号。</p><ul><li><p><strong>输入端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>D_A1</td><td>I</td><td>5</td><td>D级A1输入</td></tr><tr class="even"><td>D_A2</td><td>I</td><td>5</td><td>D级A2输入</td></tr><tr class="odd"><td>E_A1</td><td>I</td><td>5</td><td>E级A1输入</td></tr><tr class="even"><td>E_A2</td><td>I</td><td>5</td><td>E级A2输入</td></tr><tr class="odd"><td>M_A2</td><td>I</td><td>5</td><td>M级A2输入</td></tr><tr class="even"><td>E_A3</td><td>I</td><td>5</td><td>E级A3输入</td></tr><tr class="odd"><td>M_A3</td><td>I</td><td>5</td><td>M级A3输入</td></tr><tr class="even"><td>W_A3</td><td>I</td><td>5</td><td>W级A3输入</td></tr><tr class="odd"><td>Tuse_rs</td><td>I</td><td>2</td><td>D级MCU中输出的Tuse_rs信号</td></tr><tr class="even"><td>Tuse_rt</td><td>I</td><td>2</td><td>D级MCU中输出的Tuse_rt信号</td></tr><tr class="odd"><td>Tnew_E</td><td>I</td><td>2</td><td>E级Tnew_E信号输入</td></tr><tr class="even"><td>Tnew_M</td><td>I</td><td>2</td><td>M级Tnew_M信号输入</td></tr><tr class="odd"><td>Tnew_W</td><td>I</td><td>2</td><td>W级Tnew_W信号输入</td></tr></tbody></table></li><li><p><strong>输出端口（控制信号）定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>位宽</th><th>作用级</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>FwdCMPD1</td><td>2</td><td>D</td><td>对HMUX_CMP_D1的输出进行选择</td></tr><tr class="even"><td>FwdCMPD2</td><td>2</td><td>D</td><td>对HMUX_CMP_D2的输出进行选择</td></tr><tr class="odd"><td>FwdALUA</td><td>2</td><td>E</td><td>对HMUX_ALU_A的输出进行选择</td></tr><tr class="even"><td>FwdALUB</td><td>2</td><td>E</td><td>对HMUX_ALU_B的输出进行选择</td></tr><tr class="odd"><td>FwdDM</td><td>1</td><td>M</td><td>对HMUX_DM的输出进行选择</td></tr><tr class="even"><td>stall</td><td>1</td><td>F、D、M</td><td>暂停信号</td></tr></tbody></table></li><li><p>注：该模块中的“Fwd”型信号均作用于转发MUX</p></li><li><p>注：该模块中的stall信号同时作用与IFU，D_Reg，E_Reg</p></li></ul><h3 id="选择器模块">选择器模块</h3><h4 id="功能mux">功能MUX</h4><table><colgroup><col style="width: 9%"><col style="width: 8%"><col style="width: 63%"><col style="width: 10%"><col style="width: 8%"></colgroup><thead><tr class="header"><th>MUX名</th><th>选择数量</th><th>描述</th><th>输出信号名</th><th>控制信号</th></tr></thead><tbody><tr class="odd"><td>MUX_A3</td><td>3</td><td>D级中A3输入信号进行选择<br>0：D_instr_rt<br>1：D_instr_rd<br>2：0x1f</td><td>D_A3</td><td>SelA3</td></tr><tr class="even"><td>MUX_ALU_B</td><td>2</td><td>对E级ALU模块src_B接口的信号进行选择<br>0：E_V2_f<br>1：E_E32</td><td>ALU_B</td><td>SelALUB</td></tr><tr class="odd"><td>MUX_ALU_S</td><td>2</td><td>对E级ALU模块src_S接口的信号进行选择<br>0：E_instr_s<br>1：E_V1_f</td><td>ALU_S</td><td>SelALUS</td></tr><tr class="even"><td>MUX_E_out</td><td>2</td><td>对E级储存的计算结果进行选择<br>0：E_32<br>1：E_pc8</td><td>E_out</td><td>SelEMOut</td></tr><tr class="odd"><td>MUX_M_out</td><td>2</td><td>对M级储存的计算结果进行选择<br>0：M_AO<br>1：M_pc8</td><td>M_out</td><td>SelEMOut</td></tr><tr class="even"><td>MUX_W_out</td><td>3</td><td>对W级储存的计算结果进行选择<br>0：W_AO<br>1：W_DR<br>2：W_pc8</td><td>W_out</td><td>SelWOut</td></tr></tbody></table><h4 id="转发mux">转发MUX</h4><table><colgroup><col style="width: 11%"><col style="width: 8%"><col style="width: 61%"><col style="width: 10%"><col style="width: 8%"></colgroup><thead><tr class="header"><th>MUX名</th><th>选择数量</th><th>描述</th><th>输出信号名</th><th>控制信号</th></tr></thead><tbody><tr class="odd"><td>HMUX_CMP_D1</td><td>3</td><td>将数据转发到CMP_D1接口<br>0：GRF_RD1<br>1：M_out<br>2：E_out</td><td>D_V1_f</td><td>FwdCMPD1</td></tr><tr class="even"><td>HMUX_CMP_D2</td><td>3</td><td>将数据转发到CMP_D2接口<br>0：GRF_RD2<br>1：M_out<br>2：E_out</td><td>D_V2_f</td><td>FwdCMPD2</td></tr><tr class="odd"><td>HMUX_ALU_A</td><td>3</td><td>将数据转发到ALU_A接口<br>0：E_V1<br>1：W_out<br>2：M_out</td><td>E_V1_f</td><td>FwdALUA</td></tr><tr class="even"><td>HMUX_ALU_B</td><td>3</td><td>将数据转发到ALU_B接口<br>0：E_V2<br>1：W_out<br>2：M_out</td><td>E_V2_f</td><td>FwdALUB</td></tr><tr class="odd"><td>HMUX_DM</td><td>2</td><td>将数据转发到DM_WD接口<br>0：M_V2<br>1：W_out</td><td>M_V1_f</td><td>FwdDM</td></tr></tbody></table><h2 id="重要机制实现方法">重要机制实现方法</h2><h3 id="分支转移实现">分支转移实现</h3><h4 id="b类指令">B类指令</h4><p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将B类指令的判断进行前置，单独使用CMP模块进行判断。当B类指令进入D级后（此时F级的指令为编译优化调度的指令），CMP模块的判断结果进入NPC，如过CMP结果为真（CMP_out=1）而且NPCOp信号为0x001（说明当前指令为B类指令），NPC输出转移的地址npc并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><h4 id="j和jal">j和jal</h4><p>当j或jal进入D级后（此时F级的指令为编译优化调度的指令），D_instr中imm26域的数据进入NPC进行处理，如果当前NPCOp信号为0x010（说明当前指令为jal或j指令），NPC输出转移的地址npc，并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><p>jal指令在实现跳转的同时，还需要将下一条指令的地址存入31号寄存器中，因此我们需要在IFU中计算出改地址，并随着jal指令进行流水，最终在W级写入GRF的31号寄存器。由于存在延迟槽，pc+4地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为pc+8。</p><h4 id="jr和jalr">jr和jalr</h4><p>当jr进入D级后（此时F级的指令为编译优化调度的指令），D_V1_f（经过转发后的D_V1值）进入NPC，如果当前NPCOp信号为0x011（说明当前指令为jr指令），NPC输出转移的地址npc，并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><p>jalr指令在实现跳转的同时，还需要将下一条指令的地址存入31号寄存器中，因此我们需要在IFU中计算出改地址，并随着jal指令进行流水，最终在W级写入GRF的31号寄存器。由于存在延迟槽，pc+4地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为pc+8。</p><h3 id="乘除槽实现">乘除槽实现</h3><p>为了支持 <strong>mult、multu、div、divu、mfhi、mflo、mthi</strong><strong>及</strong> <strong>mtlo</strong>这些乘除法相关指令，需要设计独立的乘 / 除功能部件。该部件位于在流水线的EX 阶段，如图 1 所示。</p><ul><li><p>若当前指令为<strong>mfhi</strong>和<strong>mflo</strong>，即读取<strong>HI</strong>或<strong>LO</strong>中的数据，我们直接根据MDUOp的值将相应数据从out接口输出，进入下一级</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token punctuation">(</span>MDUOp <span class="token operator">==</span> <span class="token constant">`MDU_MFHI</span><span class="token punctuation">)</span> <span class="token operator">?</span> HI <span class="token punctuation">:</span>              <span class="token punctuation">(</span>MDUOp <span class="token operator">==</span> <span class="token constant">`MDU_MFLO</span><span class="token punctuation">)</span> <span class="token operator">?</span> LO <span class="token punctuation">:</span>                                    <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>若当前指令为<strong>mthi</strong>和<strong>mtlo</strong>，即向<strong>HI</strong>或<strong>LO</strong>寄存器中写入数据，可以直接在一个周期内完成，我们直接根据MDUOp的值进行写值操作即可。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">case</span><span class="token punctuation">(</span>MDUOp<span class="token punctuation">)</span><span class="token comment">//…………………………………………………</span>    <span class="token constant">`MDU_MTHI</span><span class="token punctuation">:</span>   HI <span class="token operator">&lt;=</span> A<span class="token punctuation">;</span>      <span class="token constant">`MDU_MTLO</span><span class="token punctuation">:</span>   LO <span class="token operator">&lt;=</span> A<span class="token punctuation">;</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>若当前指令为<strong>mult、multu、div、divu</strong>，即乘除运算指令，即使我们可以通过Verilog中内置的乘除运算实现，但是我们需要<strong>模拟实际电路的延迟</strong>，因此编程时不能直接将结果写入到<strong>HI</strong>和<strong>LO</strong>寄存器，而是先存入临时寄存器<code>HI_temp</code>和<code>LO_temp</code>。在写入的同时，还需将延迟的周期数记录下来，写入<code>max</code>寄存器。以上操作当乘除指令进入E级时的第一个周期就执行，此时start信号为1。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"> <span class="token function">case</span><span class="token punctuation">(</span>MDUOp<span class="token punctuation">)</span><span class="token constant">`MDU_MULT</span><span class="token punctuation">:</span> <span class="token keyword">begin</span> <span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>max <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token constant">`MDU_MULTU</span><span class="token punctuation">:</span> <span class="token keyword">begin</span> <span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>max <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token constant">`MDU_DIV</span><span class="token punctuation">:</span> <span class="token keyword">begin</span> <span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">}</span><span class="token punctuation">;</span>max <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token constant">`MDU_DIVU</span><span class="token punctuation">:</span> <span class="token keyword">begin</span> <span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span><span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">}</span><span class="token punctuation">;</span>max <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当模拟延迟结束之后，才能将值写入<strong>HI</strong>和<strong>LO</strong>寄存器。因此我们设置一个计数器<code>cnt</code>，当busy信号有效时进行计数，当达到<code>max</code>时停止计数并清空，同时将<code>HI_temp</code>和<code>LO_temp</code>中的值写入<code>HI</code></p><p>和<code>LO</code>。完整代码如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//HI、LO、HI_temp、LO_temp</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>            HI <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>            LO <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>            HI_temp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>            LO_temp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>busy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token comment">//the first circle </span>            <span class="token function">case</span><span class="token punctuation">(</span>MDUOp<span class="token punctuation">)</span><span class="token comment">//………………………………</span>            <span class="token keyword">endcase</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span><span class="token comment">//busy is 1, meaning the instruction is mult or div</span>            <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> max <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI_temp<span class="token punctuation">,</span> LO_temp<span class="token operator">}</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span> <span class="token operator">&lt;=</span> <span class="token operator">{</span>HI<span class="token punctuation">,</span> LO<span class="token operator">}</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token comment">// cnt and busy </span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> busy <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token keyword">begin</span>        busy <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">~</span>start <span class="token operator">&amp;&amp;</span> busy<span class="token punctuation">)</span><span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> max <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> busy <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>由于乘除运算独立于ALU，因此在乘除槽处于运算延迟时，其他<strong>无关指令</strong>均可继续进行。但是，如果后面的指令<strong>和乘除槽相关</strong>（md、mf、mt三类），则需要<strong>暂停</strong>（stall），延迟模拟结束后才可继续进行。</p></li></ul><h3 id="冒险处理">冒险处理</h3><p>冒险处理我们均通过“A_T”法实现——</p><h4 id="转发forward">转发（forward）</h4><p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p><p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p><ul><li><p><strong>供应者及其产生的数据</strong></p><table><thead><tr class="header"><th>流水级</th><th>产生数据</th><th>MUX名&amp;选择信号名</th><th>MUX输出名</th></tr></thead><tbody><tr class="odd"><td>E</td><td>E_E32，E_pc8</td><td>MUX_E_out &amp; SelEMOut</td><td>E_out</td></tr><tr class="even"><td>M</td><td>M_AO，M_pc8</td><td>MUX_M_out &amp; SelEMOut</td><td>M_out</td></tr><tr class="odd"><td>W</td><td>W_AO，W_RD，W_pc8</td><td>MUX_W_out &amp; SelWOut</td><td>W_out</td></tr></tbody></table><p>注：当M级指令为读hi和lo的指令时，M_AO中的结果是从上一周期在乘除槽中读取的hi或lo的值；如果是其他指令，M_AO是上一周期ALU的计算结果。</p></li><li><p><strong>需求者及其产生的数据</strong></p><table><colgroup><col style="width: 20%"><col style="width: 29%"><col style="width: 36%"><col style="width: 13%"></colgroup><thead><tr class="header"><th>接收端口</th><th>选择数据</th><th>HMUX名&amp;选择信号名</th><th>MUX输出名</th></tr></thead><tbody><tr class="odd"><td>CMP_D1/NPC_ra</td><td>D_V1，M_out，E_out</td><td>HMUX_CMP_D1 &amp; FwdCMPD1</td><td>D_V1_f</td></tr><tr class="even"><td>CMP_D2</td><td>D_v1，M_out，E_out</td><td>HMUX_CMP_D2 &amp; FwdCMPD2</td><td>D_V2_f</td></tr><tr class="odd"><td>ALU_A/MDU_A</td><td>E_V1， W_out，M_out</td><td>HMUX_ALU_A &amp; FwdALUA</td><td>E_V1_f</td></tr><tr class="even"><td>ALU_B/MDU_B</td><td>E_V2，W_out，M_out</td><td>HMUX_ALU_B &amp; FwdALUB</td><td>E_V1_f</td></tr><tr class="odd"><td>DM_WD</td><td>M_V2， W_out</td><td>HMUX_DM &amp; FwdDM</td><td>M_V2_f</td></tr></tbody></table></li></ul><p>从上表可以看出，W级中的数据没有转发到D级，原因是我们在GRF内实现了内部转发机制，将GRF输入端的数据（还未写入）及时反映到RD1或这RD2，判断条件为<code>A3 ==  A2</code>或者<code>A3 == A1</code>。</p><p>此时为了生成HMUX的选择信号，我们需要向HCU（冒险控制器）输入”A”数据，然后进行选择信号的计算，执行转发的条件为——</p><ul><li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为0</strong></li><li><strong>写使能信号有效</strong></li></ul><p>根据以上条件我们可以生成上面的5个HMUX选择信号，选择信号的输出值应遵循“就近原则”，及最先产生的数据最先被转发。代码如下——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> FwdCMPD1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                       <span class="token number">2'd0</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> FwdCMPD2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                      <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdALUA  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A1 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                      <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdALUB  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>E_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                      <span class="token number">2'd0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> FwdDM    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>M_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_A2 <span class="token operator">==</span> W_A3<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>RFWrite_W<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'd1</span> <span class="token punctuation">:</span>                                                                       <span class="token number">1'd0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="暂停stall">暂停（stall）</h4><p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为D级的指令进行暂停处理。</p><p>我们把Tuse和Tnew作为暂停的判断依据——</p><ul><li>Tuse：指令进入 <strong>D级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2）。</li><li>Tnew：位于 <strong>E级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的CPU 中，W 级的指令Tnew 恒为 0；对于同一条指令，Tnew@M = max(Tnew@E - 1,0)、</li></ul><p>在这一阶段，我们找到D级生成的Tuse_rs和Tuse_rt和在E,M,W级寄存器中流水的Tnew_D，Tnew_M，Tnew_W，如下表所示</p><ul><li><p><strong>Tuse表和计算表达式</strong></p><table><thead><tr class="header"><th>指令类型</th><th>Tuse_rs</th><th>Tuse_rt</th></tr></thead><tbody><tr class="odd"><td>calc_R</td><td>1</td><td>1</td></tr><tr class="even"><td>calc_I</td><td>1</td><td>X</td></tr><tr class="odd"><td>shift</td><td>X</td><td>1</td></tr><tr class="even"><td>shiftv</td><td>1</td><td>1</td></tr><tr class="odd"><td>load</td><td>1</td><td>X</td></tr><tr class="even"><td>store</td><td>1</td><td>2</td></tr><tr class="odd"><td>md</td><td>1</td><td>1</td></tr><tr class="even"><td>mt</td><td>1</td><td>X</td></tr><tr class="odd"><td>mf</td><td>X</td><td>X</td></tr><tr class="even"><td>branch</td><td>0</td><td>0</td></tr><tr class="odd"><td>j / jr</td><td>X</td><td>X</td></tr><tr class="even"><td>jal / jalr</td><td>0</td><td>X</td></tr><tr class="odd"><td>lui</td><td>X</td><td>X</td></tr></tbody></table><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//X表示不需要使用GRF中的值，此时Tuse可取得最大值</span><span class="token keyword">assign</span> Tuse_rs <span class="token operator">=</span> <span class="token punctuation">(</span>branch <span class="token operator">|</span> _jr <span class="token operator">|</span> _jalr<span class="token punctuation">)</span>                               <span class="token operator">?</span> <span class="token number">2'd0</span> <span class="token punctuation">:</span>                 <span class="token punctuation">(</span>md <span class="token operator">|</span> mt <span class="token operator">|</span> calc_R <span class="token operator">|</span> calc_I <span class="token operator">|</span> shiftv <span class="token operator">|</span> load <span class="token operator">|</span> store<span class="token punctuation">)</span>  <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                                                                         <span class="token number">2'd3</span> <span class="token punctuation">;</span>    <span class="token keyword">assign</span> Tuse_rt <span class="token operator">=</span> <span class="token punctuation">(</span>branch<span class="token punctuation">)</span>                                   <span class="token operator">?</span> <span class="token number">2'd0</span> <span class="token punctuation">:</span>                 <span class="token punctuation">(</span>md <span class="token operator">|</span> calc_R <span class="token operator">|</span> shift <span class="token operator">|</span> shiftv<span class="token punctuation">)</span>             <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                 <span class="token punctuation">(</span>store<span class="token punctuation">)</span>                                    <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                                                               <span class="token number">2'd3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Tnew表和计算表达式</strong></p><table><thead><tr class="header"><th>指令类型</th><th>Tnew_D</th><th>Tnew_E</th><th>Tnew_M</th><th>Tnew_W</th></tr></thead><tbody><tr class="odd"><td>calc_R</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>calc_I</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>shift</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>shiftv</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>load</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr class="even"><td>store</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="odd"><td>md</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="even"><td>mt</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="odd"><td>mf</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>branch</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="odd"><td>jal / jalr</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>j / jr</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="odd"><td>lui</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//X表示不需要向GRF写值，此时Tnew可取得0(最小值)</span><span class="token comment">//在控制器中生成的是D级Tnew，在流水过程中递减</span><span class="token keyword">assign</span> Tnew    <span class="token operator">=</span> <span class="token punctuation">(</span>load<span class="token punctuation">)</span>                                     <span class="token operator">?</span> <span class="token number">2'd3</span> <span class="token punctuation">:</span>                 <span class="token punctuation">(</span>mf <span class="token operator">|</span> calc_R <span class="token operator">|</span> calc_I <span class="token operator">|</span> shift <span class="token operator">|</span> shiftv<span class="token punctuation">)</span>    <span class="token operator">?</span> <span class="token number">2'd2</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>_lui<span class="token punctuation">)</span>                                     <span class="token operator">?</span> <span class="token number">2'd1</span> <span class="token punctuation">:</span>                 <span class="token punctuation">(</span>_jal <span class="token operator">|</span> _jalr<span class="token punctuation">)</span>                             <span class="token operator">?</span> <span class="token number">2'd0</span> <span class="token punctuation">:</span>                                                               <span class="token number">2'd0</span><span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>然后我们Tnew和Tuse传入HCU（冒险控制器中），然后进行stall信号的计算。如果满足以下条件则stall有效——</p><ul><li><p><strong>Tnew &gt; Tuse</strong></p></li><li><p><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为0</strong></p></li><li><p><strong>写使能信号有效</strong></p></li><li><p><strong>当E级延迟槽在进行运算（<code>start | busy</code>）时，D级为md、mt、mf指令</strong></p></li></ul><p>代码如下——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"> <span class="token keyword">assign</span>   stall_rs_E <span class="token operator">=</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rs <span class="token operator">&lt;</span> Tnew_E<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">assign</span>   stall_rs_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rs <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span>   stall_rt_E <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_E<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span>   stall_rt_M <span class="token operator">=</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>D_A2 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RFWrite_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Tuse_rt <span class="token operator">&lt;</span> Tnew_M<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span>   stall_rs   <span class="token operator">=</span> stall_rs_E <span class="token operator">|</span> stall_rs_M<span class="token punctuation">;</span><span class="token keyword">assign</span>   stall_rt   <span class="token operator">=</span> stall_rt_E <span class="token operator">|</span> stall_rt_M<span class="token punctuation">;</span> <span class="token keyword">assign</span>   stall_md   <span class="token operator">=</span> <span class="token punctuation">(</span>MDUOp_D <span class="token operator">!=</span> <span class="token constant">`MDU_NONE</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>E_start <span class="token operator">|</span> E_busy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span>   stall      <span class="token operator">=</span> stall_rs <span class="token operator">|</span> stall_rt <span class="token operator">|</span> stall_md<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>stall为1时执行以下操作——</p><ul><li><strong>冻结PC寄存器（IFU_en = ~stall = 0）</strong></li><li><strong>冻结D级寄存器（D_en = ~stall = 0）</strong></li><li><strong>清空E级寄存器（E_clr = stall = 1）</strong></li></ul><h2 id="测试方案">测试方案</h2><h3 id="典型测试样例">典型测试样例</h3><h4 id="计算访存指令测试">计算、访存指令测试</h4><p>我们先通过对除了分支、跳转之外的计算访存指令进行测试。该部分测试由python代码自动生成，生成思路是，连续枚举4条连续指令，将calc_R(包含shift_v),calc_I, LS, shift, md, mt,mf七种类型的指令进行排列组合（每一个类型随机取出一条指令），共有2401种排列。为了增加冲突概率，我们将被读写的寄存器范围调整到有限的5个，当测试样例足够多时，基本可以覆盖所有的冲突情况。</p><ul><li><p>生成代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list_R <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"addu"</span><span class="token punctuation">,</span> <span class="token string">"subu"</span><span class="token punctuation">,</span> <span class="token string">"and"</span><span class="token punctuation">,</span> <span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"nor"</span><span class="token punctuation">,</span> <span class="token string">"xor"</span><span class="token punctuation">,</span> <span class="token string">"sltu"</span><span class="token punctuation">,</span> <span class="token string">"slt"</span><span class="token punctuation">,</span> <span class="token string">"sllv"</span><span class="token punctuation">,</span> <span class="token string">"srlv"</span><span class="token punctuation">,</span> <span class="token string">"srav"</span><span class="token punctuation">]</span>list_I <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"andi"</span><span class="token punctuation">,</span> <span class="token string">"addiu"</span><span class="token punctuation">,</span> <span class="token string">"ori"</span><span class="token punctuation">,</span> <span class="token string">"xori"</span><span class="token punctuation">,</span> <span class="token string">"lui"</span><span class="token punctuation">,</span> <span class="token string">"slti"</span><span class="token punctuation">,</span> <span class="token string">"sltiu"</span><span class="token punctuation">]</span>list_LS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lw"</span><span class="token punctuation">,</span> <span class="token string">"sw"</span><span class="token punctuation">,</span> <span class="token string">"lh"</span><span class="token punctuation">,</span> <span class="token string">"lhu"</span><span class="token punctuation">,</span> <span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"lb"</span><span class="token punctuation">,</span> <span class="token string">"lbu"</span><span class="token punctuation">,</span> <span class="token string">"sb"</span><span class="token punctuation">]</span>list_shift <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"sll"</span><span class="token punctuation">,</span> <span class="token string">"srl"</span><span class="token punctuation">,</span> <span class="token string">"sra"</span><span class="token punctuation">]</span>list_B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"bne"</span><span class="token punctuation">,</span> <span class="token string">"beq"</span><span class="token punctuation">,</span><span class="token string">"bgtz"</span><span class="token punctuation">,</span> <span class="token string">"blez"</span><span class="token punctuation">,</span> <span class="token string">"bltz"</span><span class="token punctuation">,</span> <span class="token string">"bgez"</span><span class="token punctuation">]</span>list_MD <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"mult"</span><span class="token punctuation">,</span> <span class="token string">"multu"</span><span class="token punctuation">,</span> <span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token string">"divu"</span><span class="token punctuation">]</span>list_MT <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"mthi"</span><span class="token punctuation">,</span> <span class="token string">"mtlo"</span><span class="token punctuation">]</span>list_MF <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"mfhi"</span><span class="token punctuation">,</span> <span class="token string">"mflo"</span><span class="token punctuation">]</span>length <span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">def</span> <span class="token function">R_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">I_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">LS_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">shift_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">MD_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">MT_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span><span class="token keyword">def</span> <span class="token function">MF_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#………………………………</span>    instr <span class="token operator">=</span> <span class="token punctuation">[</span>R_test<span class="token punctuation">,</span> I_test<span class="token punctuation">,</span> LS_test<span class="token punctuation">,</span> shift_test<span class="token punctuation">,</span> MD_test<span class="token punctuation">,</span> MT_test<span class="token punctuation">,</span> MF_test<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"mips_code_{}.asm"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>    <span class="token comment">#寄存器随机赋值</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span>         s <span class="token operator">=</span> <span class="token string">"li ${} {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li $8, {}\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">#排列生成指令</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                instr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>                instr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>                instr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>                instr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>                f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试样例</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">li <span class="token kernel-function property">$0</span> <span class="token operator">-</span><span class="token number">1590414783</span>li <span class="token kernel-function property">$1</span> <span class="token operator">-</span><span class="token number">1387657999</span>li <span class="token kernel-function property">$2</span> <span class="token number">97336612</span>li <span class="token kernel-function property">$3</span> <span class="token operator">-</span><span class="token number">1971889419</span>li <span class="token kernel-function property">$4</span> <span class="token number">1148790734</span>li <span class="token kernel-function property">$5</span> <span class="token operator">-</span><span class="token number">289210629</span>li <span class="token kernel-function property">$6</span> <span class="token number">1026640559</span>li <span class="token kernel-function property">$7</span> <span class="token number">1852052372</span>li <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token number">7860</span>sltu <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>srav <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">or</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token keyword">xor</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">nor</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>slt <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span>ori <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">31050</span><span class="token keyword">or</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>subu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>sltu <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span>lbu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token function">878</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>slt <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token keyword">or</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>srav <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>sll <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">7</span>srlv <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">nor</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token keyword">or</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>div <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>sltu <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>sllv <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>srlv <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>mtlo <span class="token kernel-function property">$0</span>addu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>slt <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>addu <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>mfhi <span class="token kernel-function property">$1</span><span class="token keyword">nor</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>srav <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>sltiu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">7080</span><span class="token keyword">and</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token keyword">or</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token keyword">xor</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span>andi <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token number">25900</span>xori <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">18289</span>srlv <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>slt <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>ori <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">32729</span>lh <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token function">1250</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sllv <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>addu <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>xori <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">11378</span>srl <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">5</span>addu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>srav <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>slti <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">24158</span>multu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>sltu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="转移指令b类和j类功能测试">转移指令（B类和J类）功能测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">main<span class="token punctuation">:</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1000</span>li<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">1000</span>lui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000#s3 is  <span class="token operator">-</span><span class="token number">2147483648</span>lui<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000ori<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x0001#s4 is  <span class="token operator">-</span><span class="token number">2147483647</span>lui<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>xffff#s5 is  <span class="token number">2147483647</span>lui<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>xfffe#s6 is <span class="token number">2147483646</span>beq_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> beq_1_testnopbeq_2<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> beq_2_testnop……beq_10<span class="token punctuation">:</span>  beq<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> beq_10_testnopbeq_end<span class="token punctuation">:</span>bne_1<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> bne_1_testnop……bne_10<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> bne_10_testnopbne_end<span class="token punctuation">:</span>blez_1<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> blez_1_testnop……blez_10<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> blez_10_testnopblez_end<span class="token punctuation">:</span>bgtz_1<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span>bgtz_1_testnop……bgtz_10<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span>bgtz_10_testnopbgtz_end<span class="token punctuation">:</span>jal_1<span class="token punctuation">:</span>jaljal_1_testnop……jal_5<span class="token punctuation">:</span>jaljal_5_testnopjal_end<span class="token punctuation">:</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscallbeq_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_2nop……beq_10_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_endnopbne_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_2nop……bne_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_endnopblez_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_2nop……blez_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_endnopbgtz_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_2nop……bgtz_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_endnopjal_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>nop……jal_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>nopjalr_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>nop……jalr_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="转移指令冲突测试">转移指令冲突测试</h4><h5 id="连续枚举4条指令最后一条时b类指令在前三条设置和b类相冲突的指令计算访存">连续枚举4条指令，最后一条时b类指令，在前三条设置和B类相冲突的指令（计算、访存）</h5><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">6355</span>li<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">12</span>li<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">55</span>li<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>li<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>xffffli<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffffffli<span class="token kernel-function property">$s7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">12333</span><span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>lw<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>add     <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>###beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_1nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_1<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>sll    <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span>###lw<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>bne<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_2nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_2<span class="token punctuation">:</span>ori     <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">12345</span>###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>lw<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>bne<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_3nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_3<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>sw<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw      <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>###bne<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_4nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_4<span class="token punctuation">:</span>sw<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw      <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>bne<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_5nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_5<span class="token punctuation">:</span>sw<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw      <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>###<span class="token keyword">and</span><span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>bne<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> next_6nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_6<span class="token punctuation">:</span>jaljal_1###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>jal_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> next_7nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_7<span class="token punctuation">:</span>jaljal_2###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>jal_2<span class="token punctuation">:</span><span class="token keyword">and</span><span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>beq<span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> next_8nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_8<span class="token punctuation">:</span>la<span class="token kernel-function property">$30</span><span class="token punctuation">,</span> jalr_1jalr<span class="token kernel-function property">$30</span>###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>jalr_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> next_9nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_9<span class="token punctuation">:</span>la<span class="token kernel-function property">$30</span><span class="token punctuation">,</span> jalr_2jalr<span class="token kernel-function property">$30</span>###<span class="token keyword">or</span><span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span>jalr_2<span class="token punctuation">:</span><span class="token keyword">and</span><span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span>beq<span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> next_10nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_10<span class="token punctuation">:</span>mthi<span class="token kernel-function property">$s5</span>mfhi    <span class="token kernel-function property">$s1</span>###beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> next_11nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_11<span class="token punctuation">:</span>mthi<span class="token kernel-function property">$s5</span>mfhi    <span class="token kernel-function property">$s1</span>###add<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s7</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> next_12nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_12<span class="token punctuation">:</span>mthi<span class="token kernel-function property">$s5</span>mfhi    <span class="token kernel-function property">$s1</span>###add<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s7</span>lui<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">4455</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> next_13nopslt<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s5</span>next_13<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="连续四条指令中存在2个跳转设置模板由代码自动生成">连续四条指令中存在2个跳转（设置模板，由代码自动生成）</h5><ul><li><p>生成代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">B_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> lable<span class="token punctuation">)</span><span class="token punctuation">:</span>    k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_B<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> lable<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>lable<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">b_begin</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_one_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"b_test_{}_two:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_two_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal_test_{}:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}_then\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"end_{}:\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">b_end</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MT_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"j b_test_{}_two\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_two_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MT_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addu $1, $ra, $0\n"</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\njal_test_{}_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MT_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addiu $ra,$ra, 8\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"end_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MT_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jr $ra\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试样例</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">b_test_1_one<span class="token punctuation">:</span>bgtz <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> b_test_1_one_thenaddu <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>b_test_1_two<span class="token punctuation">:</span>beq <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> b_test_1_two_thenori <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">23724</span>jal_test_1<span class="token punctuation">:</span>jal jal_test_1_thenori <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">28895</span>end_1<span class="token punctuation">:</span>sllv <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>andi <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">6835</span>sb <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">2366</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token number">2</span>……………………b_test_1_one_then<span class="token punctuation">:</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>lui <span class="token kernel-function property">$4</span><span class="token punctuation">,</span><span class="token number">39476</span>lw <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">100</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>srl <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>multu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>mtlo <span class="token kernel-function property">$7</span>j b_test_1_two<span class="token keyword">xor</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>b_test_1_two_then<span class="token punctuation">:</span>srav <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>andi <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">31313</span>sb <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">3770</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>srl <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token number">1</span>divu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>mtlo <span class="token kernel-function property">$3</span>jal jal_test_1addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>jal_test_1_then<span class="token punctuation">:</span>slt <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>sltiu <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1372</span>lh <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token function">1034</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">1</span>multu <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>mtlo <span class="token kernel-function property">$6</span>addiu <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span><span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token number">8</span>bgez <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> end_1<span class="token keyword">and</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>xori <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">23606</span>lb <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">869</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sra <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>multu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span>mtlo <span class="token kernel-function property">$5</span>jr <span class="token kernel-function property">$ra</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="自动测试工具">自动测试工具</h3><ul><li><p><strong>测试代码生成工具（python）</strong></p><p>我们先将指令分类，每类指令使用<strong>列表</strong>储存。每一类指令分别用一个单独封装的函数来随机生成，在后面可以跟据需要排列组合</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> randomlist_R <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"addu"</span><span class="token punctuation">,</span> <span class="token string">"subu"</span><span class="token punctuation">,</span> <span class="token string">"and"</span><span class="token punctuation">,</span> <span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"nor"</span><span class="token punctuation">,</span> <span class="token string">"xor"</span><span class="token punctuation">,</span> <span class="token string">"sltu"</span><span class="token punctuation">,</span> <span class="token string">"slt"</span><span class="token punctuation">,</span> <span class="token string">"sllv"</span><span class="token punctuation">,</span> <span class="token string">"srlv"</span><span class="token punctuation">,</span> <span class="token string">"srav"</span><span class="token punctuation">]</span>list_I <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"andi"</span><span class="token punctuation">,</span> <span class="token string">"addiu"</span><span class="token punctuation">,</span> <span class="token string">"ori"</span><span class="token punctuation">,</span> <span class="token string">"xori"</span><span class="token punctuation">,</span> <span class="token string">"lui"</span><span class="token punctuation">,</span> <span class="token string">"slti"</span><span class="token punctuation">,</span> <span class="token string">"sltiu"</span><span class="token punctuation">]</span>list_LS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lw"</span><span class="token punctuation">,</span> <span class="token string">"sw"</span><span class="token punctuation">,</span> <span class="token string">"lh"</span><span class="token punctuation">,</span> <span class="token string">"lhu"</span><span class="token punctuation">,</span> <span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"lb"</span><span class="token punctuation">,</span> <span class="token string">"lbu"</span><span class="token punctuation">,</span> <span class="token string">"sb"</span><span class="token punctuation">]</span>list_shift <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"sll"</span><span class="token punctuation">,</span> <span class="token string">"srl"</span><span class="token punctuation">,</span> <span class="token string">"sra"</span><span class="token punctuation">]</span>list_B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"bne"</span><span class="token punctuation">,</span> <span class="token string">"beq"</span><span class="token punctuation">,</span><span class="token string">"bgtz"</span><span class="token punctuation">,</span> <span class="token string">"blez"</span><span class="token punctuation">,</span> <span class="token string">"bltz"</span><span class="token punctuation">,</span> <span class="token string">"bgez"</span><span class="token punctuation">]</span>list_MD <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"mult"</span><span class="token punctuation">,</span> <span class="token string">"multu"</span><span class="token punctuation">,</span> <span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token string">"divu"</span><span class="token punctuation">]</span>list_MTMF <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"mfhi"</span><span class="token punctuation">,</span> <span class="token string">"mflo"</span><span class="token punctuation">,</span> <span class="token string">"mthi"</span><span class="token punctuation">,</span> <span class="token string">"mtlo"</span><span class="token punctuation">]</span><span class="token comment">#length是生成的指令所用到的寄存器个数</span>length <span class="token operator">=</span> <span class="token number">8</span> <span class="token comment">#为了增大冒险概率，我们将寄存器的范围缩小到0~7</span><span class="token keyword">def</span> <span class="token function">R_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_R<span class="token punctuation">)</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>        rd <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>        s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, ${}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">I_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_I<span class="token punctuation">)</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        imm <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">32768</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">)</span>        abs_imm <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"lui"</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> <span class="token string">"{} ${},{}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rt<span class="token punctuation">,</span> abs_imm<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rt<span class="token punctuation">,</span> rs<span class="token punctuation">,</span> imm<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">LS_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_LS<span class="token punctuation">)</span>        ins <span class="token operator">=</span> list_LS<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        num <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ins<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>        <span class="token keyword">elif</span><span class="token punctuation">(</span>ins<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>                rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, {}($0)\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>ins<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> num<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">shift_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_shift<span class="token punctuation">)</span>        shamt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rd <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_shift<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> shamt<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">MD_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_MD<span class="token punctuation">)</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        <span class="token keyword">if</span><span class="token punctuation">(</span>list_MD<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"mult"</span> <span class="token keyword">or</span> list_MD<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"mul"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_MD<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_MD<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">MTMF_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_MTMF<span class="token punctuation">)</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_MTMF<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">B_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> lable<span class="token punctuation">)</span><span class="token punctuation">:</span>    k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_B<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> lable<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> length        s <span class="token operator">=</span> <span class="token string">"{} ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>lable<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">b_begin</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_one_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"b_test_{}_two:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_two_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal_test_{}:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}_then\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"end_{}:\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">b_end</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"j b_test_{}_two\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_two_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addu $1, $ra, $0\n"</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\njal_test_{}_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addiu $ra,$ra, 8\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"end_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jr $ra\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"mips_code.asm"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> <span class="token string">"li ${} {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li $8, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        MD_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        MTMF_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token comment"># index = random.randint(0,10000000) % length</span>    <span class="token comment"># file.write("li  ${} 0\n".format(index))</span>    <span class="token comment"># for i in range(10):</span>    <span class="token comment">#     b_begin(file, i+1)</span>    <span class="token comment"># file.write("j   final\n")</span>    <span class="token comment"># for i in range(10):</span>    <span class="token comment">#     b_end(file, 1+i)</span>    <span class="token comment"># file.write("final:\nnop\n")</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>自动测试工具（python）</strong></p><p>在使用前，我们需要将下方<strong>r_road</strong>和<strong>xilinx_path</strong>中输入工程文件夹路径和ISE路径。在终端运行这个代码（test.py）后，首先需要输入测试次数，对于每一次测试，我们运行一次代码自动生成工具（generate_2.py）,生成MIPS代码（mips_code.asm）,然后会启动mars和ISE分别获得标准输出（mips_out.txt）和测试输出（verilog_out.txt），最后进行文本比较，在终端会显示<strong>比较结果</strong>、<strong>期望执行周期</strong>和<strong>实际执行周期</strong>。如果出现错误，会自动生成错误日志文件，显示错误行数和相应mips机器码、标准输出、测试输出。如果想要对自己写的MIPS代码进行测试，只需要将第132行注释掉，运行次数填写为1即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> shutil<span class="token keyword">import</span> rerun_time <span class="token operator">=</span> <span class="token string">"30us"</span>xilinx_path <span class="token operator">=</span> <span class="token string">"E:\\Xilinx\\14.7\\ISE_DS\\ISE"</span>p_path <span class="token operator">=</span> <span class="token string">"D:\\Code\\Verilog\\homework_code\\P6_cpu"</span>mips_code_name <span class="token operator">=</span> <span class="token string">"mips_code.asm"</span>mips_out_name <span class="token operator">=</span> <span class="token string">"mips_out.txt"</span>verilog_out_name <span class="token operator">=</span> <span class="token string">"verilog_out.txt"</span>error <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>passed <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_mars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"编译并运行MIPS文件……"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar Mars_perfect.jar db mc CompactDataAtZero a dump .text HexText code.txt nc "</span> <span class="token operator">+</span> mips_code_name<span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar Mars_perfect.jar db mc CompactDataAtZero nc "</span> <span class="token operator">+</span> mips_code_name <span class="token operator">+</span> <span class="token string">" &gt; "</span> <span class="token operator">+</span> mips_out_name<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">load_hex_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    list_temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> hex_code<span class="token punctuation">:</span>        list_temp <span class="token operator">=</span> hex_code<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_path <span class="token operator">+</span> <span class="token string">"\\code.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file_to_IM<span class="token punctuation">:</span>        file_to_IM<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>    hex_code<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    file_to_IM<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_ise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"编译并运行Verilog文件……"</span><span class="token punctuation">)</span>        file_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token punctuation">,</span>k <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>p_path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">file</span><span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">".v"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                file_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_path <span class="token operator">+</span> <span class="token string">"\\mips.prj"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> prj<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>file_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            prj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Verilog work \""</span> <span class="token operator">+</span> p_path <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> file_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\"\n"</span><span class="token punctuation">)</span>               <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_path <span class="token operator">+</span> <span class="token string">"\mips.tcl"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tcl<span class="token punctuation">:</span>        tcl<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"run "</span> <span class="token operator">+</span> run_time <span class="token operator">+</span><span class="token string">";\nexit"</span><span class="token punctuation">)</span>        prj<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    tcl<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"XILINX"</span><span class="token punctuation">]</span> <span class="token operator">=</span> xilinx_path    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>xilinx_path <span class="token operator">+</span> <span class="token string">"\\bin\\nt64\\fuse -nodebug -prj "</span> <span class="token operator">+</span> p_path <span class="token operator">+</span> <span class="token string">"\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mips.exe -nolog -tclbatch "</span> <span class="token operator">+</span> p_path <span class="token operator">+</span> <span class="token string">"\\mips.tcl&gt; "</span> <span class="token operator">+</span> verilog_out_name<span class="token punctuation">)</span>    <span class="token comment"># print("mips.exe -nolog -tclbatch " + p_path + "\\mips.tcl &gt; verilog_out.txt")</span><span class="token keyword">def</span> <span class="token function">copy_file</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target_road<span class="token punctuation">)</span><span class="token punctuation">:</span>    f_1 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    list_temp <span class="token operator">=</span> f_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_2 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>target_road<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>    f_2<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>    f_1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># def file_adj():</span><span class="token comment">#     list_temp = list()</span><span class="token comment">#     with open(verilog_out_name, "r") as f:</span><span class="token comment">#         list_temp = f.readlines()[5:]</span><span class="token comment">#         for i in range(len(list_temp) - 1):</span><span class="token comment">#             out_1 = re.findall(r"(.+?)@(.+?):", list_temp[i])[0]</span><span class="token comment">#             out_2 = re.findall(r"(.+?)@(.+?):", list_temp[i+1])[0]</span><span class="token comment">#             if (out_1[0] == out_2[0]) and (int(out_1[1], 16) &gt; int(out_2[1], 16)):</span><span class="token comment">#                     str_temp = list_temp[i+1]</span><span class="token comment">#                     list_temp[i+1] = list_temp[i]</span><span class="token comment">#                     list_temp[i] = str_temp;</span><span class="token comment">#     with open(verilog_out_name, "w") as f:</span><span class="token comment">#         f.writelines(list_temp)</span>        <span class="token keyword">def</span> <span class="token function">file_cmp</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> passed    time <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>mips_out_name<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_1<span class="token punctuation">:</span>        out_std <span class="token operator">=</span> out_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'\n'</span> <span class="token keyword">in</span> out_std<span class="token punctuation">)</span><span class="token punctuation">:</span>            out_std<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>verilog_out_name<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_2<span class="token punctuation">:</span>        out_test <span class="token operator">=</span> out_2<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        time <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>out_test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>out_test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        flag <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">".\\log.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> log<span class="token punctuation">:</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token number">1</span>            log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Too few output! Expected output-lines is {}, But your output-lines is {}\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token number">1</span>            log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Too more output! Expected output-lines is {}, But your output-lines is {}\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"(.+?)@"</span><span class="token punctuation">,</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"(.+?)@"</span><span class="token punctuation">,</span> out_test<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Error in line {}: \nExpected output is \"{}\", but your outout is \"{}\"\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    str_temp <span class="token operator">=</span> out_test<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                    out_test<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str_temp<span class="token punctuation">;</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>verilog_out_name<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>out_test<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试结果:  Failed!"</span><span class="token punctuation">)</span>        error<span class="token punctuation">.</span>append<span class="token punctuation">(</span>order<span class="token punctuation">)</span>        os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">".\\test_log_file\\log_{}\\"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>        copy_file<span class="token punctuation">(</span><span class="token string">"log.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}\\log.txt"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>        copy_file<span class="token punctuation">(</span>mips_code_name<span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}\\mips_code.asm"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>        copy_file<span class="token punctuation">(</span>mips_out_name<span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}\\mips_out.txt"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>        copy_file<span class="token punctuation">(</span>verilog_out_name<span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}\\verilog_out.txt"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试结果:  Accepted!"</span><span class="token punctuation">)</span>        passed <span class="token operator">=</span> passed <span class="token operator">+</span> <span class="token number">1</span>    s <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'java -jar Hazard-Calculator.jar code.txt --hz  --im-base 0x3000 --im-size 16384 --dm-base 0 --dm-size 12288 '</span></span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"   your circle: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>time <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>test_times <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入测试次数："</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试开始！\n"</span><span class="token punctuation">)</span><span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">".\\test_log_file"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span><span class="token string">".\\test_log_file"</span><span class="token punctuation">)</span> os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">".\\test_log_file\\"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"错误日志文件夹已创建！"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>test_times <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n测试进度:  {}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> test_times<span class="token punctuation">)</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"python generate.py"</span><span class="token punctuation">)</span>    run_mars<span class="token punctuation">(</span><span class="token punctuation">)</span>    load_hex_code<span class="token punctuation">(</span><span class="token punctuation">)</span>    run_ise<span class="token punctuation">(</span><span class="token punctuation">)</span>    file_cmp<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n通过率：{}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>passed<span class="token punctuation">,</span>test_times<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"错误样例:"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="思考题">思考题</h2><ul><li><p><strong>Q：为什么需要有单独的乘除法部件而不是整合进ALU？为何需要有独立的 HI、LO 寄存器？</strong></p><p><strong>A：</strong>如果乘除法部件在ALU中，那么在乘除运算延迟的过程中，其他指令因为无法使用ALU而无法继续执行。而单独的乘除法部件可以保证在运算延迟的过程中，其他<strong>无关指令</strong>仍然可以正常访问ALU并执行，提高执行速度。<em>hi</em>和<em>lo</em>是与乘法运算器相关的两个寄存器，的用来存放结果的地方。它们并不是通用寄存器,除了用在乘除法之外,也不能有做其他用途。由高内聚、低耦合的原则，我们必须将他们独立。</p></li><li><p><strong>Q：参照你对延迟槽的理解，试解释 “乘除槽”。</strong></p><p><strong>A：</strong>乘除槽是专门进行乘除运算的结构，与其他模块独立。乘除槽的设置使得乘除运算独立出来，在单独的模块中进行运算，在运算延迟中不会对其他<strong>无关指令</strong>的执行产生任何影响。</p></li><li><p><strong>Q：举例说明并分析何时按字节访问内存相对于按字访问内存性能上更有优势。（Hint：考虑 C 语言中字符串的情况）</strong></p><p><strong>A：</strong>当我们只需要对<strong>字节</strong>或<strong>半字</strong>访问时，<strong>按字节访问内存</strong>性能更由优势。如果此时还采用<strong>按字访问</strong>，则需要首先将整个字从内存中拿出来，然后再从字中寻找，效率会更低。</p></li><li><p><strong>Q：在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</strong></p><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p><p><strong>A：</strong>我是采用半随机生成半手动构造的方法。对于功能型指令，完全通过python脚本自动生成。并且为了提高数据冲突的概率，我们仅仅使用0~7号寄存器进行测试。对于跳转指令，我们先使用一定模板进行构建，然后为了增加数据冒险和控制冒险，我们又手动进行一定修改，使得测试样例尽可能更多的覆盖所有可能的情况</p></li><li><p><strong>Q：为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</strong></p><p><strong>A：</strong>我们根据不同指令之间的相似性将指令分成了几类——calc_R、calc_I、shift、shiftv、load、store、B类、J类、md类、mf类、mt类，并设置对应信号帮助译码，防止计算表达式过长，而且在处理数据冲突时我们只需要将表示该类的信号写入表达式即可。此外，我们将相似功能的控制信号用一个多位宽信号来表示，如针对DM的访存功能，我们设置一个3位LSOp信号；针对乘除槽中的md、mf、mt功能，我们设置一个MDUOp信号来控制，从而减少了流水寄存器的接口数目，从而降低复杂度。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P5_流水线cpu（Basic）</title>
      <link href="/2021/11/15/co/co-p5-liu-shui-xian-cpu-basic/"/>
      <url>/2021/11/15/co/co-p5-liu-shui-xian-cpu-basic/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="流水线cpu设计方案">流水线CPU设计方案</h2><h3 id="设计概述">设计概述</h3><p>​本文所设计的CPU为Verilog实现的流水线MIPS架构CPU，该CPU支持43条MIPS汇编指令，为了实现该功能，笔者设计了IFU，GRF，NPC，CMP，EXT，ALU，DM，D_Reg，E_Reg，M_Reg，W_Reg，MCU，HCU等关键模块。整个搭建过程通过自下而上的方式完成——先根据应实现的指令对功能部件进行设计与搭建，然后对各个功能部件进行连接，形成完整的数据通路。</p><h3 id="实现指令说明">实现指令说明</h3><p>我们将本CPU实现的指令分为以下几类：</p><ul><li><p><strong>calc_R</strong>: addu, subu, and, or, nor, xor, slt,sltu</p></li><li><p><strong>calc_I</strong>: addiu, andi, ori, xori, slti,sltiu</p></li><li><p><strong>shift</strong>: sll, sra, srl</p></li><li><p><strong>shiftv</strong>: sllv, srav, srlv</p></li><li><p><strong>load</strong>: lw, lh, lhu, lb, lbu</p></li><li><p><strong>store</strong>: sw, sh, sb</p></li><li><p><strong>B类</strong>：beq， bne</p></li><li><p><strong>J类</strong>：jal, j</p></li><li><p><strong>特殊</strong>：jr, lui</p></li></ul><h2 id="工程模块定义">工程模块定义</h2><h3 id="功能模块定义">功能模块定义</h3><h4 id="ifu取指令单元">IFU（取指令单元）</h4><p>​该模块内部包含PC（程序计数器）和IM（指令存储器）。IM的容量为<strong>16KB</strong>(32bit/word×<strong>4096word</strong>)，可以根据PC的值从IM取出对应的指令，并具有同步复位的功能。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th style="text-align: center;">信号名</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">时钟信号</td></tr><tr class="even"><td style="text-align: center;">reset</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">异步复位信号</td></tr><tr class="odd"><td style="text-align: center;">en</td><td style="text-align: center;">I</td><td style="text-align: center;">1</td><td style="text-align: left;">使能信号(stall信号取反)</td></tr><tr class="even"><td style="text-align: center;">npc</td><td style="text-align: center;">I</td><td style="text-align: center;">32</td><td style="text-align: left;">下一条要被执行的指令的地址</td></tr><tr class="odd"><td style="text-align: center;">pc</td><td style="text-align: center;">O</td><td style="text-align: center;">32</td><td style="text-align: left;">输出当前正在执行的指令的地址</td></tr><tr class="even"><td style="text-align: center;">instr</td><td style="text-align: center;">O</td><td style="text-align: center;">32</td><td style="text-align: left;">输出当前正在执行的指令</td></tr><tr class="odd"><td style="text-align: center;">pc8</td><td style="text-align: center;">O</td><td style="text-align: center;">32</td><td style="text-align: left;">pc+8</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 13%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>当reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr class="even"><td>2</td><td>停止</td><td>当en信号失效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr class="odd"><td>3</td><td>写PC寄存器</td><td>当en信号失效且时钟上升沿来临时，将下一条指令的地址（nextPC）写入PC寄存器</td></tr><tr class="even"><td>4</td><td>取指令</td><td>根据当前pc的值从IM（指令存储器）中读出对应的指令到instr端口</td></tr></tbody></table></li></ul><h4 id="grf通用寄存器组">GRF（通用寄存器组）</h4><p>​ 该模块内部包含32个具有写使能32位寄存器，分别对应MIPS架构中$0 ~$31通用寄存器（其中0号寄存器中的值恒为0，即不具备写使能，因此为了实现该机制，我们不再设置0号寄存器，每次对0进行特判）。GRF可以实现同步复位，同时可以根据输入的5位地址（0~31）向寄存器堆存取数据，实现定向访存寄存器。</p><p>​为了实现内部转发，我们将当前WD中输入的数据（但没有写入）实时反映到RD1和RD2端口上，用来解决数据冲突。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 80%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>pc</td><td>I</td><td>32</td><td>输出当前正在执行的</td></tr><tr class="odd"><td>reset</td><td>I</td><td>1</td><td>同步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr class="even"><td>A1</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD1</td></tr><tr class="odd"><td>A2</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD2</td></tr><tr class="even"><td>A3</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其作为写入目标</td></tr><tr class="odd"><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="even"><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入失效</td></tr><tr class="odd"><td>RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr class="even"><td>RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 11%"><col style="width: 83%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出A1，A2地址对应的寄存器中储存的数据，将其加载到RD1和RD2</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A3地址对应的寄存器</td></tr></tbody></table></li></ul><h4 id="npc下一指令计算单元">NPC（下一指令计算单元）</h4><p>​该模块根据当前指令地址和其他控制信号（NPCOp），计算出下一指令所在的地址。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>F_pc</td><td>I</td><td>32</td><td>F级指令地址</td></tr><tr class="even"><td>D_pc</td><td>I</td><td>32</td><td>D级指令地址</td></tr><tr class="odd"><td>offset</td><td>I</td><td>32</td><td>地址偏移量，用于计算B类指令所要跳转的地址</td></tr><tr class="even"><td>imm26</td><td>I</td><td>26</td><td>当前指令数据的前26位（0~25），用于计算jal和j指令所要跳转的地址</td></tr><tr class="odd"><td>ra</td><td>I</td><td>32</td><td>储存在寄存器（$ra或是jalr指令中存储“PC+4”的寄存器）中的地址数据，用于实现jr和jalr指令</td></tr><tr class="even"><td>judge</td><td>I</td><td>1</td><td>B类指令判断结果<br>1：说明当前B类指令的判断结果为真<br>0：说明判断结果为假</td></tr><tr class="odd"><td>NPCOp</td><td>I</td><td>3</td><td>NPC功能选择<br>0x000：顺序执行<br>0x001：B类指令分支地址<br>0x010:jal/j跳转地址<br>0x011: jr跳转地址</td></tr><tr class="even"><td>npc</td><td>O</td><td>32</td><td>输出下一指令地址</td></tr></tbody></table></li></ul><h4 id="ext扩展单元">EXT（扩展单元）</h4><p>​该模块对16位立即数进行扩展，可以实现符号扩展，0扩展和加载高位（lui）操作。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>in</td><td>I</td><td>16</td><td>16位立即数</td></tr><tr class="even"><td>EXTOp</td><td>I</td><td>2</td><td>EXT功能选择信号<br>0x000: 0扩展<br>0x001: 符号扩展<br>0x010:加载到高位（lui指令使用）</td></tr><tr class="odd"><td>out</td><td>O</td><td>32</td><td>扩展结果</td></tr></tbody></table></li></ul><h4 id="cmpb类指令比较单元">CMP(B类指令比较单元)</h4><p>​该单元根据输入的CMPOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行相应比较，最后输出结果。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>D1</td><td>I</td><td>32</td><td>输入CMP单元的第一个数据</td></tr><tr class="even"><td>D1</td><td>I</td><td>32</td><td>输入CMP单元的第二个数据</td></tr><tr class="odd"><td>CMPOp</td><td>I</td><td>3</td><td>CMPOp功能选择信号<br>0x000：beq判断<br>0x001：bne判断<br>0x010：blez判断<br>0x011:bgtz判断</td></tr><tr class="even"><td>out</td><td>O</td><td>1</td><td>判断结果输出<br>1: 判断结果为真<br>0：判断结果为假</td></tr></tbody></table></li></ul><h4 id="alu逻辑运算单元">ALU（逻辑运算单元）</h4><p>&nbsp;该模块可实现加，减，按位与，按位或等11种运算，并根据ALUOP信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ALUOp</td><td>I</td><td>4</td><td>ALU功能选择信号</td></tr><tr class="even"><td>src_A</td><td>I</td><td>32</td><td>参与ALU计算的第一个值</td></tr><tr class="odd"><td>src_B</td><td>I</td><td>32</td><td>参与ALU计算的第二个值S</td></tr><tr class="even"><td>shamt</td><td>I</td><td>5</td><td>移位数输入</td></tr><tr class="odd"><td>out</td><td>O</td><td>32</td><td>输出ALU计算结果</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 14%"><col style="width: 8%"><col style="width: 71%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>ALU_Op</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>加</td><td>0b0000</td><td>ALU_Result = Src_A + Src_B</td></tr><tr class="even"><td>2</td><td>减</td><td>0b0001</td><td>ALU_Result = Src_A - Src_B</td></tr><tr class="odd"><td>3</td><td>按位与</td><td>0b0010</td><td>ALU_Result = Src_A &amp; Src_B</td></tr><tr class="even"><td>4</td><td>按位或</td><td>0b0011</td><td>ALU_Result = Src_A | Src_B</td></tr><tr class="odd"><td>5</td><td>按位异或</td><td>0b0100</td><td>ALU_Result = Src_A ⊕ Src_B</td></tr><tr class="even"><td>6</td><td>按位或非</td><td>0b0101</td><td>ALU_Result = ~(Src_A | Src_B)</td></tr><tr class="odd"><td>7</td><td>逻辑左移</td><td>0b0110</td><td>ALU_Result = Src_B &lt;&lt; Shift</td></tr><tr class="even"><td>8</td><td>逻辑右移</td><td>0b0111</td><td>ALU_Result = Src_B &gt;&gt; Shift</td></tr><tr class="odd"><td>9</td><td>算术右移</td><td>0b1000</td><td>ALU_Result = Src_B &gt;&gt;&gt; Shift</td></tr><tr class="even"><td>10</td><td>带符号比较</td><td>0b1001</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（带符号比较）</td></tr><tr class="odd"><td>11</td><td>无符号比较</td><td>0b1010</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（无符号比较）</td></tr></tbody></table></li></ul><h4 id="dm-数据存储器">DM （数据存储器）</h4><p>​ 该模块对数据进行访存，容量为容量为<strong>12KB</strong>(32bit/word×<strong>3072word</strong>),不仅可以实现对字的访问和存储，还可以实现对半字和字节的操作。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 8%"><col style="width: 5%"><col style="width: 5%"><col style="width: 81%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>pc</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr class="even"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="odd"><td>reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr class="even"><td>A</td><td>I</td><td>5</td><td>地址输入信号，指向数据储存器中某个存储单元</td></tr><tr class="odd"><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="even"><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入失效</td></tr><tr class="odd"><td>LSOp</td><td>I</td><td>3</td><td>DM访存功能选择信号<br>0x000：lw<br>0x001：lh<br>0x010：lhu<br>0x011：lb<br>0x100：lbu<br>0x101：sw<br>0x110：sh<br>0x111：sb</td></tr><tr class="even"><td>RD</td><td>O</td><td>32</td><td>输出A指定的存储单元中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 5%"><col style="width: 11%"><col style="width: 83%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出A地址对应的存储单元中的数据，将其加载到RD</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td></tr></tbody></table></li></ul><h3 id="流水寄存器模块定义">流水寄存器模块定义</h3><h4 id="d_regifid流水寄存器">D_Reg（IF/ID流水寄存器）</h4><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>en</td><td>1</td><td>D级寄存器使能信号</td><td>HCU中stall信号取反</td></tr><tr class="even"><td>I</td><td>clr</td><td>1</td><td>D级寄存器清空信号</td><td>默认为1‘b0</td></tr><tr class="odd"><td>I</td><td>F_instr</td><td>32</td><td>F级instr输入</td><td>IFU_instr</td></tr><tr class="even"><td>I</td><td>F_pc</td><td>32</td><td>F级pc输入</td><td>IFU_pc</td></tr><tr class="odd"><td>I</td><td>F_pc8</td><td>32</td><td>F级pc8输入</td><td>IFU_pc + 8</td></tr><tr class="even"><td>O</td><td>D_instr</td><td>32</td><td>D级instr输出</td><td></td></tr><tr class="odd"><td>O</td><td>D_pc</td><td>32</td><td>D级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>D_pc8</td><td>32</td><td>D级pc8输出</td><td></td></tr></tbody></table></li></ul><h4 id="e_regidex流水寄存器">E_Reg（ID/EX流水寄存器）</h4><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 6%"><col style="width: 15%"><col style="width: 6%"><col style="width: 35%"><col style="width: 36%"></colgroup><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>clr</td><td>1</td><td>E级寄存器清空信号</td><td>HCU中stall信号</td></tr><tr class="even"><td>I</td><td>D_instr_s</td><td>5</td><td>移位指令的位移数</td><td>D_instr的s域数据</td></tr><tr class="odd"><td>I</td><td>D_V1</td><td>32</td><td>D级V1输入</td><td>通过MUX_CMP_D1选择的数据</td></tr><tr class="even"><td>I</td><td>D_V2</td><td>32</td><td>D级V2输入</td><td>通过MUX_CMP_D1选择的数据</td></tr><tr class="odd"><td>I</td><td>D_A1</td><td>5</td><td>D级A1输入</td><td>D_instr的rs域数据</td></tr><tr class="even"><td>I</td><td>D_A2</td><td>5</td><td>D级A2输入</td><td>D_instr的rt域数据</td></tr><tr class="odd"><td>I</td><td>D_A3</td><td>5</td><td>D级A3输入</td><td>通过MUX_A3选择出的数据</td></tr><tr class="even"><td>I</td><td>D_E32</td><td>32</td><td>D级E32输入</td><td>通过EXT模块扩展出的数据</td></tr><tr class="odd"><td>I</td><td>D_pc</td><td>32</td><td>D级pc输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>D_pc8</td><td>32</td><td>D级pc输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>Tnew_D</td><td>2</td><td>D级指令的Tnew输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>MemWrite_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelEMOut_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelALUS_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelALUB_D</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>LSOp_D</td><td>3</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>ALUOp_D</td><td>4</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>O</td><td>E_instr_s</td><td>5</td><td>移位指令的位移数</td><td></td></tr><tr class="odd"><td>O</td><td>E_V1</td><td>32</td><td>E级V1输出</td><td></td></tr><tr class="even"><td>O</td><td>E_V2</td><td>32</td><td>E级V2输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_A1</td><td>5</td><td>E级A1输出</td><td></td></tr><tr class="even"><td>O</td><td>E_A2</td><td>5</td><td>E级A2输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_A3</td><td>5</td><td>E级A3输出</td><td></td></tr><tr class="even"><td>O</td><td>E_E32</td><td>32</td><td>E级E32输出</td><td></td></tr><tr class="odd"><td>O</td><td>E_pc</td><td>32</td><td>E级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>E_pc8</td><td>32</td><td>E级pc输出</td><td></td></tr><tr class="odd"><td>O</td><td>Tew_E</td><td>2</td><td>E级指令的Tnew输出</td><td></td></tr><tr class="even"><td>O</td><td>RFWrite_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>MemWrite_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="even"><td>O</td><td>SelEMOut_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>SelWOut_E</td><td>1</td><td>E级控制信号输出</td><td></td></tr><tr class="even"><td>O</td><td>SelALUS_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>SelALUB_E</td><td>1</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>LSOp_E</td><td>3</td><td>E级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>ALUOp_E</td><td>4</td><td>E级控制信号输出</td><td></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p><span class="math inline">\(Tnew\_E = (Tnew\_D &gt; 0) ? Tnew\_D - 1:0\)</span></p></li></ul><h4 id="m_regexmem流水寄存器">M_Reg（EX/MEM流水寄存器）</h4><ul><li><p>端口定义</p><table><colgroup><col style="width: 6%"><col style="width: 16%"><col style="width: 6%"><col style="width: 37%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>E_AO</td><td>32</td><td>E级AO输入</td><td>ALU_out数据</td></tr><tr class="even"><td>I</td><td>E_V2</td><td>32</td><td>E级V2输入</td><td>MUX_ALU选择出来的数据</td></tr><tr class="odd"><td>I</td><td>E_A2</td><td>32</td><td>E级A2输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>E_A3</td><td>5</td><td>E级A3输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>E_pc</td><td>32</td><td>E级pc输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>E_pc8</td><td>32</td><td>E级pc8输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>Tnew_E</td><td>2</td><td>E级Tnew输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>SelEMOut_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>MemWrite_E</td><td>1</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>LSOp_E</td><td>3</td><td>D级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>O</td><td>M_AO</td><td>32</td><td>M级AO输出</td><td></td></tr><tr class="even"><td>O</td><td>M_V2</td><td>32</td><td>M级V2输出</td><td></td></tr><tr class="odd"><td>O</td><td>M_A2</td><td>32</td><td>M级A2输出</td><td></td></tr><tr class="even"><td>O</td><td>M_A3</td><td>5</td><td>M级A3输出</td><td></td></tr><tr class="odd"><td>O</td><td>M_pc</td><td>32</td><td>M级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>M_pc8</td><td>32</td><td>M级pc8输出</td><td></td></tr><tr class="odd"><td>O</td><td>Tnew_M</td><td>2</td><td>M级Tnew输出</td><td></td></tr><tr class="even"><td>O</td><td>SelEMOut_M</td><td>1</td><td>D级控制信号输出（使用）</td><td></td></tr><tr class="odd"><td>O</td><td>SelWOut_M</td><td>1</td><td>D级控制信号输出</td><td></td></tr><tr class="even"><td>O</td><td>RFWrite_M</td><td>1</td><td>D级控制信号输出</td><td></td></tr><tr class="odd"><td>O</td><td>MemWrite_M</td><td>1</td><td>D级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>LSOp_M</td><td>3</td><td>D级控制信号输出（使用）</td><td></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p><span class="math inline">\(Tnew\_M = (Tnew\_E &gt; 0) ? Tnew\_E - 1:0\)</span></p></li></ul><h4 id="w_regmemwb流水寄存器">W_Reg（MEM/WB流水寄存器）</h4><ul><li><p><strong>接口定义</strong></p><table><thead><tr class="header"><th>方向</th><th>信号名</th><th>位宽</th><th>描述</th><th>输入来源</th></tr></thead><tbody><tr class="odd"><td>I</td><td>clk</td><td>1</td><td>时钟信号</td><td>mips.v中的clk</td></tr><tr class="even"><td>I</td><td>reset</td><td>1</td><td>同步复位信号</td><td>mips.v中的reset</td></tr><tr class="odd"><td>I</td><td>M_AO</td><td>32</td><td>M级AO输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>M_DR</td><td>32</td><td>M级DR输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>M_A3</td><td>5</td><td>M级A3输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>M_pc</td><td>32</td><td>M级pc输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>M_pc8</td><td>32</td><td>M级pc8输入</td><td>前一级相同信号</td></tr><tr class="even"><td>I</td><td>RFWrite_M</td><td>1</td><td>M级控制信号输入</td><td>前一级相同信号</td></tr><tr class="odd"><td>I</td><td>SelWOut_M</td><td>2</td><td>M级控制信号输入</td><td>前一级相同信号</td></tr><tr class="even"><td>O</td><td>W_AO</td><td>32</td><td>W级AO输出</td><td></td></tr><tr class="odd"><td>O</td><td>W_DR</td><td>32</td><td>W级DR输出</td><td></td></tr><tr class="even"><td>O</td><td>W_A3</td><td>5</td><td>W级A3输出</td><td></td></tr><tr class="odd"><td>O</td><td>W_pc</td><td>32</td><td>W级pc输出</td><td></td></tr><tr class="even"><td>O</td><td>W_pc8</td><td>32</td><td>W级pc8输出</td><td></td></tr><tr class="odd"><td>O</td><td>RFWrite_W</td><td>1</td><td>W级控制信号输出（使用）</td><td></td></tr><tr class="even"><td>O</td><td>SelWOut_W</td><td>2</td><td>W级控制信号输出（使用）</td><td></td></tr></tbody></table></li></ul><h3 id="控制模块定义">控制模块定义</h3><h4 id="mcu主控制器模块">MCU（主控制器模块）</h4><p>​在主控制模块中，我们对指令中Opcode域和Funct域中的数据进行解码，输出ALUOp,MemtoReg等19条控制指令，从而对数据通路进行调整，满足不同指令的需求。为实现该模块，我们又在内部设计了两个子模块——和逻辑（ANDLogic）和或逻辑（ORLogic）。前者的功能是识别，将输入的Opcode和Funct数据识别为对应的指令，后者的功能是生成，根据输入指令的不同产生不同的控制信号。</p><ul><li><p><strong>输入端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>opcode</td><td>I</td><td>6</td><td>输入D_instr_opcode域数据</td></tr><tr class="even"><td>funt</td><td>I</td><td>6</td><td>输入D_instr_funct域数据</td></tr></tbody></table></li><li><p><strong>输出端口（控制信号）定义</strong></p><table><colgroup><col style="width: 10%"><col style="width: 5%"><col style="width: 8%"><col style="width: 49%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>信号名</th><th>位宽</th><th>作用级</th><th>描述</th><th>相关指令</th></tr></thead><tbody><tr class="odd"><td>RFWrite</td><td>1</td><td>W</td><td>GRF写使能信号</td><td></td></tr><tr class="even"><td>MemWrite</td><td>1</td><td>M</td><td>DM写入使能信号</td><td>store型：sw, sb, sh</td></tr><tr class="odd"><td>SelA3</td><td>2</td><td>D</td><td>对MUX_A3的输出进行选择</td><td></td></tr><tr class="even"><td>SelEMOut</td><td>1</td><td>E、M</td><td>对MUX_E_out和MUX_M_out的输出进行选择</td><td>jr</td></tr><tr class="odd"><td>SelWOut</td><td>2</td><td>W</td><td>对MUX_W_out的输出进行选择</td><td></td></tr><tr class="even"><td>SelALUB</td><td>1</td><td>E</td><td>对MUX_ALU_B的输出进行选择</td><td></td></tr><tr class="odd"><td>SelALUS</td><td>1</td><td>E</td><td>对MUX_ALU_S的输出进行选择</td><td>shift型、shiftv型</td></tr><tr class="even"><td>NPCOp</td><td>3</td><td>D</td><td>NPC模块功能选择信号</td><td></td></tr><tr class="odd"><td>CMPOp</td><td>3</td><td>D</td><td>CMP模块功能选择信号</td><td></td></tr><tr class="even"><td>EXTOp</td><td>2</td><td>D</td><td>EXT模块功能选择信号</td><td></td></tr><tr class="odd"><td>LSOp</td><td>3</td><td>M</td><td>DM模块功能选择信号</td><td></td></tr><tr class="even"><td>ALUOp</td><td>4</td><td>E</td><td>ALU模块功能选择信号</td><td></td></tr></tbody></table></li><li><p>注：该模块中的“Sel”型信号均作用于功能MUX</p></li></ul><h4 id="hcu冒险控制器模块">HCU（冒险控制器模块）</h4><p>​在冒险控制模块中，我们通过对传入的<strong>“A”</strong>（A1，A2，A3）和<strong>“T”</strong>（Tnew，Tuse）进行分析，判断当前需要进行转发（<strong>forward</strong>）还是暂停（<strong>stall</strong>），并通过组合逻辑生成相应控制信号。</p><ul><li><p><strong>输入端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>D_A1</td><td>I</td><td>5</td><td>D级A1输入</td></tr><tr class="even"><td>D_A2</td><td>I</td><td>5</td><td>D级A2输入</td></tr><tr class="odd"><td>E_A1</td><td>I</td><td>5</td><td>E级A1输入</td></tr><tr class="even"><td>E_A2</td><td>I</td><td>5</td><td>E级A2输入</td></tr><tr class="odd"><td>M_A2</td><td>I</td><td>5</td><td>M级A2输入</td></tr><tr class="even"><td>E_A3</td><td>I</td><td>5</td><td>E级A3输入</td></tr><tr class="odd"><td>M_A3</td><td>I</td><td>5</td><td>M级A3输入</td></tr><tr class="even"><td>W_A3</td><td>I</td><td>5</td><td>W级A3输入</td></tr><tr class="odd"><td>Tuse_rs</td><td>I</td><td>2</td><td>D级MCU中输出的Tuse_rs信号</td></tr><tr class="even"><td>Tuse_rt</td><td>I</td><td>2</td><td>D级MCU中输出的Tuse_rt信号</td></tr><tr class="odd"><td>Tnew_E</td><td>I</td><td>2</td><td>E级Tnew_E信号输入</td></tr><tr class="even"><td>Tnew_M</td><td>I</td><td>2</td><td>M级Tnew_M信号输入</td></tr><tr class="odd"><td>Tnew_W</td><td>I</td><td>2</td><td>W级Tnew_W信号输入</td></tr></tbody></table></li><li><p><strong>输出端口（控制信号）定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>位宽</th><th>作用级</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>FwdCMPD1</td><td>2</td><td>D</td><td>对HMUX_CMP_D1的输出进行选择</td></tr><tr class="even"><td>FwdCMPD2</td><td>2</td><td>D</td><td>对HMUX_CMP_D2的输出进行选择</td></tr><tr class="odd"><td>FwdALUA</td><td>2</td><td>E</td><td>对HMUX_ALU_A的输出进行选择</td></tr><tr class="even"><td>FwdALUB</td><td>2</td><td>E</td><td>对HMUX_ALU_B的输出进行选择</td></tr><tr class="odd"><td>FwdDM</td><td>1</td><td>M</td><td>对HMUX_DM的输出进行选择</td></tr><tr class="even"><td>stall</td><td>1</td><td>F、D、M</td><td>暂停信号</td></tr></tbody></table></li><li><p>注：该模块中的“Fwd”型信号均作用于转发MUX</p></li><li><p>注：该模块中的stall信号同时作用与IFU，D_Reg，E_Reg</p></li></ul><h3 id="选择器模块">选择器模块</h3><h4 id="功能mux">功能MUX</h4><table><colgroup><col style="width: 9%"><col style="width: 8%"><col style="width: 63%"><col style="width: 10%"><col style="width: 8%"></colgroup><thead><tr class="header"><th>MUX名</th><th>选择数量</th><th>描述</th><th>输出信号名</th><th>控制信号</th></tr></thead><tbody><tr class="odd"><td>MUX_A3</td><td>3</td><td>D级中A3输入信号进行选择<br>0：D_instr_rt<br>1：D_instr_rd<br>2：0x1f</td><td>D_A3</td><td>SelA3</td></tr><tr class="even"><td>MUX_ALU_B</td><td>2</td><td>对E级ALU模块src_B接口的信号进行选择<br>0：E_V2_f<br>1：E_E32</td><td>ALU_B</td><td>SelALUB</td></tr><tr class="odd"><td>MUX_ALU_S</td><td>2</td><td>对E级ALU模块src_S接口的信号进行选择<br>0：E_instr_s<br>1：E_V1_f</td><td>ALU_S</td><td>SelALUS</td></tr><tr class="even"><td>MUX_E_out</td><td>2</td><td>对E级储存的计算结果进行选择<br>0：E_32<br>1：E_pc8</td><td>E_out</td><td>SelEMOut</td></tr><tr class="odd"><td>MUX_M_out</td><td>2</td><td>对M级储存的计算结果进行选择<br>0：M_AO<br>1：M_pc8</td><td>M_out</td><td>SelEMOut</td></tr><tr class="even"><td>MUX_W_out</td><td>3</td><td>对W级储存的计算结果进行选择<br>0：W_AO<br>1：W_DR<br>2：W_pc8</td><td>W_out</td><td>SelWOut</td></tr></tbody></table><h4 id="转发mux">转发MUX</h4><table><colgroup><col style="width: 11%"><col style="width: 8%"><col style="width: 61%"><col style="width: 10%"><col style="width: 8%"></colgroup><thead><tr class="header"><th>MUX名</th><th>选择数量</th><th>描述</th><th>输出信号名</th><th>控制信号</th></tr></thead><tbody><tr class="odd"><td>HMUX_CMP_D1</td><td>3</td><td>将数据转发到CMP_D1接口<br>0：GRF_RD1<br>1：M_out<br>2：E_out</td><td>D_V1_f</td><td>FwdCMPD1</td></tr><tr class="even"><td>HMUX_CMP_D2</td><td>3</td><td>将数据转发到CMP_D2接口<br>0：GRF_RD2<br>1：M_out<br>2：E_out</td><td>D_V2_f</td><td>FwdCMPD2</td></tr><tr class="odd"><td>HMUX_ALU_A</td><td>3</td><td>将数据转发到ALU_A接口<br>0：E_V1<br>1：W_out<br>2：M_out</td><td>E_V1_f</td><td>FwdALUA</td></tr><tr class="even"><td>HMUX_ALU_B</td><td>3</td><td>将数据转发到ALU_B接口<br>0：E_V2<br>1：W_out<br>2：M_out</td><td>E_V2_f</td><td>FwdALUB</td></tr><tr class="odd"><td>HMUX_DM</td><td>2</td><td>将数据转发到DM_WD接口<br>0：M_V2<br>1：W_out</td><td>M_V1_f</td><td>FwdDM</td></tr></tbody></table><h2 id="重要机制实现方法">重要机制实现方法</h2><h3 id="分支转移实现">分支转移实现</h3><h4 id="b类指令">B类指令</h4><p>​为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将B类指令的判断进行前置，单独使用CMP模块进行判断。当B类指令进入D级后（此时F级的指令为编译优化调度的指令），CMP模块的判断结果进入NPC，如过CMP结果为真（CMP_out=1）而且NPCOp信号为0x001（说明当前指令为B类指令），NPC输出转移的地址npc并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><h4 id="j和jal">j和jal</h4><p>​当j或jal进入D级后（此时F级的指令为编译优化调度的指令），D_instr中imm26域的数据进入NPC进行处理，如果当前NPCOp信号为0x010（说明当前指令为jal或j指令），NPC输出转移的地址npc，并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><p>​jal指令在实现跳转的同时，还需要将下一条指令的地址存入31号寄存器中，因此我们需要在IFU中计算出改地址，并随着jal指令进行流水，最终在W级写入GRF的31号寄存器。由于存在延迟槽，pc+4地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为pc+8。</p><h4 id="jr">jr</h4><p>​当jr进入D级后（此时F级的指令为编译优化调度的指令），D_V1_f（经过转发后的D_V1值）进入NPC，如果当前NPCOp信号为0x011（说明当前指令为jr指令），NPC输出转移的地址npc，并进入IFU的输入端，在下一时钟沿上升时进入F级，实现转移。</p><h3 id="冒险处理">冒险处理</h3><p>冒险处理我们均通过“A_T”法实现——</p><h4 id="转发forward">转发（forward）</h4><p>​当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p><p>​在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p><ul><li><p><strong>供应者及其产生的数据</strong></p><table><thead><tr class="header"><th>流水级</th><th>产生数据</th><th>MUX名&amp;选择信号名</th><th>MUX输出名</th></tr></thead><tbody><tr class="odd"><td>E</td><td>E_E32，E_pc8</td><td>MUX_E_out &amp; SelEMOut</td><td>E_out</td></tr><tr class="even"><td>M</td><td>M_AO，M_pc8</td><td>MUX_M_out &amp; SelEMOut</td><td>M_out</td></tr><tr class="odd"><td>W</td><td>W_AO，W_RD，W_pc8</td><td>MUX_W_out &amp; SelWOut</td><td>W_out</td></tr></tbody></table></li><li><p><strong>需求者及其产生的数据</strong></p><table><colgroup><col style="width: 20%"><col style="width: 29%"><col style="width: 36%"><col style="width: 13%"></colgroup><thead><tr class="header"><th>接收端口</th><th>选择数据</th><th>HMUX名&amp;选择信号名</th><th>MUX输出名</th></tr></thead><tbody><tr class="odd"><td>CMP_D1/NPC_ra</td><td>D_V1，M_out，E_out</td><td>HMUX_CMP_D1 &amp; FwdCMPD1</td><td>D_V1_f</td></tr><tr class="even"><td>CMP_D2</td><td>D_v1，M_out，E_out</td><td>HMUX_CMP_D2 &amp; FwdCMPD2</td><td>D_V2_f</td></tr><tr class="odd"><td>ALU_A</td><td>E_V1， W_out，M_out</td><td>HMUX_ALU_A &amp; FwdALUA</td><td>E_V1_f</td></tr><tr class="even"><td>ALU_B</td><td>E_V2，W_out，M_out</td><td>HMUX_ALU_B &amp; FwdALUB</td><td>E_V1_f</td></tr><tr class="odd"><td>DM_WD</td><td>M_V2， W_out</td><td>HMUX_DM &amp; FwdDM</td><td>M_V2_f</td></tr></tbody></table></li></ul><p>​从上表可以看出，W级中的数据没有转发到D级，原因是我们在GRF内实现了内部转发机制，将GRF输入端的数据（还未写入）及时反映到RD1或这RD2，判断条件为<code>A3 ==  A2</code>或者<code>A3 == A1</code>。</p><p>​此时为了生成HMUX的选择信号，我们需要向HCU（冒险控制器）输入”A”数据，然后进行选择信号的计算，执行转发的条件为——</p><ul><li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为0</strong></li><li><strong>写使能信号有效</strong></li></ul><p>​根据以上条件我们可以生成上面的5个HMUX选择信号，选择信号的输出值应遵循“就近原则”，及最先产生的数据最先被转发。</p><h4 id="暂停stall">暂停（stall）</h4><p>​接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为D级的指令进行暂停处理。</p><p>​ 我们把Tuse和Tnew作为暂停的判断依据——</p><ul><li>Tuse：指令进入 <strong>D级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2）。</li><li>Tnew：位于 <strong>E级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的CPU 中，W 级的指令Tnew 恒为 0；对于同一条指令，Tnew@M = max(Tnew@E - 1,0)</li></ul><p>​在这一阶段，我们找到D级生成的Tuse_rs和Tuse_rt和在E,M,W级寄存器中流水的Tnew_D，Tnew_M，Tnew_W，如下表所示</p><ul><li><p><strong>Tuse表</strong></p><table><thead><tr class="header"><th>指令类型</th><th>Tuse_rs</th><th>Tuse_rt</th></tr></thead><tbody><tr class="odd"><td>calc_R</td><td>1</td><td>1</td></tr><tr class="even"><td>calc_I</td><td>1</td><td>X</td></tr><tr class="odd"><td>shift</td><td>X</td><td>1</td></tr><tr class="even"><td>shiftv</td><td>1</td><td>1</td></tr><tr class="odd"><td>load</td><td>1</td><td>X</td></tr><tr class="even"><td>store</td><td>1</td><td>2</td></tr><tr class="odd"><td>branch</td><td>0</td><td>0</td></tr><tr class="even"><td>jump</td><td>X</td><td>X</td></tr><tr class="odd"><td>jr</td><td>0</td><td>X</td></tr></tbody></table></li><li><p><strong>Tnew表</strong></p><table><thead><tr class="header"><th>指令类型</th><th>Tnew_D</th><th>Tnew_E</th><th>Tnew_M</th><th>Tnew_W</th></tr></thead><tbody><tr class="odd"><td>calc_R</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>calc_I</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>shift</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>shiftv</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>load</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr class="even"><td>store</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="odd"><td>branch</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="even"><td>jal</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>jr</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr class="even"><td>lui</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></li></ul><p>​然后我们Tnew和Tuse传入HCU（冒险控制器中），然后进行stall信号的计算。如果Tnew&gt; TuseHCU中的stall信号值为1，此时执行以下操作——</p><ul><li><strong>冻结PC寄存器（IFU_en = ~stall = 0）</strong></li><li><strong>冻结D级寄存器（D_en = ~stall = 0）</strong></li><li><strong>清空E级寄存器（E_clr = stall = 1）</strong></li></ul><h2 id="测试方案">测试方案</h2><h3 id="典型测试样例">典型测试样例</h3><h4 id="运算指令测试">运算指令测试</h4><p>该部分测试通过随机数随机生成，以保证测试数据的任意性，然后与同学代码进行对拍，以确定正确性。（随机生成程序与对拍程序均由同学设计）<br>其中一组测试数据如下所示</p><p></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">li <span class="token kernel-function property">$0</span> <span class="token number">1856279938</span>li <span class="token kernel-function property">$1</span> <span class="token number">1934446801</span>li <span class="token kernel-function property">$2</span> <span class="token operator">-</span><span class="token number">1722438048</span>li <span class="token kernel-function property">$3</span> <span class="token operator">-</span><span class="token number">1916920114</span>li <span class="token kernel-function property">$4</span> <span class="token number">661049635</span>li <span class="token kernel-function property">$5</span> <span class="token operator">-</span><span class="token number">1673451598</span>li <span class="token kernel-function property">$6</span> <span class="token number">494171713</span>li <span class="token kernel-function property">$7</span> <span class="token number">1395838457</span>li  <span class="token kernel-function property">$7</span> <span class="token number">0</span>li  <span class="token kernel-function property">$4</span> <span class="token number">0</span>li  <span class="token kernel-function property">$3</span> <span class="token number">0</span>subu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>sltu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>slt <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">xor</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token keyword">xor</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token keyword">xor</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>subu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>slt <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>sltu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>srav <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">xor</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token keyword">xor</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>sltu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>sltu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>srlv <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>slt <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>subu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>srav <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>sllv <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span>andi <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">4839</span>lui <span class="token kernel-function property">$0</span><span class="token punctuation">,</span><span class="token number">50410</span>lui <span class="token kernel-function property">$7</span><span class="token punctuation">,</span><span class="token number">37950</span>slti <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">27385</span>sltiu <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">25736</span>xori <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">21063</span>addiu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">13980</span>sltiu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3696</span>andi <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9134</span>xori <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">6255</span>andi <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">16257</span>andi <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">11820</span>slti <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">27643</span>sltiu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">28474</span>addiu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">27095</span>slti <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">28162</span>slti <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">21601</span>sltiu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">8945</span>ori <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">6182</span>andi <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">50</span>sw <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">2248</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">1490</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">2357</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token function">304</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">797</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">3380</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">2036</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">3090</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token function">2144</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token function">1386</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token function">1450</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">178</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token function">2184</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token function">3686</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">784</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token function">1856</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token function">2054</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token function">2672</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token function">144</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token function">1898</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">0</span>srl <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">2</span>sll <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">5</span>sll <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token number">7</span>sra <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">7</span>sra <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">3</span>sra <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">6</span>srl <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token number">6</span>sll <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">4</span>srl <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token number">6</span>sll <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">2</span>sll <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">1</span>sra <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">5</span>sra <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token number">7</span>sll <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">2</span>srl <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token number">0</span>sra <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">6</span>sra <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">4</span>sra <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token number">5</span>sra <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">5</span>li  <span class="token kernel-function property">$2</span> <span class="token number">0</span>li  <span class="token kernel-function property">$3</span> <span class="token number">0</span>li  <span class="token kernel-function property">$5</span> <span class="token number">0</span>b_test_1_one<span class="token punctuation">:</span>bne <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> b_test_1_one_then<span class="token keyword">or</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>b_test_1_two<span class="token punctuation">:</span>beq <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> b_test_1_two_thenlui <span class="token kernel-function property">$1</span><span class="token punctuation">,</span><span class="token number">33465</span>jal_test_1<span class="token punctuation">:</span>jal jal_test_1_thenlui <span class="token kernel-function property">$5</span><span class="token punctuation">,</span><span class="token number">28752</span>end_1<span class="token punctuation">:</span>srav <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>xori <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4086</span>sb <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">1959</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token number">5</span>……………………………………………………b_test_10_one<span class="token punctuation">:</span>bne <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> b_test_10_one_thensllv <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>b_test_10_two<span class="token punctuation">:</span>blez <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> b_test_10_two_thenaddiu <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">24630</span>jal_test_10<span class="token punctuation">:</span>jal jal_test_10_thenandi <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2262</span>end_10<span class="token punctuation">:</span><span class="token keyword">and</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span>sltiu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10971</span>lhu <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token function">3654</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>srl <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">6</span>j   <span class="token keyword">final</span><span class="token comment">//</span>b_test_1_one_then<span class="token punctuation">:</span><span class="token keyword">nor</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>ori <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">25634</span>sw <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token function">3824</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>srl <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token number">2</span>j b_test_1_two<span class="token keyword">and</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>b_test_1_two_then<span class="token punctuation">:</span><span class="token keyword">or</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>andi <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">31499</span>sw <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">2876</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">6</span>jal jal_test_1addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>jal_test_1_then<span class="token punctuation">:</span>sllv <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>sltiu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">21590</span>lh <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token function">3136</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sra <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">2</span>addiu <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span><span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token number">8</span>blez <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> end_1sllv <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>ori <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">28484</span>lb <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token function">1030</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">7</span>jr <span class="token kernel-function property">$ra</span>…………………………………………b_test_10_one_then<span class="token punctuation">:</span>sltu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>addiu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">3346</span>sh <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">2950</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>srl <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token number">1</span>j b_test_10_twoslt <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>b_test_10_two_then<span class="token punctuation">:</span><span class="token keyword">xor</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>slti <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">16048</span>lh <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">146</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sra <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">6</span>jal jal_test_10addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>jal_test_10_then<span class="token punctuation">:</span>srav <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>lui <span class="token kernel-function property">$6</span><span class="token punctuation">,</span><span class="token number">58558</span>lbu <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token function">3162</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token number">2</span>addiu <span class="token kernel-function property">$ra</span><span class="token punctuation">,</span><span class="token kernel-function property">$ra</span><span class="token punctuation">,</span> <span class="token number">8</span>bgtz <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> end_10<span class="token keyword">or</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span>addiu <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">16811</span>lb <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token function">4069</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sll <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token number">0</span>jr <span class="token kernel-function property">$ra</span><span class="token keyword">final</span><span class="token punctuation">:</span>nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="转移指令b类和j类测试">转移指令（B类和J类）测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">main<span class="token punctuation">:</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1000</span>li<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">1000</span>lui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000#s3 is  <span class="token operator">-</span><span class="token number">2147483648</span>lui<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000ori<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x0001#s4 is  <span class="token operator">-</span><span class="token number">2147483647</span>lui<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>xffff#s5 is  <span class="token number">2147483647</span>lui<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>xfffe#s6 is <span class="token number">2147483646</span>beq_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> beq_1_testnopbeq_2<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> beq_2_testnop……beq_10<span class="token punctuation">:</span>  beq<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> beq_10_testnopbeq_end<span class="token punctuation">:</span>bne_1<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> bne_1_testnop……bne_10<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> bne_10_testnopbne_end<span class="token punctuation">:</span>blez_1<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> blez_1_testnop……blez_10<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> blez_10_testnopblez_end<span class="token punctuation">:</span>bgtz_1<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span>bgtz_1_testnop……bgtz_10<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span>bgtz_10_testnopbgtz_end<span class="token punctuation">:</span>jal_1<span class="token punctuation">:</span>jaljal_1_testnop……jal_5<span class="token punctuation">:</span>jaljal_5_testnopjal_end<span class="token punctuation">:</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscallbeq_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_2nop……beq_10_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_endnopbne_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_2nop……bne_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_endnopblez_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_2nop……blez_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_endnopbgtz_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_2nop……bgtz_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_endnopjal_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>nop……jal_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>nopjalr_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>nop……jalr_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访存指令测试">访存指令测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">.</span>textli<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>xABCF1234li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">0</span>x1234ABCDli<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>xa1b2c3d4li<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fff0000sb<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">100</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">103</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">105</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">107</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">108</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">110</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">112</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">114</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">16</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">20</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">24</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">28</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">32</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">36</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">40</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">44</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">48</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">52</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">56</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">60</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">64</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">68</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">72</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">76</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">6</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">80</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">84</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">88</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">92</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动测试工具">自动测试工具</h3><ul><li><p><strong>测试代码生成工具（python）</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">    <span class="token keyword">import</span> random    list_R <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"addu"</span><span class="token punctuation">,</span> <span class="token string">"subu"</span><span class="token punctuation">,</span> <span class="token string">"and"</span><span class="token punctuation">,</span> <span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"nor"</span><span class="token punctuation">,</span> <span class="token string">"xor"</span><span class="token punctuation">,</span> <span class="token string">"sltu"</span><span class="token punctuation">,</span> <span class="token string">"slt"</span><span class="token punctuation">,</span> <span class="token string">"sllv"</span><span class="token punctuation">,</span> <span class="token string">"srlv"</span><span class="token punctuation">,</span> <span class="token string">"srav"</span><span class="token punctuation">]</span>  list_I <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"andi"</span><span class="token punctuation">,</span> <span class="token string">"addiu"</span><span class="token punctuation">,</span> <span class="token string">"ori"</span><span class="token punctuation">,</span> <span class="token string">"xori"</span><span class="token punctuation">,</span> <span class="token string">"lui"</span><span class="token punctuation">,</span> <span class="token string">"slti"</span><span class="token punctuation">,</span> <span class="token string">"sltiu"</span><span class="token punctuation">]</span>  list_LS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lw"</span><span class="token punctuation">,</span> <span class="token string">"sw"</span><span class="token punctuation">,</span> <span class="token string">"lh"</span><span class="token punctuation">,</span> <span class="token string">"lhu"</span><span class="token punctuation">,</span> <span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"lb"</span><span class="token punctuation">,</span> <span class="token string">"lbu"</span><span class="token punctuation">,</span> <span class="token string">"sb"</span><span class="token punctuation">]</span>  list_shift <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"sll"</span><span class="token punctuation">,</span> <span class="token string">"srl"</span><span class="token punctuation">,</span> <span class="token string">"sra"</span><span class="token punctuation">]</span>  list_B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"bne"</span><span class="token punctuation">,</span> <span class="token string">"beq"</span><span class="token punctuation">]</span>      <span class="token keyword">def</span> <span class="token function">R_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_R<span class="token punctuation">)</span>          rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span>          rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span>          rd <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span>          s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, ${}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">I_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_I<span class="token punctuation">)</span>          rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          imm <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">32768</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">)</span>          abs_imm <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"lui"</span><span class="token punctuation">:</span>              s <span class="token operator">=</span> <span class="token string">"{} ${},{}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rt<span class="token punctuation">,</span> abs_imm<span class="token punctuation">)</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_I<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rt<span class="token punctuation">,</span> rs<span class="token punctuation">,</span> imm<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">LS_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_LS<span class="token punctuation">)</span>          ins <span class="token operator">=</span> list_LS<span class="token punctuation">[</span>k<span class="token punctuation">]</span>          num <span class="token operator">=</span> <span class="token number">0</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>ins<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>          <span class="token keyword">elif</span><span class="token punctuation">(</span>ins<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              num <span class="token operator">=</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4096</span>                    rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          s <span class="token operator">=</span> <span class="token string">"{} ${}, {}($0)\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>ins<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> num<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">shift_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_shift<span class="token punctuation">)</span>          shamt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          rd <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_shift<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> shamt<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">B_test</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> lable<span class="token punctuation">)</span><span class="token punctuation">:</span>      k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_B<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          rt <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          s <span class="token operator">=</span> <span class="token string">"{} ${}, ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> lable<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          rs <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>          s <span class="token operator">=</span> <span class="token string">"{} ${}, {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>list_B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> rs<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>lable<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">b_begin</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_one_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"b_test_{}_two:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"b_test_{}_two_then"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal_test_{}:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}_then\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"end_{}:\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>        R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">b_end</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_one_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"j b_test_{}_two\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\nb_test_{}_two_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jal jal_test_{}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addu $1, $ra, $0\n"</span><span class="token punctuation">)</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\njal_test_{}_then:\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"addiu $ra,$ra, 8\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      B_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"end_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"jr $ra\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"mips_code.asm"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          temp <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span>          s <span class="token operator">=</span> <span class="token string">"li ${} {}\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>          <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>      index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>      index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>        R_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>      I_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>      LS_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>      shift_test<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>        index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>      index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>      index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"li  ${} 0\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          b_begin<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"j   final\n"</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          b_end<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>i<span class="token punctuation">)</span>      <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"final:\n"</span><span class="token punctuation">)</span><span class="token operator">-</span> 自动测试工具（python）  在使用前，我们需要将下方r_road和xilinx_path中输入工程文件夹路径和ISE路径。在终端运行这个代码（test<span class="token punctuation">.</span>py）后，首先需要输入测试次数，对于每一次测试，我们运行一次代码自动生成工具（generate_2<span class="token punctuation">.</span>py）<span class="token punctuation">,</span>生成MIPS代码（mips_code<span class="token punctuation">.</span>asm）<span class="token punctuation">,</span>然后会启动mars和ISE分别获得标准输出和测试输出，最后进行文本比较。如果出现错误，会自动生成错误日志文件，显示错误行数和相应mips机器码、标准输出、测试输出。如果想要对自己写的MIPS代码进行测试，只需要将第<span class="token number">100</span>行注释掉，运行次数填写为<span class="token number">1</span>即可。  ```python  <span class="token keyword">import</span> os  <span class="token keyword">import</span> shutil  p_road <span class="token operator">=</span> <span class="token string">"D:\\Code\\Verilog\\homework_code\\P5_cpu_test"</span>  run_time <span class="token operator">=</span> <span class="token string">"20us"</span>  xilinx_path <span class="token operator">=</span> <span class="token string">"E:\\Xilinx\\14.7\\ISE_DS\\ISE"</span>  error <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">run_mars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"编译并运行MIPS文件……"</span><span class="token punctuation">)</span>      os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar mars.jar db mc CompactDataAtZero a dump .text HexText code.txt nc mips_code.asm"</span><span class="token punctuation">)</span>      os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar mars.jar db mc CompactDataAtZero nc mips_code.asm &gt; mips_out.txt"</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">load_hex_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      list_temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> hex_code<span class="token punctuation">:</span>          list_temp <span class="token operator">=</span> hex_code<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\\code.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file_to_IM<span class="token punctuation">:</span>          file_to_IM<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>      hex_code<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>      file_to_IM<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">run_ise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"编译并运行Verilog文件……"</span><span class="token punctuation">)</span>            file_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token punctuation">,</span>k <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>p_road<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>              <span class="token keyword">if</span> <span class="token builtin">file</span><span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">".v"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                  file_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\\mips.prj"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> prj<span class="token punctuation">:</span>          <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>file_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              prj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Verilog work \""</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> file_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\"\n"</span><span class="token punctuation">)</span>                   <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\mips.tcl"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tcl<span class="token punctuation">:</span>          tcl<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"run "</span> <span class="token operator">+</span> run_time <span class="token operator">+</span><span class="token string">";\nexit"</span><span class="token punctuation">)</span>            prj<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>      tcl<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"XILINX"</span><span class="token punctuation">]</span> <span class="token operator">=</span> xilinx_path      os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>xilinx_path <span class="token operator">+</span> <span class="token string">"\\bin\\nt64\\fuse -nodebug -prj "</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt"</span><span class="token punctuation">)</span>      os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mips.exe -nolog -tclbatch "</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\mips.tcl&gt; verilog_out.txt"</span><span class="token punctuation">)</span>      <span class="token comment"># print("mips.exe -nolog -tclbatch " + p_road + "\\mips.tcl &gt; verilog_out.txt")</span>    <span class="token keyword">def</span> <span class="token function">copy_file</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target_road<span class="token punctuation">)</span><span class="token punctuation">:</span>      f_1 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>      list_temp <span class="token operator">=</span> f_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>      f_2 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>target_road <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>      f_2<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>      f_1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>      f_2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">file_cmp</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"mips_out.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_1<span class="token punctuation">:</span>          out_std <span class="token operator">=</span> out_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>          out_std<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>          out_1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"verilog_out.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_2<span class="token punctuation">:</span>          out_test <span class="token operator">=</span> out_2<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>          <span class="token comment"># out_2.truncate()</span>          <span class="token comment"># out_2.writelines(out_test)</span>          out_2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            flag <span class="token operator">=</span> <span class="token number">0</span>      <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">".\\log.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> log<span class="token punctuation">:</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>              flag <span class="token operator">=</span> <span class="token number">1</span>              log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Too few output! Expected output-lines is {}\nBut your output-lines is {}\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>              <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                      log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Error in line {}\nExpected output is \"{}\"\nBut your outout is \"{}\"\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        log<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试结果:  Failed!"</span><span class="token punctuation">)</span>          os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">".\\test_log_file\\log_{}\\"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>          copy_file<span class="token punctuation">(</span><span class="token string">"log.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>          copy_file<span class="token punctuation">(</span><span class="token string">"mips_code.asm"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>          copy_file<span class="token punctuation">(</span><span class="token string">"mips_out.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>          copy_file<span class="token punctuation">(</span><span class="token string">"verilog_out.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试结果:  Accepted!"</span><span class="token punctuation">)</span>          test_times <span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入测试次数："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"错误日志文件夹已创建！"</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">".\\test_log_file"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span><span class="token string">".\\test_log_file"</span><span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试开始！\n"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>test_times <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"python generate_2.py"</span><span class="token punctuation">)</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n测试进度:  {}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> test_times<span class="token punctuation">)</span><span class="token punctuation">)</span>      run_mars<span class="token punctuation">(</span><span class="token punctuation">)</span>      load_hex_code<span class="token punctuation">(</span><span class="token punctuation">)</span>      run_ise<span class="token punctuation">(</span><span class="token punctuation">)</span>      file_cmp<span class="token punctuation">(</span>i<span class="token punctuation">)</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="思考题">思考题</h2><h3 id="流水线冒险">流水线冒险</h3><ol type="1"><li><p><strong>在采用本节所述的控制冒险处理方式下，PC的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</strong></p><p><strong>A</strong>：当需要进行暂停时，IFU的使能信号失效，PC值不变。当不需要进行分支转移和跳转时，NPC中将F_pc信号加4处理返回IFU，下一时钟沿来临时更新为F_pc+4。当执行分支指令时，NPC将D_pc+4和符号扩展后的imm16相加，返回IFU，下一时钟沿上升时更新。当执行j/jal指令时，NPC将imm26进行扩展（前四位补D_pc的前四位，后两位补0），返回IFU，下一时钟沿上升时更新。当执行jr指令时，NPC将从GRF的RD1端口（考虑转发）输出的值输出，返回IFU下一时钟沿上升时更新。</p></li><li><p><strong>对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写PC+8 ？</strong></p><p><strong>A</strong>：因为需要考虑编译优化，jal的下一条指令是延迟槽中的指令，在jal执行前会被执行。如果回写PC+4的话，当出现“jr$ra”时，将会回到延迟槽，重复执行延迟槽中的指令。因此需要回写PC+8。</p></li></ol><h3 id="数据冒险的分析">数据冒险的分析</h3><ol type="1"><li><p><strong>为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由ALU 或者 DM 等部件来提供数据？</strong></p><p><strong>A</strong>：因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</p></li></ol><h3 id="at-法处理流水线数据冒险">AT 法处理流水线数据冒险</h3><ol type="1"><li><p><strong>“转发（旁路）机制的构造”中的 Thinking 1-4；</strong></p><p><strong>Thinking1</strong>：如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</p><p><strong>A</strong>：例如：</p><pre class="line-numbers language-none"><code class="language-none">$s0, $0, 4andi$s1, $s0, 5sw      $s1, 4($s0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Thinking 2</strong>：我们为什么要对 GPR采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</p><p><strong>A</strong>：因为需要使得W级保存的将要写入得数据及时反馈到GRF的输出端口，从而规避数据冒险。如果不采用内部转发，我们可以在GRF的输出端口加入多路选择器，将W级的数据进行转发。</p><p><strong>Thinking 3</strong>：为什么 0 号寄存器需要特殊处理？</p><p><strong>A</strong>：因为对0号寄存器的写入是无效的，如果不特殊处理，则会使得向0号寄存器写入的数据（无效输入）被错误转发，从而造成BUG。</p><p><strong>Thinking 4</strong>：什么是“最新产生的数据”？</p><p><strong>A</strong>:距离当前需求者最近的流水寄存器中储存的数据。</p></li><li><p><strong>在 AT方法讨论转发条件的时候，只提到了“供给者需求者的A相同，且不为 0”，但在CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A的时候，要结合 we 做什么操作呢？</strong></p><p><strong>A</strong>：因为当we信号为0时我们就把RF写入地址置为0，因此如果“供给者的A不为0”，就已经排除了“写入信号为0”的情况。</p></li></ol><h3 id="在线测试相关说明">在线测试相关说明</h3><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略，</strong>比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p><p>此思考题请同学们结合自己测试 CPU使用的具体手段，按照自己的实际情况进行回答。</p><p><strong>A</strong>：我是采用半随机生成半手动构造的方法。对于功能型指令，完全通过python脚本自动生成。并且为了提高数据冲突的概率，我们仅仅使用0~7号寄存器进行测试。对于跳转指令，我们先使用一定模板进行构建，然后为了增加数据冒险和控制冒险，我们又手动进行一定修改，使得测试样例尽可能更多的覆盖所有可能的情况</p><h2 id="附录">附录</h2><p><img src="RTL综合表.png"></p><p><img src="pipline.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P4_单周期cpu（Verilog实现）</title>
      <link href="/2021/11/09/co/co-p4-dan-zhou-qi-cpu-verilog-shi-xian/"/>
      <url>/2021/11/09/co/co-p4-dan-zhou-qi-cpu-verilog-shi-xian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单周期cpu设计方案">单周期CPU设计方案</h2><h3 id="设计概述">设计概述</h3><p>本文所设计的CPU为Verilog实现的单周期MIPS架构CPU，该CPU支持43条MIPS汇编指令，为了实现该功能，笔者设计了IFU，GRF，NPC，ALU，DM，Controler，BranchControl等关键模块。整个搭建过程通过自下而上的方式完成——先根据应实现的指令对功能部件进行设计与搭建，然后对各个功能部件进行连接，形成完整的数据通路。</p><p><img src="CPU.png"></p><h3 id="实现指令说明">实现指令说明</h3><p> 本CPU支持43条指令，包括19条R型指令，2条J型指令，22条I型指令。</p><h4 id="r型指令">R型指令</h4><ul><li>算数/位运算指令：add, addu, sub, subu, and, or, nor, xor</li><li>移位指令：sll, srl, sra, sllv, srlv, srav</li><li>置位指令：slt, sltu</li><li>跳转指令：jr, jalr</li></ul><h4 id="j型指令">J型指令</h4><ul><li>跳转指令：j, jal</li></ul><h4 id="i型指令">I型指令</h4><ul><li>算数/位运算指令： addi, andi, addiu, ori, xori, lui</li><li>B类指令：beq, bne, bgtz, bgez, blez, bltz</li><li>置位指令：slti, sltiu</li><li>访存指令：lw, sw, lh, lhu, lb, lbu, sh, sb</li></ul><h3 id="数据通路模块定义">数据通路模块定义</h3><h4 id="ifu取指令单元">IFU（取指令单元）</h4><p>  该模块内部包含PC（程序计数器）和IM（指令存储器容量为32*1024bit）。可以根据PC的值从IM取出对应的指令，并具有同步复位的功能。</p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>reset</td><td>I</td><td>1</td><td>同步复位信号</td></tr><tr class="odd"><td>stop</td><td>I</td><td>1</td><td>停止信号</td></tr><tr class="even"><td>next_pc</td><td>I</td><td>32</td><td>下一条要被执行的指令的地址</td></tr><tr class="odd"><td>pc</td><td>O</td><td>32</td><td>输出当前正在执行的指令的地址</td></tr><tr class="even"><td>instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>当reset信号有效时，将PC寄存器中的值置为0x00000000</td></tr><tr class="even"><td>2</td><td>停止</td><td>当stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr class="odd"><td>3</td><td>写PC寄存器</td><td>当stop信号失效且时钟上升沿来临时，将下一条指令的地址（next_pc）写入PC寄存器</td></tr><tr class="even"><td>4</td><td>取指令</td><td>根据当前PC的值从IM（指令存储器）中读出对应的指令到instr端口</td></tr></tbody></table></li></ul><h4 id="grf通用寄存器组">GRF（通用寄存器组）</h4><p>该模块内部包含32个具有写使能32位寄存器，分别对应MIPS架构中$0 ~$31通用寄存器（其中0号寄存器中的值恒为0，即不具备写使能）。GRF可以实现异步复位，同时可以根据输入的5位地址（0~31）向寄存器堆存取数据，实现定向访存寄存器。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>pc</td><td>I</td><td>1</td><td>当前指令地址</td></tr><tr class="odd"><td>reset</td><td>I</td><td>1</td><td>同步复位信号 1：复位信号有效 0：复位信号无效</td></tr><tr class="even"><td>read_addr_1</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD1</td></tr><tr class="odd"><td>read_addr_2</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD2</td></tr><tr class="even"><td>write_addr</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其作为写入目标</td></tr><tr class="odd"><td>write_data</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="even"><td>RegWrite</td><td>I</td><td>1</td><td>写使能信号 1：写入有效 0：写入失效</td></tr><tr class="odd"><td>read_data_1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr class="even"><td>read_data_2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出read_addr_1，read_addr_2地址对应的寄存器中储存的数据，将其加载到read_data_1和read_data_2</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当RegWrite信号有效且时钟上升沿来临时，将write_data中的数据写入到write_addr地址对应的寄存器</td></tr></tbody></table></li></ul><h4 id="npc下一指令计算单元">NPC（下一指令计算单元）</h4><p>该模块根据当前指令地址和控制信号，计算出下一指令所在的地址。<br>- <strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>pc</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr class="even"><td>offset</td><td>I</td><td>32</td><td>地址偏移量，用于计算B类指令所要跳转的地址</td></tr><tr class="odd"><td>instr_26</td><td>I</td><td>26</td><td>当前指令数据的前26位（0~25），用于计算jal和j指令所要跳转的地址</td></tr><tr class="even"><td>ra_data</td><td>I</td><td>32</td><td>储存在寄存器（$ra或是jalr指令中存储“PC+4”的寄存器）中的地址数据，用于实现jr和jalr指令</td></tr><tr class="odd"><td>branch_judge</td><td>I</td><td>1</td><td>B类指令分支条件判断结果 1：B类指令分支条件成立0：B类指令分支条件不成立</td></tr><tr class="even"><td>NPCOp</td><td>I</td><td>3</td><td>对输出next_pc的值进行选择 0b000:next_pc为pc+40b001:next_pc为分支的地址 0b010:next_pc为j型指令的跳转地址0b011:next_pc为寄存器中保存的地址</td></tr><tr class="odd"><td>next_pc</td><td>O</td><td>32</td><td>输出下一指令地址</td></tr><tr class="even"><td>pc+4</td><td>O</td><td>32</td><td>输出pc+4的值，用于实现jal和jalr指令中的地址存储</td></tr></tbody></table><h4 id="alu逻辑运算单元">ALU（逻辑运算单元）</h4><p> 该模块可实现加，减，按位与，按位或等11种运算，并根据ALUOP信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th><strong>信号名</strong></th><th><strong>方向</strong></th><th><strong>位宽</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td>ALUOp</td><td>I</td><td>4</td><td>ALU功能选择信号</td></tr><tr class="even"><td>src_A</td><td>I</td><td>32</td><td>参与ALU计算的第一个值</td></tr><tr class="odd"><td>src_B</td><td>I</td><td>32</td><td>参与ALU计算的第二个值</td></tr><tr class="even"><td>shamt</td><td>I</td><td>5</td><td>移位数输入</td></tr><tr class="odd"><td>FlowJudge</td><td>I</td><td>1</td><td>溢出判断信号 1：进行溢出判断 0：不进行溢出判断</td></tr><tr class="even"><td>equal</td><td>O</td><td>1</td><td>相等判断信号 1：src_A和src_B相等 0：src_A和src_B不相等</td></tr><tr class="odd"><td>ALU_result</td><td>O</td><td>32</td><td>输出ALU计算结果</td></tr><tr class="even"><td>flow_result</td><td>O</td><td>1</td><td>输出ALU计算结果的溢出情况（add，sub，addi等指令有效）</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>ALU_Op</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>加</td><td>0b0000</td><td>ALU_result = src_A + src_B</td></tr><tr class="even"><td>2</td><td>减</td><td>0b0001</td><td>ALU_result = src_A - src_B</td></tr><tr class="odd"><td>3</td><td>按位与</td><td>0b0010</td><td>ALU_result = src_A &amp; src_B</td></tr><tr class="even"><td>4</td><td>按位或</td><td>0b0011</td><td>ALU_result = src_A | src_B</td></tr><tr class="odd"><td>5</td><td>按位异或</td><td>0b0100</td><td>ALU_result = src_A ⊕ src_B</td></tr><tr class="even"><td>6</td><td>按位或非</td><td>0b0101</td><td>ALU_result = ~(src_A | src_B)</td></tr><tr class="odd"><td>7</td><td>逻辑左移</td><td>0b0110</td><td>ALU_result = src_B &lt;&lt; shamt</td></tr><tr class="even"><td>8</td><td>逻辑右移</td><td>0b0111</td><td>ALU_result = src_B &gt;&gt; shamt</td></tr><tr class="odd"><td>9</td><td>算术右移</td><td>0b1000</td><td>ALU_result = src_B &gt;&gt;&gt; shamt</td></tr><tr class="even"><td>10</td><td>带符号比较</td><td>0b1001</td><td>ALU_result = (src_A &gt; src_B) ? 1 : 0（带符号比较）</td></tr><tr class="odd"><td>11</td><td>无符号比较</td><td>0b1010</td><td>ALU_result = (src_A &gt; src_B) ? 1 : 0（无符号比较）</td></tr></tbody></table></li></ul><h4 id="dm-数据存储器">DM （数据存储器）</h4><p>该模块可以实现对数据的存储与访问（包括对字、半字、字节的各种访存操作），还可以实现同步复位。</p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>pc</td><td>I</td><td>32</td><td>当前指令的地址</td></tr><tr class="even"><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="odd"><td>reset</td><td>I</td><td>1</td><td>同步复位信号</td></tr><tr class="even"><td>MemWrite</td><td>I</td><td>1</td><td>储存器写入使能信号 1：写入有效 0：写入失效</td></tr><tr class="odd"><td>addr</td><td>I</td><td>32</td><td>储存器写入地址</td></tr><tr class="even"><td>write_data</td><td>I</td><td>32</td><td>储存器写入数据</td></tr><tr class="odd"><td>LSOp</td><td>I</td><td>3</td><td>访存功能选择 <br>0b000:lw <br>0b001:sw <br>0b010:lh<br>0b011:lhu <br>0b100:sh <br>0b101:lb <br>0b110:lbu<br>0b111:sb</td></tr><tr class="even"><td>read_data</td><td>O</td><td>32</td><td>储存器读出数据</td></tr></tbody></table><h4 id="branch-controlb类指令控制模块">BranchControl（B类指令控制模块）</h4><p>该模块跟据当前所执行的分支指令类型进行相应判断，并将判断结果输出。</p></li><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>cmp_data</th><th>I</th><th>32</th><th>输入32位数据，用于和0进行比较（实现blez，bgez，bltz，bgtz）</th></tr></thead><tbody><tr class="odd"><td>equal</td><td>I</td><td>1</td><td>相等判断信号，即ALU模块中Src_A和Src_B的比较结果（实现beq，bne）</td></tr><tr class="even"><td>BranchOp</td><td>I</td><td>3</td><td>B类指令选择指令 0b000：beq指令 0b001：bgez，bltz 0b010：bgtz0b011：blez 0b100：bne</td></tr><tr class="odd"><td>judge</td><td>I</td><td>1</td><td>区别bgez，bltz两个指令</td></tr><tr class="even"><td>result</td><td>O</td><td>1</td><td>输出判断结果 1：B类指令转移条件成立 0：B类指令转移条件不成立</td></tr></tbody></table></li></ul><h3 id="控制模块定义">控制模块定义</h3><p>在控制模块中，我们对指令中Opcode域和Funct域中的数据进行解码，输出ALUOp,MemtoReg等15条控制指令，从而对数据通路进行调整，满足不同指令的需求。为实现该模块，我们又在内部设计了两个子模块——和逻辑（ANDLogic）和或逻辑（ORLogic）。前者的功能是识别，将输入的Opcode和Funct数据识别为对应的指令，后者的功能是生成，根据输入指令的不同产生不同的控制信号。</p><ul><li><p><strong>控制信号定义</strong></p><table><colgroup><col style="width: 10%"><col style="width: 17%"><col style="width: 10%"><col style="width: 14%"><col style="width: 46%"></colgroup><thead><tr class="header"><th>序号</th><th>信号名</th><th>位宽</th><th>描述</th><th>触发指令（信号为1）</th></tr></thead><tbody><tr class="odd"><td>1</td><td>MemToReg</td><td>1</td><td>GRF中WD接口输入数据选择</td><td></td></tr><tr class="even"><td>2</td><td>MemWrite</td><td>1</td><td>DM写入使能信号</td><td></td></tr><tr class="odd"><td>3</td><td>ALUSrc</td><td>1</td><td>ALU中Src_B接口输入数据选择</td><td></td></tr><tr class="even"><td>4</td><td>RegWrite</td><td>1</td><td>GRF写入使能信号</td><td></td></tr><tr class="odd"><td>5</td><td>SYSCALL</td><td>1</td><td>syscall指令译码信号，GRF中A1接口输入数据选择</td><td></td></tr><tr class="even"><td>6</td><td>SignedExt</td><td>1</td><td>立即数符号扩展选择</td><td></td></tr><tr class="odd"><td>7</td><td>RegDst</td><td>1</td><td>GRF中A3接口输入数据选择</td><td></td></tr><tr class="even"><td>8</td><td>AddrToReg</td><td>1</td><td>指令地址传递信号，选择是否将PC+4输入到GRF的WD端口</td><td></td></tr><tr class="odd"><td>9</td><td>RaLink</td><td>1</td><td><span class="math inline">\(ra寄存器写入选择信号，选择是否将\)</span>ra作为GRF的写入对象</td><td></td></tr><tr class="even"><td>10</td><td>VarShift</td><td>1</td><td>可变移位选择信号，选择是否将指令rs域的五位数据写入ALU的Shift接口</td><td></td></tr><tr class="odd"><td>11</td><td>FlowJudge</td><td>1</td><td>溢出判断选择信号</td><td></td></tr><tr class="even"><td>12</td><td>BranchOp</td><td>3</td><td>B类指令选择信号</td><td></td></tr><tr class="odd"><td>13</td><td>LSOp</td><td>3</td><td>访存操作选择信号</td><td></td></tr><tr class="even"><td>14</td><td>NPCOp</td><td>3</td><td>next_pc输出选择信号</td><td></td></tr><tr class="odd"><td>15</td><td>ALUOp</td><td>4</td><td>ALU功能选择信号</td><td></td></tr></tbody></table></li><li><p>生成代码</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">   <span class="token keyword">assign</span> MemToReg       <span class="token operator">=</span> _lw <span class="token operator">|</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu<span class="token punctuation">;</span>    <span class="token keyword">assign</span> MemWrite       <span class="token operator">=</span> _sw <span class="token operator">|</span> _sh <span class="token operator">|</span> _sb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> ALUSrc         <span class="token operator">=</span> _addi <span class="token operator">|</span> _addiu <span class="token operator">|</span> _andi <span class="token operator">|</span> _ori <span class="token operator">|</span> _xori <span class="token operator">|</span> _slti <span class="token operator">|</span> _sltiu <span class="token operator">|</span> _lw <span class="token operator">|</span> _sw <span class="token operator">|</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _sh <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu <span class="token operator">|</span> _sb <span class="token operator">|</span> _lui<span class="token punctuation">;</span>    <span class="token keyword">assign</span> RegWrite       <span class="token operator">=</span> _sll <span class="token operator">|</span> _sra <span class="token operator">|</span> _srl <span class="token operator">|</span> _add <span class="token operator">|</span> _addu <span class="token operator">|</span> _sub <span class="token operator">|</span> _and <span class="token operator">|</span> _or <span class="token operator">|</span> _nor <span class="token operator">|</span> _slt <span class="token operator">|</span> _sltu <span class="token operator">|</span> _jalr <span class="token operator">|</span> _xor <span class="token operator">|</span> _sllv <span class="token operator">|</span> _srav <span class="token operator">|</span> _srlv <span class="token operator">|</span> _subu <span class="token operator">|</span> _jal <span class="token operator">|</span> _addi <span class="token operator">|</span> _addiu <span class="token operator">|</span> _andi <span class="token operator">|</span> _ori <span class="token operator">|</span> _xori <span class="token operator">|</span> _slti <span class="token operator">|</span> _sltiu <span class="token operator">|</span> _lw <span class="token operator">|</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu <span class="token operator">|</span> _lui<span class="token punctuation">;</span>    <span class="token keyword">assign</span> SYSCALL        <span class="token operator">=</span> _syscall<span class="token punctuation">;</span>    <span class="token keyword">assign</span> SignedExt      <span class="token operator">=</span> _addi <span class="token operator">|</span> _addiu <span class="token operator">|</span> _slti <span class="token operator">|</span> _sltiu <span class="token operator">|</span> _lw <span class="token operator">|</span> _sw <span class="token operator">|</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _sh <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu <span class="token operator">|</span> _sb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> RegDst         <span class="token operator">=</span> _sll <span class="token operator">|</span> _sra <span class="token operator">|</span> _srl <span class="token operator">|</span> _add <span class="token operator">|</span> _addu <span class="token operator">|</span> _sub <span class="token operator">|</span> _and <span class="token operator">|</span> _or <span class="token operator">|</span> _nor <span class="token operator">|</span> _slt <span class="token operator">|</span> _sltu <span class="token operator">|</span> _jalr <span class="token operator">|</span> _xor <span class="token operator">|</span> _sllv <span class="token operator">|</span> _srav <span class="token operator">|</span> _srlv <span class="token operator">|</span> _subu<span class="token punctuation">;</span>    <span class="token keyword">assign</span> AddrToReg      <span class="token operator">=</span> _jalr <span class="token operator">|</span> _jal<span class="token punctuation">;</span>    <span class="token keyword">assign</span> RaLink         <span class="token operator">=</span> _jal<span class="token punctuation">;</span>    <span class="token keyword">assign</span> VarShift       <span class="token operator">=</span> _sllv <span class="token operator">|</span> _srav <span class="token operator">|</span> _srlv<span class="token punctuation">;</span>    <span class="token keyword">assign</span> FlowJudge      <span class="token operator">=</span> _add <span class="token operator">|</span> _sub <span class="token operator">|</span> _addi<span class="token punctuation">;</span>        <span class="token keyword">assign</span> NPCOp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>       <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> NPCOp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _jalr <span class="token operator">|</span> _jr <span class="token operator">|</span> _j <span class="token operator">|</span> _jal<span class="token punctuation">;</span>    <span class="token keyword">assign</span> NPCOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _jalr <span class="token operator">|</span> _jr <span class="token operator">|</span> _beq <span class="token operator">|</span> _bne <span class="token operator">|</span> _bgez <span class="token operator">|</span> _bgtz <span class="token operator">|</span> _blez <span class="token operator">|</span> _bltz<span class="token punctuation">;</span>        <span class="token keyword">assign</span> BranchOp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token operator">=</span> _bne<span class="token punctuation">;</span>    <span class="token keyword">assign</span> BranchOp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token operator">=</span> _bgtz <span class="token operator">|</span> _blez<span class="token punctuation">;</span>    <span class="token keyword">assign</span> BranchOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token operator">=</span> _bgez <span class="token operator">|</span> _blez <span class="token operator">|</span> _bltz<span class="token punctuation">;</span>    <span class="token keyword">assign</span> LSOp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token operator">=</span> _sh <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu <span class="token operator">|</span> _sb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> LSOp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token operator">=</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _lbu <span class="token operator">|</span> _sb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> LSOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token operator">=</span> _sw <span class="token operator">|</span> _lhu <span class="token operator">|</span> _lb <span class="token operator">|</span> _sb<span class="token punctuation">;</span>    <span class="token keyword">assign</span> ALUOp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _sra <span class="token operator">|</span> _slt <span class="token operator">|</span> _sltu <span class="token operator">|</span> _srav <span class="token operator">|</span> _slti <span class="token operator">|</span> _sltiu <span class="token operator">|</span> _lui<span class="token punctuation">;</span>    <span class="token keyword">assign</span> ALUOp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _sll <span class="token operator">|</span> _srl <span class="token operator">|</span> _nor <span class="token operator">|</span> _xor <span class="token operator">|</span> _sllv <span class="token operator">|</span> _srlv <span class="token operator">|</span> _xori<span class="token punctuation">;</span>    <span class="token keyword">assign</span> ALUOp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _sll <span class="token operator">|</span> _srl <span class="token operator">|</span> _and <span class="token operator">|</span> _or <span class="token operator">|</span> _sltu <span class="token operator">|</span> _sllv <span class="token operator">|</span> _srlv <span class="token operator">|</span> _andi <span class="token operator">|</span> _ori <span class="token operator">|</span> _sltiu <span class="token operator">|</span> _lui<span class="token punctuation">;</span><span class="token keyword">assign</span> ALUOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>       <span class="token operator">=</span> _srl <span class="token operator">|</span> _sub <span class="token operator">|</span> _or <span class="token operator">|</span> _nor <span class="token operator">|</span> _slt <span class="token operator">|</span> _srlv <span class="token operator">|</span> _subu <span class="token operator">|</span> _ori <span class="token operator">|</span> _slti <span class="token operator">|</span> _lui<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="重要机制实现方法">重要机制实现方法</h3><h4 id="转移指令b类和j类实现方法">转移指令（B类和J类）实现方法</h4><p>转移指令包括两种——B类和J类，这两类指令的地址转移功能均需要通过NPC的选择与计算将对应的PC地址传入PC寄存器（IFU模块中）。B类指令数量更多，转移条件的判断也更为复杂，因此我们将其封装成一个模块——BranchControl。该模块的接口定义已经给出，现在分析其内部实现逻辑。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>BranchOp<span class="token punctuation">)</span>            <span class="token constant">`BRANCH_BEQ</span><span class="token punctuation">:</span>            result <span class="token operator">=</span> equal<span class="token punctuation">;</span>            <span class="token constant">`BRANCH_BNE</span><span class="token punctuation">:</span>            result <span class="token operator">=</span> <span class="token operator">~</span>equal<span class="token punctuation">;</span>            <span class="token constant">`BRANCH_BGEZ_OR_BLEZ</span><span class="token punctuation">:</span>   result <span class="token operator">=</span> <span class="token punctuation">(</span>judge <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>cmp_data<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>cmp_data<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token constant">`BRANCH_BGTZ</span><span class="token punctuation">:</span>           result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>cmp_data<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token constant">`BRANCH_BLEZ</span><span class="token punctuation">:</span>           result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>cmp_data<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token punctuation">:</span>                result <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>据判断逻辑不同，B类指令又可以分为两类——bne，beq和bltz，blez，bgtz，bgez。bne和beq指令需要将两个操作数进行比较，根据两者的值是否相等进一步判断是否执行跳转。“Equal”接口的信号正是两个操作数的比较结果。而bltz，blez，bgtz，bgez四个指令只需要将一个操作数和0进行比较。我们将这个操作数的值直接传入该模块，然后用四个比较器分别计算这四个指令的判断结果。</p></li><li><p>6个B类指令的判断结果已经得到，下面我们要做的是根据当前指令选择出其中一个判断结果进行输出，这就需要通过“BranchOp”（B类指令选择信号）进行选择</p><table><thead><tr class="header"><th>BranchOp</th><th>对应指令</th></tr></thead><tbody><tr class="odd"><td>0b000</td><td>beq</td></tr><tr class="even"><td>0b001</td><td>bgez，bltz</td></tr><tr class="odd"><td>0b010</td><td>bgtz</td></tr><tr class="even"><td>0b011</td><td>blez</td></tr><tr class="odd"><td>0b100</td><td>bne</td></tr></tbody></table></li><li><p>由上表可以发现，当“BranchOp”的值为0b001时，对应的指令有两个——bgez和bltz。原因是根据MIPS指令集，bgez和bgtz的Opcode完全一致（000001），无法仅通过ControlUnit将这两个指令进行区分。因此，我们需要将指令的16~20位数据输入该模块（在该数据段中bgez指令的值为0b00001，bltz的值为0b00000），即“Judge”信号，将这两个指令的判断结果区分。这样分支指令的判断结果就可以得出，并传入NPC中。</p></li></ul><p>下面我们介绍NPC中B类和J类指令的执行逻辑。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span>       <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       npc_1 <span class="token operator">=</span> pc <span class="token operator">+</span> <span class="token number">32'd4</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span>       <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       npc_2 <span class="token operator">=</span> pc <span class="token operator">+</span> <span class="token number">32'd4</span> <span class="token operator">+</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span>       <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       npc_3 <span class="token operator">=</span> <span class="token operator">{</span>pc<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr_26<span class="token punctuation">,</span> <span class="token number">2'b00</span><span class="token operator">}</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span>       <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       npc_4 <span class="token operator">=</span> ra_data<span class="token punctuation">;</span>、、<span class="token keyword">assign</span> pc_plus_4 <span class="token operator">=</span> npc_1<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>NPCOp<span class="token punctuation">)</span>            <span class="token constant">`NPC_PC_PLUS_FOUR</span><span class="token punctuation">:</span>       next_pc <span class="token operator">=</span> npc_1<span class="token punctuation">;</span>            <span class="token constant">`NPC_BRANCH</span><span class="token punctuation">:</span>             next_pc <span class="token operator">=</span> <span class="token punctuation">(</span>branch_judge<span class="token punctuation">)</span> <span class="token operator">?</span> npc_2 <span class="token punctuation">:</span> npc_1<span class="token punctuation">;</span>            <span class="token constant">`NPC_INSTR_26</span><span class="token punctuation">:</span>           next_pc <span class="token operator">=</span> npc_3<span class="token punctuation">;</span>            <span class="token constant">`NPC_RA_DATA</span><span class="token punctuation">:</span>            next_pc <span class="token operator">=</span> npc_4<span class="token punctuation">;</span>             <span class="token keyword">default</span><span class="token punctuation">:</span>                next_pc <span class="token operator">=</span> next_pc<span class="token punctuation">;</span>        <span class="token keyword">endcase</span>    <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们需要先将输入的数据进行处理，转换为PC地址，包括对“Offset”（B类指令码中的地址偏移量）和“Instruction[25:0]”（j和jal指令码中储存地址的数据段）进行处理。然后通过“branch_jdudge”信号（BranchControl模块输出的结果）和“NPCOp”信号对之前得到的计算结果进行选择，最终将选择后的结果通过“next_pc”端口输出。</li><li>此外，由于jal和jalr指令中需要将PC+4的值写入到某个寄存器中，因此需要将PC+4的值计算出来通过“PC+4”接口输出。在写入过程中，控制信号“RaLink”和“AddrTrans”起到了调节数据通路的作用。</li></ul><h4 id="访存指令实现方法">访存指令实现方法</h4><p>访存指令包含8个——lw，sw，lb，lbu，lh，lhu，sb，sh，均在DM模块中实现。由于我们的程序中DM为按字地址存储，所以我们无法直接对字节和半字进行操作，需要进行位的拼接。读储存器代码如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    temp         <span class="token operator">=</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//get the whole word</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">case</span><span class="token punctuation">(</span>LSOp<span class="token punctuation">)</span>            <span class="token constant">`LS_LW</span><span class="token punctuation">:</span> read_data   <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token constant">`LS_LH</span><span class="token punctuation">:</span> read_data   <span class="token operator">=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">16</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span>                                                         <span class="token punctuation">:</span> <span class="token operator">{{</span><span class="token number">16</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>            <span class="token constant">`LS_LHU</span><span class="token punctuation">:</span> read_data  <span class="token operator">=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">16</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span>                                                         <span class="token punctuation">:</span> <span class="token operator">{{</span><span class="token number">16</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>            <span class="token constant">`LS_LB</span><span class="token punctuation">:</span> read_data   <span class="token operator">=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span>                                    <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span>                                     <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">:</span>                                                              <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>            <span class="token constant">`LS_LBU</span><span class="token punctuation">:</span> read_data  <span class="token operator">=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span>                                    <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span>                                     <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">:</span>                                                              <span class="token operator">{{</span><span class="token number">24</span><span class="token operator">{</span><span class="token number">1'b0</span><span class="token operator">}}</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>              <span class="token keyword">default</span><span class="token punctuation">:</span> read_data <span class="token operator">=</span> temp<span class="token punctuation">;</span>                         <span class="token keyword">endcase</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写储存器代码如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token function">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>                data_memory<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">32'h0</span><span class="token punctuation">;</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>MemWrite <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token function">case</span><span class="token punctuation">(</span>LSOp<span class="token punctuation">)</span>                 <span class="token constant">`LS_SW</span><span class="token punctuation">:</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> write_data<span class="token punctuation">;</span>                <span class="token constant">`LS_SH</span><span class="token punctuation">:</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token operator">?</span>  <span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> write_data<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span> <span class="token operator">{</span>write_data<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>                <span class="token constant">`LS_SB</span><span class="token punctuation">:</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> write_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span><span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> write_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span> <span class="token punctuation">:</span>                        <span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">{</span>temp<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">,</span> write_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">:</span>                                                  <span class="token operator">{</span>write_data<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token punctuation">:</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">endcase</span>        <span class="token keyword">else</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> data_memory<span class="token punctuation">[</span>addr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="测试方案">测试方案</h2><h3 id="典型测试样例">典型测试样例</h3><h4 id="运算指令测试">运算指令测试</h4><p>该部分测试通过随机数随机生成，以保证测试数据的任意性，然后与同学代码进行对拍，以确定正确性。（随机生成程序与对拍程序均由同学设计）<br>其中一组测试数据如下所示</p><p></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">li  <span class="token kernel-function property">$0</span> <span class="token operator">-</span><span class="token number">5646112</span>li  <span class="token kernel-function property">$1</span>  <span class="token number">123555</span>……………………<span class="token keyword">xor</span> <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>addu <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">nor</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>addu <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>srlv <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span>sub <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span>add <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">nor</span> <span class="token kernel-function property">$18</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span><span class="token keyword">or</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$18</span><span class="token keyword">and</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token keyword">or</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token keyword">or</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$22</span><span class="token keyword">and</span> <span class="token kernel-function property">$21</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span><span class="token keyword">or</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>sllv <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$19</span><span class="token keyword">xor</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>srlv <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token keyword">or</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token keyword">and</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span>sltu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$30</span>sllv <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>srav <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token keyword">xor</span> <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$9</span>sltu <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token keyword">and</span> <span class="token kernel-function property">$17</span><span class="token punctuation">,</span> <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token keyword">xor</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>slt <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token keyword">xor</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>srav <span class="token kernel-function property">$12</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span>sltu <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>subu <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>srav <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>add <span class="token kernel-function property">$18</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span>sltu <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span>srlv <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token keyword">or</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>sllv <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$26</span>add <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$18</span>srlv <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token keyword">or</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span>add <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token keyword">and</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$26</span>addu <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$20</span><span class="token keyword">xor</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">xor</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">and</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token keyword">nor</span> <span class="token kernel-function property">$26</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>add <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>srlv <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>add <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span>sltu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span>……………………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>#### 转移指令（B类和J类）测试<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">main<span class="token punctuation">:</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1000</span>li<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">1000</span>lui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000#s3 is  <span class="token operator">-</span><span class="token number">2147483648</span>lui<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000ori<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x0001#s4 is  <span class="token operator">-</span><span class="token number">2147483647</span>lui<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>xffff#s5 is  <span class="token number">2147483647</span>lui<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>xfffe#s6 is <span class="token number">2147483646</span>beq_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> beq_1_testbeq_2<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> beq_2_test……beq_10<span class="token punctuation">:</span>  beq<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> beq_10_testbeq_end<span class="token punctuation">:</span>bne_1<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> bne_1_test……bne_10<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> bne_10_testbne_end<span class="token punctuation">:</span>blez_1<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> blez_1_test……blez_10<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> blez_10_testblez_end<span class="token punctuation">:</span>bgtz_1<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span>bgtz_1_test……bgtz_10<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span>bgtz_10_testbgtz_end<span class="token punctuation">:</span>jal_1<span class="token punctuation">:</span>jaljal_1_test……jal_5<span class="token punctuation">:</span>jaljal_5_testjal_end<span class="token punctuation">:</span>jalr_1<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">12916</span>jalr<span class="token kernel-function property">$v1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$v0</span>……jalr_5<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">12948</span>jalr<span class="token kernel-function property">$v1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$v0</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscallbeq_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_2……beq_10_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_endbne_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_2……bne_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_end                 blez_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_2……blez_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_endbgtz_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_2……bgtz_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_endjal_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>……jal_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>jalr_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>……jalr_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="访存指令测试">访存指令测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">.</span>textli<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>xABCF1234li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">0</span>x1234ABCDli<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>xa1b2c3d4li<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fff0000sb<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">100</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">103</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">105</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">107</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">108</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">110</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">112</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">114</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">16</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">20</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">24</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">28</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">32</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">36</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">40</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">44</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">48</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">52</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">56</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">60</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">64</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">68</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">72</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">76</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">6</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">80</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">84</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">88</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">92</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动测试工具">自动测试工具</h3><p>我们通过python程序将MIPS汇编程序（test.asm）编译并运行，形成16进制机器码（code.txt）和标准输出（mips_out.txt）。然后命令行运行ise，得到工程文件的输出（verilog_out.txt）.然后我们对两个输出文件进行比较，得出比较结果。若出现不同，还会输出错误日志文件（log_i.txt）。</p><p></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> osp_road <span class="token operator">=</span> <span class="token string">"D:\\Code\\Verilog\\homework_code\\P4_cpu_test"</span>run_time <span class="token operator">=</span> <span class="token string">"200us"</span>xilinx_path <span class="token operator">=</span> <span class="token string">"E:\\Xilinx\\14.7\\ISE_DS\\ISE"</span>error <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">run_mars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar mars.jar mc CompactDataAtZero a dump .text HexText code.txt nc mips_code.asm"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"java -jar mars.jar mc CompactDataAtZero nc mips_code.asm &gt; mips_out.txt"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">load_hex_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    list_temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> hex_code<span class="token punctuation">:</span>        list_temp <span class="token operator">=</span> hex_code<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\\code.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file_to_IM<span class="token punctuation">:</span>        file_to_IM<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>    hex_code<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    file_to_IM<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_ise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    file_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token punctuation">,</span>k <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>p_road<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">file</span><span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">".v"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                file_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\\mips.prj"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> prj<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>file_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            prj<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Verilog work \""</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> file_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\"\n"</span><span class="token punctuation">)</span>               <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>p_road <span class="token operator">+</span> <span class="token string">"\mips.tcl"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tcl<span class="token punctuation">:</span>        tcl<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"run "</span> <span class="token operator">+</span> run_time <span class="token operator">+</span><span class="token string">";\nexit"</span><span class="token punctuation">)</span>    prj<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    tcl<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"XILINX"</span><span class="token punctuation">]</span> <span class="token operator">=</span> xilinx_path    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>xilinx_path <span class="token operator">+</span> <span class="token string">"\\bin\\nt64\\fuse -nodebug -prj "</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt"</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mips.exe -nolog -tclbatch "</span> <span class="token operator">+</span> p_road <span class="token operator">+</span> <span class="token string">"\\mips.tcl&gt; verilog_out.txt"</span><span class="token punctuation">)</span>    <span class="token comment"># print("mips.exe -nolog -tclbatch " + p_road + "\\mips.tcl &gt; verilog_out.txt")</span><span class="token keyword">def</span> <span class="token function">copy_file</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target_road<span class="token punctuation">)</span><span class="token punctuation">:</span>    f_1 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    list_temp <span class="token operator">=</span> f_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_2 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>target_road <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>    f_2<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>list_temp<span class="token punctuation">)</span>    f_1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">file_cmp</span><span class="token punctuation">(</span>test_order<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"mips_out.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_1<span class="token punctuation">:</span>        out_std <span class="token operator">=</span> out_1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>        out_std<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"verilog_out.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_2<span class="token punctuation">:</span>        out_test <span class="token operator">=</span> out_2<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        out_2 <span class="token operator">=</span> out_2<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">".\\log.txt"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>test_order<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> log<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>out_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>out_std<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    log<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"error in line {}\n expected output is {}\nyour outout is {}\n\n"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> out_std<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> out_test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Wrong Answer!"</span><span class="token punctuation">)</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">".\\test_log_file\\log_{}\\"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            copy_file<span class="token punctuation">(</span><span class="token string">"log.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            copy_file<span class="token punctuation">(</span><span class="token string">"mips_code.asm"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            copy_file<span class="token punctuation">(</span><span class="token string">"mips_out.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            copy_file<span class="token punctuation">(</span><span class="token string">"verilog_out.txt"</span><span class="token punctuation">,</span> <span class="token string">".\\test_log_file\\log_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Accepted!"</span><span class="token punctuation">)</span><span class="token comment">#### main</span>test_times <span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>test_times<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"python D:\大学资料\大二上\计算机组成\实验上机\P4\自动化测试\code_generate.py"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n{}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> test_times<span class="token punctuation">)</span><span class="token punctuation">)</span>    run_mars<span class="token punctuation">(</span><span class="token punctuation">)</span>    load_hex_code<span class="token punctuation">(</span><span class="token punctuation">)</span>    run_ise<span class="token punctuation">(</span><span class="token punctuation">)</span>file_cmp<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>## 思考题<br>1.Q：根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？<br><img src="p4Q1.png"><br>A：因为MIPS架构cpu的指令存储器是按字节寻址，而我们在Verilog中构建的IM是按字寻址的，而且地址尾款为10位（[0:1024]）。因此应该对pc[9:0]进行左移2位的操作，相当于取pc[11:2].addr信号是来源于pc<p></p><ol start="2" type="1"><li><p>Q：思考Verilog语言设计控制器的译码方式，给出代码示例，并尝试对比各方式的优劣。<br>A：可以记录下指令对应的控制信号如何取值，也可以记录下控制信号每种取值所对应的指令。如以下代码——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//第一种方式</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">begin</span>     <span class="token function">if</span><span class="token punctuation">(</span>_add <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">begin</span> Regwrite <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> RegDst <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>sub <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span> Regwrite <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> RegDst <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>……………… <span class="token keyword">end</span><span class="token comment">//第二种方式</span> <span class="token keyword">assign</span> MemToReg       <span class="token operator">=</span> _lw <span class="token operator">|</span> _lh <span class="token operator">|</span> _lhu <span class="token operator">|</span> _lb <span class="token operator">|</span> _lbu<span class="token punctuation">;</span> <span class="token keyword">assign</span> MemWrite       <span class="token operator">=</span> _sw <span class="token operator">|</span> _sh <span class="token operator">|</span> _sb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Q：在相应的部件中，reset的优先级比其他控制信号（不包括clk信号）都要高，且相应的设计都是同步复位。清零信号reset所驱动的部件具有什么共同特点<br>A：都具有寄存器类型，可以对数据进行存储，在运行中可读可写，如pc，DM，GRF。</p></li><li><p>Q：C语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持C语言，MIPS指令的所有计算指令均可以忽略溢出。请说明为什么在忽略溢出的前提下，addi与addiu是等价的，add与addu是等价的。提示：阅读《MIPS32®Architecture For Programmers Volume II: The MIPS32® InstructionSet》中相关指令的Operation部分 。<br>A：英文指令集中，对于ADD的解释是: ADDU performs the same arithmeticoperation but does not trap onoverflow,也就是说，add和addu仅有溢出检测的区别。在忽略溢出的条件下，无论是否溢出，二者都将计算结果存入rd中，因此二者是等价的。Addi和addiu同理。</p></li><li><p>Q：根据自己的设计说明单周期处理器的优缺点。</p><p>A：单周期的CPU会在一个时钟周期内完成所有的工作，既从指令取出，到得到结果，全部在一个时钟之内完成。优点是设计较为简单，指令与指令之间独立，缺点是cpu的时钟周期受关键路径限制，时钟周期较长，效率比较低。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P3_单周期cpu（Logisim实现）</title>
      <link href="/2021/11/01/co/co-p3-dan-zhou-qi-cpu-logisim-shi-xian/"/>
      <url>/2021/11/01/co/co-p3-dan-zhou-qi-cpu-logisim-shi-xian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单周期cpu设计方案">单周期CPU设计方案</h2><h3 id="设计概述">设计概述</h3><p> 本文所设计的CPU为Losgisim实现的单周期MIPS架构CPU，该CPU支持43条MIPS汇编指令，为了实现该功能，笔者设计了IFU，GRF，NPC，ALU，DM，ControlUnite，Branch Control，LSControl等关键模块。整个搭建过程通过自下而上的方式完成——先根据应实现的指令对功能部件进行设计与搭建，然后对各个功能部件进行连接，形成完整的数据通路。<br><img src="CPU.png"></p><h3 id="实现指令说明">实现指令说明</h3><p> 本CPU支持43条指令，包括19条R型指令，2条J型指令，22条I型指令。</p><h4 id="r型指令">R型指令</h4><ul><li>算数/位运算指令：add, addu, sub, subu, and, or, nor, xor</li><li>移位指令：sll, srl, sra, sllv, srlv, srav</li><li>置位指令：slt, sltu</li><li>跳转指令：jr, jalr</li><li>系统调用：syscall</li></ul><h4 id="j型指令">J型指令</h4><ul><li>跳转指令：j, jal</li></ul><h4 id="i型指令">I型指令</h4><ul><li>算数/位运算指令： addi, andi, addiu, ori, xori, lui</li><li>B类指令：beq, bne, bgtz, bgez, blez, bltz</li><li>置位指令：slti, sltiu</li><li>访存指令：lw, sw, lh, lhu, lb, lbu, sh, sb</li></ul><h3 id="数据通路模块定义">数据通路模块定义</h3><h4 id="ifu取指令单元">IFU（取指令单元）</h4><p> 该模块内部包含PC（程序计数器）和IM（指令存储器），PC通过Logism内置的32位寄存器实现，IM通过Logisim内置的ROM实现（容量为32*32bit）。可以根据PC的值从IM取出对应的指令，并具有异步复位的功能。<br><img src="IFU.png"></p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>Reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr class="odd"><td>Stop</td><td>I</td><td>1</td><td>停止信号</td></tr><tr class="even"><td>Next_PC</td><td>I</td><td>32</td><td>下一条要被执行的指令的地址</td></tr><tr class="odd"><td>PC</td><td>O</td><td>32</td><td>输出当前正在执行的指令的地址</td></tr><tr class="even"><td>Instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00000000</td></tr><tr class="even"><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr class="odd"><td>3</td><td>写PC寄存器</td><td>当Stop信号失效且时钟上升沿来临时，将下一条指令的地址（nextPC）写入PC寄存器</td></tr><tr class="even"><td>4</td><td>取指令</td><td>根据当前PC的值从IM（指令存储器）中读出对应的指令到Instr端口</td></tr></tbody></table></li></ul><h4 id="grf通用寄存器组">GRF（通用寄存器组）</h4><p>  该模块内部包含32个具有写使能32位寄存器，分别对应MIPS架构中$0 ~$31通用寄存器（其中0号寄存器中的值恒为0，即不具备写使能）。GRF可以实现异步复位，同时可以根据输入的5位地址（0~31）向寄存器堆存取数据，实现定向访存寄存器。<br><img src="GRF.png"></p><ul><li><p><strong>端口定义</strong></p><table><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>Reset</td><td>I</td><td>1</td><td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr class="odd"><td>A1</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD1</td></tr><tr class="even"><td>A2</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其中的数据读出到RD2</td></tr><tr class="odd"><td>A3</td><td>I</td><td>5</td><td>地址输入信号，指定32个寄存器中的一个，将其作为写入目标</td></tr><tr class="even"><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="odd"><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入失效</td></tr><tr class="even"><td>RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的32位数据</td></tr><tr class="odd"><td>RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>Reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出A1，A2地址对应的寄存器中储存的数据，将其加载到RD1和RD2</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A3地址对应的寄存器</td></tr></tbody></table></li></ul><h4 id="npc下一指令计算单元">NPC（下一指令计算单元）</h4><p> 该模块根据当前指令地址和其他控制信号（“JR”，“JUMP”等），计算出下一指令所在的地址。<br><img src="NPC.png"></p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>PC</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr class="even"><td>Offset</td><td>I</td><td>32</td><td>地址偏移量，用于计算B类指令所要跳转的地址</td></tr><tr class="odd"><td>Ins_26</td><td>I</td><td>26</td><td>当前指令数据的前26位（0~25），用于计算jal和j指令所要跳转的地址</td></tr><tr class="even"><td>Ra</td><td>I</td><td>32</td><td>储存在寄存器（$ra或是jalr指令中存储“PC+4”的寄存器）中的地址数据，用于实现jr和jalr指令</td></tr><tr class="odd"><td>If_Branch</td><td>I</td><td>1</td><td>B类指令选择信号<br>1：说明当前指令为B类指令<br>0：说明当前指令不是B类信号</td></tr><tr class="even"><td>JR</td><td>I</td><td>1</td><td>输入“JR”控制信号<br>1：说明当前指令为jr或jal<br>0：说明当前指令不是jr和jalr</td></tr><tr class="odd"><td>JUMP</td><td>I</td><td>1</td><td>输入“JUMP”控制信号<br>1：说明当前指令为j或jal<br>0：说明当前指令不是为j和jump</td></tr><tr class="even"><td>Next_PC</td><td>O</td><td>32</td><td>输出下一指令地址</td></tr><tr class="odd"><td>PC+4</td><td>O</td><td>32</td><td>输出PC+4的值，用于实现jal和jalr指令中的地址存储</td></tr></tbody></table></li></ul><p>注：关于“If_branch”，“JR”，“JUMP”端口信号的选择作用将在“”部分进一步说明</p><h4 id="alu逻辑运算单元">ALU（逻辑运算单元）</h4><p> 该模块可实现加，减，按位与，按位或等11种运算，并根据ALUOP信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断。<br><img src="ALU.png"></p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ALU_Op</td><td>I</td><td>4</td><td>ALU功能选择信号</td></tr><tr class="even"><td>Src_A</td><td>I</td><td>32</td><td>参与ALU计算的第一个值</td></tr><tr class="odd"><td>Src_B</td><td>I</td><td>32</td><td>参与ALU计算的第二个值</td></tr><tr class="even"><td>Shift</td><td>I</td><td>5</td><td>移位数输入</td></tr><tr class="odd"><td>FlowJudge</td><td>I</td><td>1</td><td>溢出判断信号<br>1：进行溢出判断<br>0：不进行溢出判断</td></tr><tr class="even"><td>Equal</td><td>O</td><td>1</td><td>相等判断信号<br>1：Src_A和Src_B相等<br>0：Src_A和Src_B不相等</td></tr><tr class="odd"><td>ALU_Result</td><td>O</td><td>32</td><td>输出ALU计算结果</td></tr><tr class="even"><td>Overflow</td><td>O</td><td>1</td><td>输出ALU计算结果的溢出情况（add，sub，addi等指令有效）<br>1：ALU计算结果溢出<br>0：ALU计算结果</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>ALU_Op</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>加</td><td>0b0000</td><td>ALU_Result = Src_A + Src_B</td></tr><tr class="even"><td>2</td><td>减</td><td>0b0001</td><td>ALU_Result = Src_A - Src_B</td></tr><tr class="odd"><td>3</td><td>按位与</td><td>0b0010</td><td>ALU_Result = Src_A &amp; Src_B</td></tr><tr class="even"><td>4</td><td>按位或</td><td>0b0011</td><td>ALU_Result = Src_A | Src_B</td></tr><tr class="odd"><td>5</td><td>按位异或</td><td>0b0100</td><td>ALU_Result = Src_A ⊕ Src_B</td></tr><tr class="even"><td>6</td><td>按位或非</td><td>0b0101</td><td>ALU_Result = ~(Src_A | Src_B)</td></tr><tr class="odd"><td>7</td><td>逻辑左移</td><td>0b0110</td><td>ALU_Result = Src_B &lt;&lt; Shift</td></tr><tr class="even"><td>8</td><td>逻辑右移</td><td>0b0111</td><td>ALU_Result = Src_B &gt;&gt; Shift</td></tr><tr class="odd"><td>9</td><td>算术右移</td><td>0b1000</td><td>ALU_Result = Src_B &gt;&gt;&gt; Shift</td></tr><tr class="even"><td>10</td><td>带符号比较</td><td>0b1001</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（带符号比较）</td></tr><tr class="odd"><td>11</td><td>无符号比较</td><td>0b1010</td><td>ALU_Result = (Src_A &gt; Src_B) ? 1 : 0（无符号比较）</td></tr></tbody></table></li></ul><h4 id="dm-数据存储器">DM （数据存储器）</h4><p> 该模块使用了Logism自带的RAM，不仅可以实现对数据的存储与访问，还通过“LS”，“LSExt”，“LSop”等控制信号对字节/半字进行操作，并具有异步复位功能。<br><img src="DM.png"></p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr class="even"><td>Reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr class="odd"><td>A</td><td>I</td><td>5</td><td>地址输入信号，指向数据储存器中某个存储单元</td></tr><tr class="even"><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr class="odd"><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入失效</td></tr><tr class="even"><td>LS</td><td>I</td><td>1</td><td>输入“LS”控制信号<br>1:说明当前指令是对字节/半字的操作<br>0:执行其他指令（包括lw和sw）</td></tr><tr class="odd"><td>LSExt</td><td>I</td><td>1</td><td>输入“LSExt”控制信号<br>1：对DM中读出的字节/半字进行符号扩展（lb,lh指令）<br>0：对DM中读出的字节/半字进行符号扩展（lbu，lhu指令）</td></tr><tr class="even"><td>LSOp</td><td>I</td><td>1</td><td>输入“LSOp”控制信号<br>1：执行半字操作指令（lh，lhu，sh）<br>0：执行字节操作指令（lb，lbu，sb）</td></tr><tr class="odd"><td>RD</td><td>O</td><td>32</td><td>输出A指定的存储单元中的32位数据</td></tr></tbody></table></li><li><p><strong>功能定义</strong></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>1</td><td>复位</td><td>Reset信号有效时，所有寄存器中储存的值均被清零</td></tr><tr class="even"><td>2</td><td>读数据</td><td>读出A地址对应的存储单元中的数据，将其加载到RD</td></tr><tr class="odd"><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td></tr></tbody></table><p>注：关于“LS”，“LSExt”，“LSop”端口信号的选择作用将在“”部分进一步说明</p></li></ul><h4 id="branch-controlb类指令控制模块">BranchControl（B类指令控制模块）</h4><p> 该模块通过接收“Branch”，“Branch_Op”等控制信号，将对转移条件进行判断，并输出判断结果。<br><img src="Branch%20Control.png"></p><ul><li><p><strong>端口定义</strong></p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>D</td><td>I</td><td>32</td><td>输入32位数据，用于和0进行比较（实现blez，bgez，bltz，bgtz）</td></tr><tr class="even"><td>Equal</td><td>I</td><td>1</td><td>相等判断信号，即ALU模块中Src_A和Src_B的比较结果（实现beq，bne）</td></tr><tr class="odd"><td>Branch</td><td>I</td><td>1</td><td>B类指令判断信号<br>1：当前执行的指令B类指令<br>0：其他指令</td></tr><tr class="even"><td>BranchOp</td><td>I</td><td>3</td><td>B类指令选择指令<br>0b000：beq指令<br>0b001：bgez，bltz<br>0b010：bgtz<br>0b011：blez<br>0b100：bne</td></tr><tr class="odd"><td>Judge</td><td>I</td><td>1</td><td>区别bgez，bltz两个指令</td></tr><tr class="even"><td>Result</td><td>O</td><td>1</td><td>输出判断结果<br>1：B类指令转移条件成立<br>0：B类指令转移条件不成立</td></tr></tbody></table><p>注：关于“Branch”，“BranchOp”端口信号的选择作用将在“”部分进一步说明</p></li></ul><h3 id="控制模块定义">控制模块定义</h3><p> 在控制模块中，我们对指令中Opcode域和Funct域中的数据进行解码，输出ALUOp,MemtoReg等19条控制指令，从而对数据通路进行调整，满足不同指令的需求。为实现该模块，我们又在内部设计了两个子模块——和逻辑（ANDLogic）和或逻辑（ORLogic）。前者的功能是识别，将输入的Opcode和Funct数据识别为对应的指令，后者的功能是生成，根据输入指令的不同产生不同的控制信号。<br><img src="Control%20Unit.png"></p><ul><li><p><strong>控制信号定义</strong></p><table><colgroup><col style="width: 10%"><col style="width: 17%"><col style="width: 10%"><col style="width: 14%"><col style="width: 46%"></colgroup><thead><tr class="header"><th>序号</th><th>信号名</th><th>位宽</th><th>描述</th><th>触发指令（信号为1）</th></tr></thead><tbody><tr class="odd"><td>1</td><td>MemToReg</td><td>1</td><td>GRF中WD接口输入数据选择</td><td>lw, lb, lbu, lh, lhu</td></tr><tr class="even"><td>2</td><td>MemWrite</td><td>1</td><td>DM写入使能信号</td><td>sw, sb, sh</td></tr><tr class="odd"><td>3</td><td>ALUSrc</td><td>1</td><td>ALU中Src_B接口输入数据选择</td><td>addi, andi, addiu, slti, ori, lw, sw, sltiu, xori, lb, lbu, lh, lhu,sb, sh, lui</td></tr><tr class="even"><td>4</td><td>RegWrite</td><td>1</td><td>GRF写入使能信号</td><td>sll, sra, srl, add, addu, sub, and, or, nor, slt, sltu, jalr, xor,sllv, srav, srlv, subu, jal, addi, andi, addiu, slti, ori, lw, sltiu,xori, lb, lbu, lh, lhu, lui</td></tr><tr class="odd"><td>5</td><td>SYSCALL</td><td>1</td><td>syscall指令译码信号，GRF中A1接口输入数据选择</td><td>syscall</td></tr><tr class="even"><td>6</td><td>SignedExt</td><td>1</td><td>立即数符号扩展选择</td><td>addi, addiu, slti, sltiu, lw, sw, lb, lbu, lh, lhu, sb, sh</td></tr><tr class="odd"><td>7</td><td>RegDst</td><td>1</td><td>GRF中A3接口输入数据选择</td><td>sll, sra, srl, add, addu, sub, and, or, nor, slt, sltu, jalr, xor,sllv, srav, srlv, subu</td></tr><tr class="even"><td>8</td><td>Branch</td><td>1</td><td>B类指令判断信号</td><td>beq, bne, bgez, bgtz, blez, bltz</td></tr><tr class="odd"><td>9</td><td>BranchOp</td><td>3</td><td>B类指令选择信号</td><td>见Branch模块</td></tr><tr class="even"><td>10</td><td>JR</td><td>1</td><td>J类指令选择信号</td><td>jalr, jr</td></tr><tr class="odd"><td>11</td><td>JUMP</td><td>1</td><td>J类指令判断信号</td><td>jalr, jr, j, jal</td></tr><tr class="even"><td>12</td><td>AddrTrans</td><td>1</td><td>指令地址传递信号，选择是否将PC+4输入到GRF的WD端口</td><td>jal, jalr</td></tr><tr class="odd"><td>13</td><td>RaLink</td><td>1</td><td>$ra寄存器写入选择信号，选择是否将$ra作为GRF的写入对象</td><td>jal</td></tr><tr class="even"><td>14</td><td>VarShift</td><td>1</td><td>可变移位选择信号，选择是否将指令rs域的五位数据写入ALU的Shift接口</td><td>srav, srlv, sllv</td></tr><tr class="odd"><td>15</td><td>FlowJudge</td><td>1</td><td>溢出判断选择信号</td><td>add, sub, addi</td></tr><tr class="even"><td>16</td><td>LS</td><td>1</td><td>字节/半字操作选择信号</td><td>lb, lbu, lh, lhu, sb, sh</td></tr><tr class="odd"><td>17</td><td>LSExt</td><td>1</td><td>字节/半字符号扩展选择信号</td><td>lb, lh</td></tr><tr class="even"><td>18</td><td>LSOp</td><td>1</td><td>字节/半字类访存指令选择信号</td><td>lh, lhu, sh</td></tr><tr class="odd"><td>19</td><td>LUI</td><td>1</td><td>lui指令译码信号，选择是否将16写入ALU的Shift接口</td><td>lui</td></tr><tr class="even"><td>20</td><td>ALUOp</td><td>4</td><td>ALU功能选择信号</td><td>见ALU模块</td></tr></tbody></table></li></ul><h3 id="重要机制实现方法">重要机制实现方法</h3><h4 id="转移指令b类和j类实现方法">转移指令（B类和J类）实现方法</h4><p> 转移指令包括两种——B类和J类，这两类指令的地址转移功能均需要通过NPC的选择与计算将对应的PC地址传入PC寄存器（IFU模块中）。B类指令数量更多，转移条件的判断也更为复杂，因此我们将其封装成一个模块——BranchControl。该模块的接口定义已经给出，现在分析其内部实现逻辑。<br><img src="Branch%20Control内部实现.png"></p><ul><li>根据判断逻辑不同，B类指令又可以分为两类——bne，beq和bltz，blez，bgtz，bgez。bne和beq指令需要将两个操作数进行比较，根据两者的值是否相等进一步判断是否执行跳转。“Equal”接口的信号正是两个操作数的比较结果。而bltz，blez，bgtz，bgez四个指令只需要将一个操作数和0进行比较。我们将这个操作数的值直接传入该模块，然后用四个比较器分别计算这四个指令的判断结果。</li><li>6个B类指令的判断结果已经得到，下面我们要做的是根据当前指令选择出其中一个判断结果进行输出，这就需要通过“BranchOp”（B类指令选择信号）进行选择——</li></ul><table><thead><tr class="header"><th>BranchOp</th><th>对应指令</th></tr></thead><tbody><tr class="odd"><td>0b000</td><td>beq</td></tr><tr class="even"><td>0b001</td><td>bgez，bltz</td></tr><tr class="odd"><td>0b010</td><td>bgtz</td></tr><tr class="even"><td>0b011</td><td>blez</td></tr><tr class="odd"><td>0b100</td><td>bne</td></tr></tbody></table><ul><li>由上表可以发现，当“BranchOp”的值为0b001时，对应的指令有两个——bgez和bltz。原因是根据MIPS指令集，bgez和bgtz的Opcode完全一致（000001），无法仅通过ControlUnit将这两个指令进行区分。因此，我们需要将指令的16~20位数据输入该模块（在该数据段中bgez指令的值为0b00001，bltz的值为0b00000），即“Judge”信号，将这两个指令的判断结果区分。</li><li>虽然得到了初步判断结果，但是仍然无法确定是否进行地址转移。因为即使当前指令是非B类指令，ALU和该模块中的判断操作仍会进行，但这不是我们想要的结果。因此我们将得到的初步判断结果和Branch（B类指令判断信号）进行与运算，就得到最终的判断结果并传入NPC中（若为1，则说明应该执行跳转）。</li></ul><p>下面我们介绍NPC中B类和J类指令的执行逻辑。<br><img src="NPC内部实现.png"></p><ul><li>我们需要先将输入的数据进行处理，转换为PC地址，包括对“Offset”（B类指令码中的地址偏移量）和“Instruction[25:0]”（j和jal指令码中储存地址的数据段）进行处理。然后通过“If_branch”信号（BranchControl模块输出的结果），“JR”信号，“JUMP”信号对之前得到的计算结果进行选择，最终将选择后的结果通过“Next_PC”端口输出。</li><li>此外，由于jal和jalr指令中需要将PC+4的值写入到某个寄存器中，因此需要将PC+4的值计算出来通过“PC+4”接口输出。<br>在写入过程中，控制信号“RaLink”和“AddrTrans”起到了调节数据通路的作用。</li></ul><h4 id="访存指令实现方法">访存指令实现方法</h4><p>访存指令包含8个——lw，sw，lb，lbu，lh，lhu，sb，sh，均在DM模块中实现。由于Logisim自带的RAM功能上的限制，我们无法直接对字节和半字进行操作。为实现对字节和半字的访存，笔者在DM中单独设计了一个模块——“LSControl”。该模块可以接收RAM中的数据，并对其进行处理，以便实现对字节和半字的操作。</p><p><img src="DM内部.png"><br>LS Control内部实现逻辑如下</p><p><img src="LS%20Control内部.png"></p><ul><li>当前指令为lw或sw时，“LS”信号值为1，直接进行写入和访问即可。</li><li>当前指令为lb，lbu，lh，lhu时，我们首先将需要访问的字节/半字所在的整个字从RAM取出（RAM地址为“A”信号的2~6位），传入LSControl中，根据“A”中的地址数据取出字节/半字。然后跟据“LSEXT”的值对取出的字节/半字进行符号扩展或者零扩展（lb和lh需要进行符号扩展，lbu和lhu需要进行0扩展）。而”LSOp“的作用是用来判断当前处理的对象是字节还是半字，最终将选择出的值加载到LD端口，返回到DM模块中。</li><li>当前指令为sb或sh时，我们还需要将写入的数据传入LSControl中，将其中的字节/半字取出，加载进从RAM中读出的字中。该操作仍然需要通过”LSOp“判断当前处理的对象是字节还是半字，最终将选择出的值加载到SD端口，返回到DM模块中。</li></ul><h2 id="测试方案">测试方案</h2><h3 id="典型测试样例">典型测试样例</h3><h4 id="运算指令测试">运算指令测试</h4><p>该部分测试通过随机数随机生成，以保证测试数据的任意性，然后与同学代码进行对拍，以确定正确性。（随机生成程序与对拍程序均由同学设计）<br>其中一组测试数据如下所示<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">  <span class="token punctuation">.</span>dataa0<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1312790913</span>a1<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">735115427</span>a2<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">879199915</span>a3<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1512039151</span>a4<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">2013377222</span>a5<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1905462880</span>a6<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1727785544</span>a7<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">495505030</span>a8<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">908018362</span>a9<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">872011691</span>a10<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">688762757</span>a11<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">584970043</span>a12<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">771638002</span>a13<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1758026820</span>a14<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1511157661</span>a15<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1960163833</span>a16<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">544909545</span>a17<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">927301894</span>a18<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1007746847</span>a19<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1635999615</span>a20<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">873288396</span>a21<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">185826422</span>a22<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">804499640</span>a23<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1264829813</span>a24<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1861578073</span>a25<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1064488967</span>a26<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">1910898200</span>a27<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">2116088717</span>a28<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">300923572</span>a29<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">2026048648</span>a30<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token number">130284251</span>a31<span class="token punctuation">:</span>   <span class="token punctuation">.</span>word  <span class="token operator">-</span><span class="token number">1794474076</span><span class="token punctuation">.</span>textli <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> a0li <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> a1li <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> a2li <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> a3li <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> a4lw <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> a5lw <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> a6lw <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> a7lw <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> a8lw <span class="token kernel-function property">$9</span><span class="token punctuation">,</span> a9lw <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> a10lw <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> a11lw <span class="token kernel-function property">$12</span><span class="token punctuation">,</span> a12lw <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> a13lw <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> a14lw <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> a15lw <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> a16lw <span class="token kernel-function property">$17</span><span class="token punctuation">,</span> a17lw <span class="token kernel-function property">$18</span><span class="token punctuation">,</span> a18lw <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> a19lw <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> a20lw <span class="token kernel-function property">$21</span><span class="token punctuation">,</span> a21lw <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> a22lw <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> a23lw <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> a24lw <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> a25lw <span class="token kernel-function property">$26</span><span class="token punctuation">,</span> a26lw <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> a27lw <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> a28lw <span class="token kernel-function property">$29</span><span class="token punctuation">,</span> a29lw <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> a30lw <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> a31<span class="token keyword">xor</span> <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span>addu <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">nor</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>addu <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>srlv <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span>sub <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span>add <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token keyword">nor</span> <span class="token kernel-function property">$18</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span><span class="token keyword">or</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$18</span><span class="token keyword">and</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token keyword">or</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token keyword">or</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$22</span><span class="token keyword">and</span> <span class="token kernel-function property">$21</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span><span class="token keyword">or</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>sllv <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$19</span><span class="token keyword">xor</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span>srlv <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$1</span><span class="token keyword">or</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token keyword">and</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span>sltu <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$14</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$30</span>sllv <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>srav <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token keyword">xor</span> <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$9</span>sltu <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$8</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token keyword">and</span> <span class="token kernel-function property">$17</span><span class="token punctuation">,</span> <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token keyword">xor</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>slt <span class="token kernel-function property">$20</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$17</span><span class="token keyword">xor</span> <span class="token kernel-function property">$7</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>srav <span class="token kernel-function property">$12</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span>addu <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span>sltu <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>subu <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$21</span>srav <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>add <span class="token kernel-function property">$18</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span>sltu <span class="token kernel-function property">$22</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span>srlv <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token keyword">or</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$6</span>sllv <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$26</span>add <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$18</span>srlv <span class="token kernel-function property">$15</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token keyword">or</span> <span class="token kernel-function property">$25</span><span class="token punctuation">,</span> <span class="token kernel-function property">$10</span><span class="token punctuation">,</span> <span class="token kernel-function property">$31</span>add <span class="token kernel-function property">$2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$13</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span><span class="token keyword">and</span> <span class="token kernel-function property">$1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$24</span><span class="token punctuation">,</span> <span class="token kernel-function property">$26</span>addu <span class="token kernel-function property">$19</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$20</span><span class="token keyword">xor</span> <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">xor</span> <span class="token kernel-function property">$14</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token keyword">and</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$16</span><span class="token punctuation">,</span> <span class="token kernel-function property">$25</span><span class="token keyword">nor</span> <span class="token kernel-function property">$26</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span>add <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$29</span>srlv <span class="token kernel-function property">$30</span><span class="token punctuation">,</span> <span class="token kernel-function property">$3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$2</span>add <span class="token kernel-function property">$11</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$27</span>sltu <span class="token kernel-function property">$6</span><span class="token punctuation">,</span> <span class="token kernel-function property">$28</span><span class="token punctuation">,</span> <span class="token kernel-function property">$23</span>………………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="转移指令b类和j类测试">转移指令（B类和J类）测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">main<span class="token punctuation">:</span>li<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1000</span>li<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">1000</span>lui<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000#s3 is  <span class="token operator">-</span><span class="token number">2147483648</span>lui<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x8000ori<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token number">0</span>x0001#s4 is  <span class="token operator">-</span><span class="token number">2147483647</span>lui<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token number">0</span>xffff#s5 is  <span class="token number">2147483647</span>lui<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fffori<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> <span class="token number">0</span>xfffe#s6 is <span class="token number">2147483646</span>beq_1<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> beq_1_testbeq_2<span class="token punctuation">:</span>beq<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> beq_2_test……beq_10<span class="token punctuation">:</span>  beq<span class="token kernel-function property">$s5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> beq_10_testbeq_end<span class="token punctuation">:</span>bne_1<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> bne_1_test……bne_10<span class="token punctuation">:</span>bne<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> bne_10_testbne_end<span class="token punctuation">:</span>blez_1<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> blez_1_test……blez_10<span class="token punctuation">:</span> blez<span class="token kernel-function property">$s6</span><span class="token punctuation">,</span> blez_10_testblez_end<span class="token punctuation">:</span>bgtz_1<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span>bgtz_1_test……bgtz_10<span class="token punctuation">:</span> bgtz<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span>bgtz_10_testbgtz_end<span class="token punctuation">:</span>jal_1<span class="token punctuation">:</span>jaljal_1_test……jal_5<span class="token punctuation">:</span>jaljal_5_testjal_end<span class="token punctuation">:</span>jalr_1<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">12916</span>jalr<span class="token kernel-function property">$v1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$v0</span>……jalr_5<span class="token punctuation">:</span><span class="token keyword">or</span><span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">12948</span>jalr<span class="token kernel-function property">$v1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$v0</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$s0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscallbeq_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_2……beq_10_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span><span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbeq_endbne_1_test<span class="token punctuation">:</span> addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_2……bne_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span><span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token number">1</span>   jbne_end                 blez_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_2……blez_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span><span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token number">1</span>jblez_endbgtz_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_2……bgtz_10_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span><span class="token kernel-function property">$t3</span> <span class="token number">1</span>jbgtz_endjal_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>……jal_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t4</span><span class="token punctuation">,</span> <span class="token kernel-function property">$4</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$ra</span>jalr_1_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span>……jalr_5_test<span class="token punctuation">:</span>addi<span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token kernel-function property">$t5</span><span class="token punctuation">,</span> <span class="token number">1</span>jr<span class="token kernel-function property">$v1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访存指令测试">访存指令测试</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">.</span>textli<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token number">0</span>xABCF1234li<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token number">0</span>x1234ABCDli<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token number">0</span>xa1b2c3d4li<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token number">0</span>x7fff0000sb<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">100</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">103</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">105</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sb<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">107</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s4</span><span class="token punctuation">,</span> <span class="token function">108</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">110</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">112</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sh<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">114</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">0</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">16</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">20</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">24</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">28</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lb<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">32</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">36</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">40</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">44</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">3</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">7</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">11</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lbu<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">13</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">48</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">52</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">56</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">60</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">4</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lh<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">64</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">68</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">72</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">76</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">2</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">6</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>lhu<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">12</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token function">80</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token function">84</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t2</span><span class="token punctuation">,</span> <span class="token function">88</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>sw<span class="token kernel-function property">$t3</span><span class="token punctuation">,</span> <span class="token function">92</span><span class="token punctuation">(</span><span class="token kernel-function property">$0</span><span class="token punctuation">)</span>li<span class="token kernel-function property">$v0</span><span class="token punctuation">,</span> <span class="token number">10</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动测试工具">自动测试工具</h3><p> 我们通过python程序将MIPS汇编程序（test.asm）转化为16进制指令码（rom.txt），并自动加载进存有单周期cpu电路文件（cpu.cric）中的ROM元件中，并形成新的电路文件（cpu_remake.cric）。</p><p></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> re<span class="token comment">#generate ROM-File</span>command<span class="token operator">=</span><span class="token string">"java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText rom.txt"</span> os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>command<span class="token punctuation">)</span>content <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"rom.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#write ROM-File to Circle—File</span>cur <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"cpu.circ"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>cur <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r'addr/data: 5 32([\s\S]*)&lt;/a&gt;'</span><span class="token punctuation">,</span><span class="token string">"addr/data: 5 32\n"</span> <span class="token operator">+</span> content <span class="token operator">+</span> <span class="token string">"&lt;/a&gt;"</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"cpu_remake.circ"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span><span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="思考题">思考题</h2><ol type="1"><li>Q：现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。<br>A：合理。ROM是只读存储器，是非易失的，因此可以用来储存指令；RAM既可以读也可以写，因此满足DM对读写的要求；GRF是寄存器堆，需要较高的读写速度，因此适合用寄存器实现。</li><li>Q：事实上，实现 nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由。<br>A：nop指令码为0x00000000，相当于<code>sll $0, $0, 0</code>,相当于把$0寄存器中的值左移0位并写入$0寄存器，因为$0的值始终为0，不会被修改，因此该指令执行后没有任何影响。即使cpu没有设置sll指令，nop指令也不会对电路中任何元件进行操作，对电路没有任何影响。</li><li>Q：上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0的机器码。实际上，可以通过为 DM增添片选信号，来避免手工修改的麻烦，请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。<br>A：我们在导入时将MARS导出模式设置TestAtZero，此时text的首地址为0，data在0x3000。我们可以设置一个片选信号，检测输入的地址的高4位，如果是0b0011，则说明是data中的数据，然后再导入到DM中。</li><li>Q：除了编写程序进行测试外，还有一种验证 CPU设计正确性的办法——形式验证。形式验证的含义是根据某个或某些形式规范或属性，使用数学的方法证明其正确性或非正确性。请搜索“形式验证（FormalVerification)”了解相关内容后，简要阐述相比于测试，形式验证的优劣之处。<br>A：相比于传统测试，形式验证是采用数学方法将待验证电路和功能描述或参考实际直接进行比较，可以实现对所有情况进行验证，而且验证时间短，不仅能够缩短设计周期，而且能够达到完全的功能覆盖率。不像传统测试那样费时费力，而且正确率无法保证。然而，形式验证目前不能有效的验证电路的性能，如电路的时间延迟和功耗。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P2_MIPS汇编程序设计</title>
      <link href="/2021/10/30/co/co-p2-mips-hui-bian-cheng-xu-she-ji/"/>
      <url>/2021/10/30/co/co-p2-mips-hui-bian-cheng-xu-she-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mips架构risc">MIPS架构（RISC）</h2><h3 id="cpu执行程序的过程">CPU执行程序的过程</h3><ul><li>读取指令</li><li>分析指令</li><li>执行指令</li></ul><h3 id="risc的设计思想">RISC的设计思想：</h3><p>CPU越简单则性能越高，即目标为减少指令数量， 去除复杂指令</p><ul><li>加速大概率事件</li><li>简单意味着更容易设计、电路频率更高</li><li>简单功能由硬件实现；复杂功能（由大量小功能组成）交给软件处理（复杂功能是小概率的）</li></ul><h3 id="risc的设计策略">RISC的设计策略</h3><ul><li>指令定长：所有指令都占用32位（1个字）<br>降低了从存储器中读取指令的复杂度</li><li>简化指令寻址模式：以基地址+偏移为主<br>降低了从主存中读取操作数的复杂度</li><li>ISA的指令不仅数量少，而且简单<br>降低了指令执行的复杂度</li><li>只有load与store两类指令能够访存<br>例如，不允许寄存器+存储器或存储器+存储器</li><li>把复杂留给编译<br>编译器将高层语言复杂语句转换为若干简单的汇编指令</li></ul><h2 id="mips的寄存器">MIPS的寄存器</h2><p>MIPS共有32个一般寄存器（标号为$0 ~$31),不区别正负。还有pc、hi、lo等特殊寄存器</p><table><thead><tr class="header"><th>寄存器名</th><th>序号</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>$zero</td><td>0</td><td>储存常量0，不支持修改</td></tr><tr class="even"><td>$v0 ~ $v1</td><td>2~3</td><td>函数返回值</td></tr><tr class="odd"><td>$a0 ~ $a3</td><td>4~7</td><td>函数参数</td></tr><tr class="even"><td>$t0 ~ $t9</td><td>8~15, 24~25</td><td>临时变量</td></tr><tr class="odd"><td>$s0 ~ $s7</td><td>16~23</td><td>程序员变量（全局变量）</td></tr><tr class="even"><td>$k0 ~ $k1</td><td>26~27</td><td>操作系统使用</td></tr><tr class="odd"><td>$gp</td><td>28</td><td>在生成复杂的存储布局时使用（属于编译范畴）</td></tr><tr class="even"><td>$sp</td><td>29</td><td>栈顶指针</td></tr><tr class="odd"><td>$fp</td><td>30</td><td>在生成复杂的存储布局时使用（属于编译范畴）</td></tr><tr class="even"><td>$ra</td><td>31</td><td>函数返回值</td></tr><tr class="odd"><td>pc</td><td>无</td><td>程序计数器（冯诺依曼计算机）</td></tr><tr class="even"><td>hi</td><td>无</td><td>储存乘法运算结果的高32位和除法运算的余数</td></tr><tr class="odd"><td>lo</td><td>无</td><td>储存乘法运算结果的低32位和除法运算的商</td></tr></tbody></table><h2 id="mips中主存地址的表示和主存数据的存储">MIPS中主存地址的表示和主存数据的存储</h2><h3 id="地址表示方式">地址表示方式：</h3><ul><li>绝对地址<br>主存单元的地址直接用具体的数值来表示</li><li>相对地址<br>采用“基地址+偏移”的方式，优点如下<ul><li>一致性：与数据结构的访问方式高度一致</li><li>统一性：可以用某个固定base与不同的offset计算得到任意地址</li><li>灵活性：不同的{base,offset}组合可以对应同一个地址，为软件编程带来很大的灵活性</li></ul></li></ul><h3 id="指令存储方式">指令存储方式：</h3><ul><li>大端存储：最高有效字节在字内的最低地址</li><li>小端存储：最高有效字节在字内的最高地址</li></ul><h2 id="mips的指令集按功能分类">MIPS的指令集（按功能分类）</h2><h3 id="加载指令">加载指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">lb<span class="token punctuation">,</span> lbu<span class="token punctuation">,</span> lh<span class="token punctuation">,</span> lhu<span class="token punctuation">,</span> lw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="保存指令">保存指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">sb<span class="token punctuation">,</span> sh<span class="token punctuation">,</span> sw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="r-r运算指令">R-R运算指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">add<span class="token punctuation">,</span> addu<span class="token punctuation">,</span> sub<span class="token punctuation">,</span> subu<span class="token punctuation">,</span> mult<span class="token punctuation">,</span> multu<span class="token punctuation">,</span> div<span class="token punctuation">,</span> divuslt<span class="token punctuation">,</span> sltusll<span class="token punctuation">,</span> srl<span class="token punctuation">,</span> sra<span class="token punctuation">,</span> sllv<span class="token punctuation">,</span> srlv<span class="token punctuation">,</span> srav and<span class="token punctuation">,</span> or<span class="token punctuation">,</span> xor<span class="token punctuation">,</span> nor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="r-i运算指令">R-I运算指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">addi<span class="token punctuation">,</span> addiu<span class="token punctuation">,</span> andi<span class="token punctuation">,</span> ori<span class="token punctuation">,</span> xori<span class="token punctuation">,</span> luislti<span class="token punctuation">,</span> sltiu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="分支指令">分支指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">beq<span class="token punctuation">,</span> bne<span class="token punctuation">,</span> blez<span class="token punctuation">,</span> bltz<span class="token punctuation">,</span> bgez<span class="token punctuation">,</span> bgtz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跳转指令">跳转指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">j<span class="token punctuation">,</span> jal<span class="token punctuation">,</span> jr<span class="token punctuation">,</span> jalr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="传输指令">传输指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">mfhi<span class="token punctuation">,</span> mflo<span class="token punctuation">,</span> mthi<span class="token punctuation">,</span> mflo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="特权指令">特权指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">eret</span><span class="token punctuation">(</span>异常返回<span class="token punctuation">)</span>， <span class="token function">mfc0</span><span class="token punctuation">(</span>读CP0寄存器<span class="token punctuation">)</span>， <span class="token function">mtc0</span><span class="token punctuation">(</span>写CP0寄存器<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="陷阱指令">陷阱指令</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">break</span><span class="token punctuation">(</span>断点异常<span class="token punctuation">)</span>， <span class="token function">syscall</span><span class="token punctuation">(</span>系统调用异常<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="tips1-mips指令判断溢出的方法">tips1: MIPS指令判断溢出的方法</h3><ul><li>以add指令为例：<br><img src="add判断溢出.png"></li></ul><h3 id="tips2-lo和hi寄存器中保存的值">tips2: LO和HI寄存器中保存的值</h3><ul><li>在乘法指令中， LO保存运算结果的低32位，HI保存运算结果的高32位；</li><li>在除法指令中， LO保存商，HI保存余数；</li></ul><h3 id="tips3-mips指令中u的含义">tips3: MIPS指令中“u”的含义</h3><p>signed 和 unsigned 有三种不同的含义</p><ul><li>符号位扩展<ul><li>lb, lh 符号扩展</li><li>lbu, lhu 零扩展</li></ul></li><li>溢出检测<ul><li>add, addi, sub, mult, div 检测溢出</li><li>addu, addiu, subu, multu, divu 不检测溢出</li></ul></li><li>比较对象的符号性<ul><li>slt, slti 和符号数比较</li><li>sltu, sltiu 和无符号数比较</li></ul></li></ul><h3 id="伪指令">伪指令</h3><ul><li>为了使程序更可读更易编写，MIPS定义了一组伪指令，例如常用的<code>move</code>,<code>la</code>,<code>li</code>等等。</li><li>伪指令并不是真正的指令， 在汇编时汇编器会将其转化为实际指令<br>例如<code>move dst, src</code>会被转化为<code>addi dst, src, 0</code></li><li>伪指令通常会转化为多条真实指令，因此这组真实指令之间必须通过某个寄存器（<code>$at</code>）来传递信息。因此<code>$at</code>为汇编器专属寄存器，不能被程序员修改（约定）。</li></ul><h2 id="mips中函数的实现">MIPS中函数的实现</h2><h3 id="函数实现的步骤">函数实现的步骤</h3><ul><li>调用者把参数放置在某个地方以便函数能访问（<code>$a0</code>,<code>$a1</code>, <code>$a2</code>, <code>$a3</code>）</li><li>调用者转移控制给被调用的函数(<code>jal</code>指令)</li><li>函数获取局部变量对应的空间(通过桟操作)</li><li>函数执行具体功能</li><li>函数把返回值放置在某个地方，然后恢复使用的资源(<code>v0</code>,<code>v1</code>)</li><li>返回控制给调用者(<code>jr</code>指令)</li></ul><h3 id="函数相关的寄存器">函数相关的寄存器</h3><ul><li>$a0 ~ $a3：4个传递参数的寄存器</li><li>$v0 ~ $v1：2个传递返回值的寄存器</li><li>$ra：返回地址寄存器，保存着调用者的地址用到的寄存器</li></ul><h3 id="保存和恢复寄存器">保存和恢复寄存器</h3><ul><li>因为寄存器数量较少，因此需要桟将寄存器中的数据保存在内存中，防止调用函数的过程中某些需要保存的值被覆盖。此时我们需要对保存栈顶地址的寄存器<code>$sp</code>进行操作：<strong>申请桟帧-&gt;储存寄存器的值-&gt;调用函数-&gt;将桟中的值返回寄存器-&gt;释放桟帧</strong><br><img src="桟操作示例.png"></li><li>根据寄存器受保护的程度,可以将寄存器分为<strong>强保护</strong>和<strong>弱保护</strong><br><img src="寄存器保护分析.png"><br>注意，强保护寄存器为<strong>被调用者</strong>保存（进入函数时保存，退出函数前恢复）；弱保护寄存器由<strong>调用者</strong>保存（调用子函数前保存，子函数返回后恢复）。</li></ul><h2 id="mips指令格式">MIPS指令格式</h2><p>MIPS指令的32位被划分为若干个域，代表特定含义，每一个域在不同指令的含义大体是相同的。<br>### R型指令<br><strong>域的分块</strong><br><img src="R型分块.png"><br><strong>域的命名</strong><br><img src="R型.png"></p><table><thead><tr class="header"><th>域名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>opcode</td><td>代表指令的操作，R型指令的opcode固定为0b000000</td></tr><tr class="even"><td>funct</td><td>与opcode指令配合，精确定义指令的具体操作，主要用于服务R型指令</td></tr><tr class="odd"><td>rs</td><td>指定第一个操作数（source寄存器）</td></tr><tr class="even"><td>rt</td><td>指定第二个操作数（target寄存器）</td></tr><tr class="odd"><td>rd</td><td>指定结果回写的寄存器（destination寄存器）</td></tr><tr class="even"><td>shamt</td><td>移位指令（sll， sra， srl）中的移位位数，其他指令中该域固定为0</td></tr></tbody></table><p><strong>注意</strong>：<br>- <code>nop</code>是一条特殊指令（0x00000000），对应的指令为<code>sll $0, $0, 0</code>,主要用于解决流水线冲突。</p><h3 id="i型指令">I型指令</h3><p><strong>域的分块</strong><br><img src="I型分块.png"><br><strong>域的命名</strong><br><img src="I型命名.png"></p><table><thead><tr class="header"><th>域名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>opcode</td><td>代表指令的操作， I型中opcode为非零编码，一共可以编码64条指令</td></tr><tr class="even"><td>rs</td><td>指定第一个操作数（source操作数）</td></tr><tr class="odd"><td>rt</td><td>指定第二个操作数（target操作数）</td></tr><tr class="even"><td>immediate</td><td>表示16位立即数</td></tr></tbody></table><p><strong>注意</strong>：</p><ul><li>立即数（immediate）分为<strong>有符号立即数</strong>和<strong>无符号立即数</strong><ul><li>无符号立即数的指令包括：<strong>位运算</strong>指令(and, or,nor等)和<strong>小于置位</strong>指令（slti等）<br><strong>zero_ext()</strong>：运算前需要进行无符号扩展</li><li>有符号立即数的指令包括：<strong>分支</strong>指令（如beq，bne等），<strong>访存</strong>指令（lw， sw等）<br><strong>sign_ext()</strong>：运算前需要进行符号扩展</li></ul></li><li>如何计算32位立即数？<ul><li>解决方案：<strong>结合使用lui和ori两个指令</strong></li><li>例如伪指令<code>addi $t0, $t0, 0xABABCDCD</code>可以转化为以下三条指令<br><pre class="line-numbers language-c" data-language="c"><code class="language-c">lui $at<span class="token punctuation">,</span><span class="token number">0xABAB</span> # 高<span class="token number">16</span>位ori $at<span class="token punctuation">,</span>$at<span class="token punctuation">,</span><span class="token number">0xCDCD</span> # 低<span class="token number">16</span>位add $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span>$at # 赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li>关于跳转指令（B类指令）的跳转范围<ul><li>指令都是32位长，且指令是字对齐，这意味着最低2位恒为0。因此immediate没有必要记录最低2位，乘以4后就得到了对应字节地址！immediate为16位符号数，其表示范围是正负±<span class="math inline">\(2^15\)</span></li><li>如果跳转的目的地址超过了<span class="math inline">\(2^15\)</span>条指令可以将<code>beq $s0, $0, far</code>改写为<br><pre class="line-numbers language-c" data-language="c"><code class="language-c">bne $s0<span class="token punctuation">,</span> $<span class="token number">0</span><span class="token punctuation">,</span> nextj farnext<span class="token operator">:</span> #next instruction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="j型指令">J型指令</h3><p><strong>域的分块和命名</strong><br><img src="J型.png"><br><strong>PC地址的计算方法</strong><br><img src="PC的计算.png"><br>由于PC的值始终是4的倍数，因此最后两位都是零，没有必要存储；PC的高四位来自当前指令的高四位，意味着目的地址与当前指令必在同一区段<strong>{X000_0000，XFFF_FFFF}</strong>,因此<code>j</code>指令的跳转范围是<strong>256MB</strong>，只有jr指令（R型）才可以跳转到<strong>4GB</strong>内的任意地址。</p><h3 id="指令格式总结">指令格式总结</h3><ul><li>三类指令格式对比<br><img src="指令格式总结.png"></li><li>B类指令(<strong>I型</strong>)使用<strong>PC相对寻址</strong>，J指令(<strong>J型</strong>)使用<strong>绝对地址寻址</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog中符号数的使用</title>
      <link href="/2021/10/26/co/co-p1-verilog-zhong-fu-hao-shu-de-shi-yong/"/>
      <url>/2021/10/26/co/co-p1-verilog-zhong-fu-hao-shu-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算数右移符号">算数右移符号<code>&gt;&gt;&gt;</code></h2><p>我们都知道，逻辑左移符号是<code>&gt;&gt;</code>(即最高位补零)，算数右移符号是<code>&gt;&gt;&gt;</code>(即最高位补符号位，但是以下例子是错误的)<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">3'b011</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右操作数无符号</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">3</span>'sb011<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右操作数有符号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>第一、二个例子中，尽管使用了<code>&gt;&gt;&gt;</code>符号，但是<code>A</code>默认是无符号数，因此最终Verilog会默认在A的前面补上0。<br>第三个例子中，尽管<code>3'sb011</code>属于符号数，但是算术右移表达式最终结果的符号仅仅与<strong>左操作数</strong>有关，因此仍然是错误的。（实际上，所有的移位运算符的<strong>右操作数</strong>都被当作无符号数处理。)<p></p><h2 id="系统函数-signed">系统函数 $signed( )</h2><p><code>$signed()</code>作为一个系统函数，其作用是执行内部的表达式，并将表达式的<strong>结果</strong>强制转换为有符号数类型（值与位宽完全相同吧），作为其返回值。该函数可以屏蔽外部表达式的符号性传递。需要注意的是，<code>$signed()</code>函数仅仅会将<strong>括号内表达式的结果</strong>强制进行转换,而<strong>不会影响</strong>表达式的执行。<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token keyword">signed</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> signA<span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>signA <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样就可以解释，为什么前三个表达式是正确的的，而最后一个表示式是错误的（在A&gt;&gt;&gt; B的执行中，A是作为无符号数进行移位）。<p></p><h2 id="三目运算符">三目运算符<code>? :</code></h2><p>根据verilog的语言特性，如果一个表达式中既存在有符号数又存在无符号数，那么表达式的<strong>结果</strong>就是<strong>无符号数</strong>（即在表达式计算过程中，有符号数当作无符号数参与运算）。</p><p><strong>如果表达式多层嵌套，那么每一个表达式结果的符号性由以下原则决定</strong>：</p><ul><li>表达式的结果的符号性，由这个表达式的操作数以及外部影响共同决定</li><li>表达式结果的符号性的决定，先于表达式结果的计算</li></ul><p>也就是说，Verilog在计算一个表达式时，会先去计算这个表达式的符号性。而在得到表达式整体的符号性之后，整体的符号性会依次向内传递到每个操作数中。而对于任何一个表达式，如果其中有一个操作数的符号性为无符号，则整个表达式的符号性为无符号。（部分操作数不影响，如移位操作的右操作数；也有部分表达式的结果不受外界影响，如比较、位拼接、位截取表达式结果均为无符号数；但大部分表达式满足本规则。）<br>三目运算符也是一种表达式，因此遵从以上原则。下面我们结合以下例子进行进一步解释——<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B <span class="token punctuation">:</span> A <span class="token operator">+</span> B<span class="token punctuation">;</span><span class="token comment">//错误</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span> <span class="token punctuation">:</span> A <span class="token operator">+</span> B<span class="token punctuation">;</span><span class="token comment">//正确</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span> <span class="token punctuation">:</span> A <span class="token operator">+</span> B<span class="token punctuation">;</span><span class="token comment">//正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>首先分析第一个表达式。最外层的三目运算符中出现了无符号数<code>A+B</code>,因此这个表达式结果的符号性为<strong>无符号</strong>，并进一步将这个<strong>无符号性</strong>传给了<code>$signed(A) &gt;&gt;&gt; B</code>。对于<code>$signed(A) &gt;&gt;&gt; B</code>这个表达式，整体符号性已经被确定为无符号，因而又进一步传给操作数<code>$signed(A)</code>，尽管<code>$signed(A)</code>的结果是有符号的，但是因为符号性的传递作用，<code>$signed(A)</code>在参与算术右移运算时仍然被当做无符号数，因此不符合预期。</li><li>对于第二个表达式，同第一个表达式的分析，<code>$signed($signed(A) &gt;&gt;&gt; B)</code>整体的符号性被确定是无符号，但是由于系统函数的作用，<code>$signed(A) &gt;&gt;&gt; B</code>与外界分割开来，根据<code>$signed</code>函数的运算规则，<code>$signed($signed(A) &gt;&gt;&gt; B)</code>先计算<code>$signed(A) &gt;&gt;&gt; B</code>的值，然后将结果看作有符号数进行返回。<br></li><li><strong>需要注意是，符号性的传递并没有失效。</strong><code>$signed($signed(A) &gt;&gt;&gt; B)</code>的<strong>有符号结果</strong>最终会被当作无符号数作为整个表达式<code>(1'b1)? $signed($signed(A) &gt;&gt;&gt; B) : A + B</code>的返回值<br>从以下实验可以看出<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> flag_1<span class="token punctuation">,</span> flag_2<span class="token punctuation">;</span><span class="token keyword">wire</span> A <span class="token operator">=</span> <span class="token number">32'hf000</span><span class="token punctuation">;</span><span class="token keyword">wire</span> B <span class="token operator">=</span> <span class="token number">32'h0001</span><span class="token punctuation">;</span><span class="token keyword">assign</span> flag_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span> <span class="token punctuation">:</span> A <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">assign</span> flag_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token kernel-function property">$unsigned</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span> <span class="token punctuation">:</span> A <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//最终结果flag_1和flag_2都是1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="位宽与符号">位宽与符号</h2><p>表达式的结果除了符号性以外，还有一个特质：位宽。表达式的符号性与等号左侧无关；但表达式的位宽一般来说是<strong>等号左右两侧所有表达式的位宽中最大的一个</strong>。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>D<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>A<span class="token punctuation">,</span>B<span class="token punctuation">;</span><span class="token keyword">assign</span> D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">{</span>A<span class="token punctuation">,</span>B<span class="token operator">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>{A, B}</code>的结果是一个32位的无符号数，这导致了右侧表达式的期望结果是一个32位无符号数（因为等号左侧最大位宽也是32位）；而<code>$signed($signed(A) &gt;&gt;&gt; B)</code>的结果是一个16位的有符号数。当这个有符号数被计算出后，它会先被转化成无符号数，再被扩展至32位。因此我们最终得到的变量D的高16位都会被填充上0。但是，如果D的位宽是16位，因此就不需要进行位扩展，问题也就没有暴露出来。</p><p>下面有一些正确的例子——</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>D<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>A<span class="token punctuation">,</span> B<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token keyword">signed</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> signA<span class="token punctuation">,</span> signB<span class="token punctuation">;</span><span class="token keyword">assign</span> D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">:</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token operator">?</span> signA <span class="token operator">&gt;&gt;&gt;</span> signB <span class="token punctuation">:</span> signA <span class="token operator">+</span> signB<span class="token punctuation">;</span><span class="token keyword">assign</span> D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量和常量的符号性">变量和常量的符号性</h2><p>如果一个变量没有显式的声明符号性，则会自动被当作无符号变量<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">;</span> <span class="token comment">//无符号</span><span class="token keyword">wire</span> <span class="token keyword">unsigned</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">;</span> <span class="token comment">// 无符号</span><span class="token keyword">wire</span> <span class="token keyword">signed</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">;</span> <span class="token comment">//有符号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>如果一个常量没有显式的声明进制，则被当成<strong>有符号的</strong>十进制数；否则会被当成无符号数。<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>ALUOp<span class="token operator">==</span><span class="token number">3'b101</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&gt;&gt;&gt;</span>B <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//正确 (0 被看作有符号数)</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>ALUOp<span class="token operator">==</span><span class="token number">3'b101</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&gt;&gt;&gt;</span>B <span class="token punctuation">:</span> <span class="token number">32'b0</span><span class="token punctuation">;</span> <span class="token comment">//错误 (显式声明了进制, 被当成无符号数)</span><span class="token keyword">assign</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>ALUOp<span class="token operator">==</span><span class="token number">3'b101</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&gt;&gt;&gt;</span>B <span class="token punctuation">:</span> <span class="token number">32</span>'sb0<span class="token punctuation">;</span> <span class="token comment">//正确 (显式声明了进制,但是被显示声明了符号性)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h2 id="其他有关符号的注意事项">其他有关符号的注意事项</h2><ul><li>仅由操作数决定，不由左侧决定 (如 <code>assign D = exp</code>，exp符号与 D 无关. 这一点区别于位宽,位宽由左右两侧所有表达式的最大位宽决定)</li><li>小数是<strong>有符号</strong>的,显式声明了进制的数<strong>无符号</strong>, 除非用修饰符s声明了其有符号(如 'd12 无符号，'sd12 有符号)</li><li>位选/多位选择/位拼接的结果无符号 (如<code>b[2]</code>,<code>b[3:4]</code>, <code>{b}</code> 均无符号)</li><li>比较表达式的结果<strong>无符号</strong> (要么是 0, 要么是 1)</li><li>由实数强转成整型的表达式<strong>有符号</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog中reg的使用</title>
      <link href="/2021/10/26/co/co-p1-verilog-zhong-reg-de-shi-yong/"/>
      <url>/2021/10/26/co/co-p1-verilog-zhong-reg-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义和实例化模块时reg的使用">定义和实例化模块时reg的使用</h2><ul><li><p>在实例化元件时，wire 类型信号可以被连接至任意端口上，但 reg类型的信号只能被连接至元件的输入端口上。</p></li><li><p>在声明元件时，我们可以将任意端口声明为 wire类型，但只能将输出端口声明为 reg 类型，否则会出现问题。</p><p>定义输出端口时，我们可以直接定义成reg类型<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">output</span> <span class="token keyword">reg</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p></li><li><p>或者在模块内部声明<code>reg</code>寄存器，然后通过<code>assign</code>语句将寄存器中的值赋给<code>wire</code>型输出端口<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">output</span> b<span class="token punctuation">;</span> <span class="token comment">//b是wire型(net)端口</span><span class="token keyword">reg</span> temp<span class="token punctuation">;</span><span class="token keyword">assign</span> b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>## task 和 function 中 reg 的使用<p></p></li><li><p>任务(<code>task</code>)中，返回值是通过输出端口的变量决定的，而task输出端口必须为<code>reg</code>类型。因此在调用<code>task</code>时，需要在调用前定义一个reg型变量，接收<code>task</code>的返回值。</p></li><li><p>函数(<code>function</code>)中，调用函数的表达式的操作结果就是返回值。在函数的定义时，默认存在一个与函数同名的，在函数内部的寄存器(<code>reg</code>)，相当于C语言中的<br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span>……<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp_reg<span class="token punctuation">;</span> <span class="token comment">//建立临时变量，储存要返回的结果</span>    <span class="token comment">/* 对temp_reg 进行操作*/</span>    <span class="token keyword">return</span> temp_reg<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog其他tips</title>
      <link href="/2021/10/26/co/co-p1-verilog-qi-ta-tips/"/>
      <url>/2021/10/26/co/co-p1-verilog-qi-ta-tips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>always中的敏感列表不支持(posedge clk or negedge clk)</li><li>parameter可用作在顶层模块中例化底层模块时传递参数的接口，localparam的作用域仅仅限于当前module，不能作为参数传递的接口。</li><li>复位的时候要把所有的reg型变量都复位</li><li>integer类型也是一种寄存器数据类型，integer类型的变量为有符号数，而reg类型的变量则为无符号数，除非特别声明为有符号数，还有就是integer的位宽为宿主机的字的位数，但最小为32位，用integer的变量都可以用reg定义，只是用于计数更方便而已。reg,integer,real，time都是寄存器数据类型，定义在Verilog中用来保存数值的变量，和实际的硬件电路中的寄存器有区别。</li><li>大多数的矢量类型（reg或者net）都被默认当做无符号数。integer和real是个例外，它们被默认为当做有符号数。通常，real类型是不可综合的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog状态机设计</title>
      <link href="/2021/10/26/co/co-p1-verilog-zhuang-tai-ji-she-ji/"/>
      <url>/2021/10/26/co/co-p1-verilog-zhuang-tai-ji-she-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Verilog HDL 中可以用许多种方法来描述有限状态机，最常用的方法是用always 语句和 case 语句。下面具体说明用 Verilog设计有限状态机的一般步骤：</p><ul><li><p>逻辑抽象，得出状态转换图。</p></li><li><p>状态化简（该步骤可以省略），如果在状态转换图中出现两个一样的状态则需要将其合并为一个状态，以得到最简的状态转换图。</p></li><li><p>状态分配，也就是状态编码。通常有很多种编码方式，比如 <strong>Gray编码</strong>、<strong>独热编码</strong>等。在实际电路中，需综合考虑电路复杂度与电路性能之间的折中。这里的设计没有用到特别复杂的电路逻辑，所以大家可以自行决定用哪种编码方式。（<strong>不过，对于需要在FPGA上运行的电路，推荐使用独热编码方式。因为FPGA有丰富的寄存器资源，门逻辑相对缺乏，采用独热编码可以有效提高电路的速度和可靠性，也有利于提高器件资源的利用率。</strong>）</p></li><li><p>根据状态转移图得出次态逻辑和输出逻辑。</p></li><li><p>按照相应逻辑，用 Verilog HDL 来描述有限状态机状态转移的情况。要注意同步复位和异步复位的不同， 尽量用 case 或 if-else语句描述出状态的转移。</p></li></ul><h4 id="设计建议">设计建议</h4><ol type="1"><li>一般用case、casez 或 casex语句进行状态判断，比用 if-else语句更加清晰明了。</li><li>在 case 语句的最后，要加上 default分支语句，以避免锁存器的产生。</li><li>状态机一般应设计为同步方式，并由一个时钟信号来触发。</li><li>实用的状态机都应设计为由唯一的时钟边沿触发的同步运行方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog边沿检测总结</title>
      <link href="/2021/10/26/co/co-p1-verilog-bian-yan-jian-ce-zong-jie/"/>
      <url>/2021/10/26/co/co-p1-verilog-bian-yan-jian-ce-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="上升沿或下降沿检测">上升沿（或下降沿）检测</h2><p>如图所示，当检测到上升沿时，<strong>out</strong>会变为高电平，同时维持一个周期，然后变为低电平等待下一次检测。<br><img src="上升沿识别.png" alt="上升沿识别"><br>只需要设定一个临时<code>reg</code>类型变量来储存上一次的<strong>in</strong>值，然后在下一上升沿进行识别即可，代码如下</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pedge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> temp<span class="token punctuation">;</span>    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span>        <span class="token keyword">begin</span>            temp <span class="token operator">&lt;=</span> in<span class="token punctuation">;</span> <span class="token comment">//temp始终比in晚一个周期</span>            pedge <span class="token operator">&lt;=</span> <span class="token operator">~</span>temp <span class="token operator">&amp;</span> in<span class="token punctuation">;</span> <span class="token comment">//当输出为1时检测到上升沿</span>            <span class="token comment">//本题刚好与所示时序图相反，其中Q就相当于temp， D就相当于in，检测下降沿是对in取反就好。</span>        <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="上升沿和下降沿同时检测">上升沿和下降沿同时检测</h2><p>时序图如下<br><img src="上升沿和下降沿同时识别.png"><br>该问题比较简单，只需要稍微修改以下计算<code>out</code>的表达式即可<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_temp<span class="token punctuation">;</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span>    <span class="token keyword">begin</span>        in_temp <span class="token operator">&lt;=</span> in<span class="token punctuation">;</span>        anyedge <span class="token operator">&lt;=</span> in <span class="token operator">^</span> in_temp<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="下降沿或上升沿捕获">下降沿（或上升沿）捕获</h2><p>捕获的意思是，只要检测到下降沿，就使得输出信号<code>out</code>一直保持高电平，直至复位信号<code>reset</code>值为<strong>1</strong>（此处为同步复位）。时序图如下——<br><img src="下降沿捕获.png"><br>此时我们需要注意，“使<code>out</code>在复位之前一直保持值为1”的方法。<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> reset<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_temp<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        in_temp <span class="token operator">&lt;=</span> in<span class="token punctuation">;</span>        <span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">begin</span>            out <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>in_temp <span class="token operator">&amp;</span> <span class="token operator">~</span>in<span class="token punctuation">)</span> <span class="token operator">|</span> out<span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span> <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="双边沿检测触发器">双边沿检测触发器</h2><p>此时我们要构造一个触发器使其可以同时检测时钟的上升沿和下降沿，时序图如下——<br><img src="双边沿检测触发器.png"><br>由于<code>always</code>中的敏感列表不支持(posedge clk or negedgeclk)，因此我们可以使用两个always语句然后结合MUX实现<br></p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>clk<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token punctuation">:</span> b<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        a <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        b <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>还有以下使用XOR的方法解决,可以说是非常巧妙了。<br><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> p<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    <span class="token comment">// clk的上升沿</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span>        p <span class="token operator">&lt;=</span> d <span class="token operator">^</span> n<span class="token punctuation">;</span>    <span class="token comment">// clk的下降沿</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">negedge</span> clk<span class="token punctuation">)</span>        n <span class="token operator">&lt;=</span> d <span class="token operator">^</span> p<span class="token punctuation">;</span>    <span class="token comment">//在上升沿时候，p=d^n, 则q=d^n^n=d;</span>    <span class="token comment">//在下降沿时候，n=d^p, 则q=p^d^p=d;</span>    <span class="token comment">//加载一个新值时会取消旧值。</span>    <span class="token keyword">assign</span> q <span class="token operator">=</span> p <span class="token operator">^</span> n<span class="token punctuation">;</span>    <span class="token comment">// 这样写是无法综合的</span>    <span class="token comment">/*always @(posedge clk, negedge clk) begin        q &lt;= d;    end*/</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P1_Verilog阻塞和非阻塞赋值的讨论</title>
      <link href="/2021/10/26/co/co-p1-verilog-zu-sai-he-fei-zu-sai-fu-zhi-de-tao-lun/"/>
      <url>/2021/10/26/co/co-p1-verilog-zu-sai-he-fei-zu-sai-fu-zhi-de-tao-lun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念区别">概念区别</h2><ol type="1"><li><p>阻塞赋值操作符用等号(即 =)表示。“阻塞”是指在进程语句（initial和always）中，当前的赋值语句阻断了其后的语句，也就是说后面的语句必须等到当前的赋值语句执行完毕才能执行。而且阻塞赋值可以看成是一步完成的，即：计算等号右边的值并同时赋给左边变量。</p><p>也就是说：赋值时先计算等号右手方向（RHS）部分的值，这时赋值语句不允许任何别的Verilog语句的干扰，直到现行的赋值完成时刻，即把RHS赋值给LHS的时刻，它才允许别的赋值语句的执行。</p></li><li><p>非阻塞赋值操作符用小于等于号 (即 &lt;=)表示。“非阻塞”是指在进程语句（initial和always）中，当前的赋值语句不会阻断其后的语句。非阻塞语句可以认为是分为两个步骤进行的：</p><ul><li><p>计算等号右边的表达式的值,(<strong>我的理解是：在进入进程后，所有的非阻塞语句的右端表达式同时计算，赋值动作只发生在顺序执行到当前非阻塞语句那一刻</strong>)。</p></li><li><p>在本条赋值语句结束时，将等号右边的值赋给等号左边的变量。</p></li></ul><p>也就是说：在<strong>赋值操作时刻开始</strong>时<strong>计算</strong>非阻塞赋值符的RHS表达式，<strong>赋值操作时刻结束</strong>时<strong>更新</strong>LHS。在计算非阻塞赋值的RHS表达式和更新LHS期间，其他的Verilog语句，包括其他的Verilog非阻塞赋值语句都能同时计算RHS表达式和更新LHS。非阻塞赋值允许其他的Verilog语句同时进行操作。</p></li></ol><h2 id="层次化队列事件">层次化队列事件</h2><p><strong>层次化事件队列</strong>是硬件仿真（Simulation）时，用于规定“<strong>不同事件执行的优先级关系</strong>”，在这里我们可以一般将一个事件理解为需要运行的一条语句（当然，有的语句由多个事件组成，例如非阻塞赋值需要被拆分为计算等号右边的值（RHS）和将结果赋予等号的左边变量（LHS），赋值事件在计算事件执行结束时才能加入队列。根据事件的优先级，Verilog将其分为 4个队列（<strong>队列间的优先级不同，从上到下优先级依次递减，只有当优先级高的队列中所有任务完成后，才会继续完成优先级较低的任务</strong>）</p><ol type="1"><li>动态事件队列（动态事件队列在队列内部执行顺序无硬性规定，但在同一个begin - end语句块中的语句应当严格按照源代码中的顺序执行；且多个非阻塞赋值应当按照语句执行顺序进行）<ul><li>阻塞赋值</li><li>计算非阻塞赋值语句右边的表达式（RHS）</li><li>连续赋值（如 assign）</li><li>执行 display 命令</li><li>……</li></ul></li><li>停止运行的时间队列（#0）（不推荐使用）</li><li>非阻塞事件队列：更新非阻塞赋值语句 LHS（左边变量）的值。</li><li>监控事件队列（执行 monitor，strobe 命令）<br>## 注意事项</li><li>阻塞赋值是按需执行，非阻塞赋值是并行执行。</li><li>阻塞赋值和后面的赋值语句<strong>只有概念上的先后，而无实质上的延迟</strong>。若在RHS 加上延迟，则在延迟期间会阻止赋值语句的执行,延迟后才执行赋值，这种赋值语句是不可综合的。</li><li>一般可综合的阻塞赋值操作在RHS不能设定有延迟，(<strong>即使是零延迟也不允许</strong>)</li><li>非阻塞赋值操作只能用于对寄存器类型变量进行赋值，因此只能用在"initial"块和"always"块等过程块中。非阻塞赋值<strong>不允许</strong>用于连续赋值。</li></ol><h2 id="可综合风格的verilog编程原则">可综合风格的Verilog编程原则</h2><ol type="1"><li>时序电路建模时，用非阻塞赋值。</li><li>锁存器电路建模时，用非阻塞赋值。</li><li>用always块建立组合逻辑模型时，用阻塞赋值。</li><li>在同一个always块中建立时序和组合逻辑电路时，用非阻塞赋值。</li><li>在同一个always块中不要既用非阻塞赋值又用阻塞赋值。</li><li>不要在一个以上的always块中为同一个变量赋值。</li><li>用$strobe系统任务来显示用非阻塞赋值的变量值</li><li>在赋值时不要使用 #0 延迟</li></ol><h2 id="赋值延后的情况">赋值延后的情况</h2><ol type="1"><li><p>当在always块中的每一个条件分支中，仅有一条赋值语句（不管是阻塞与非阻塞），且要满足条件中的条件判断式不含有在本模块中定义并赋值的reg变量（采用非阻塞赋值）或者来自其他模块的非阻塞reg型信号，此时阻塞与非阻塞表现的结果是一样的，都是在时钟边沿瞬间完成的；</p><p>理解非阻塞赋值分两个过程，RHS的计算为第一步，LHS的赋值为第二步，这是第一层面；第二，由于两步时间非常短，表现出来就是在时钟边沿瞬间完成，故表现结果非阻塞和阻塞一样，这是第二个层面。</p></li><li><p>当条件分支语句中含有的条件判断式是阻塞赋值变量（无论是外部输入的数据，或者是本模块的阻塞赋值变量，此时也包括assign赋值语句的LHS），那么也是在边沿瞬间完成赋值，不会延后1个周期；</p><p><strong>NOTE：assign赋值语句为连续赋值语句，与过程赋值语句并列（过程赋值包括阻塞与非阻塞）。</strong></p></li><li><p>如果条件判断式中含有非阻塞赋值的reg变量（无论是本模块的还是其他外部模块的），那么在该条件分支下的非阻塞赋值语句会延后一个周期完成（相对条件判断式中的变量的赋值完成，延后一个周期赋值）。</p></li><li><p>一个条件分支中含有多条非阻塞语句时，若non1（第一条LHS）出现在第二条语句的RHS中，则会出现non2延迟一个周期的情况，<br>————————————————<br>原文链接：https://blog.csdn.net/huigeyu/article/details/100105428</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P0_logisim状态机设计</title>
      <link href="/2021/10/17/co/co-p0-logisim-zhuang-tai-ji-she-ji/"/>
      <url>/2021/10/17/co/co-p0-logisim-zhuang-tai-ji-she-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="时序逻辑电路的基本元件">时序逻辑电路的基本元件</h2><h3 id="sr锁存器">SR锁存器</h3><ul><li>功能：清除（R = 1）、置位（S = 1）、保持（R = 0， S = 0）<br></li><li>缺点：没有时间上的同步关系<br><img src="SR锁存器原理图.png"> <img src="SR锁存器真值表.png"></li></ul><h3 id="d锁存器">D锁存器</h3><ul><li>功能：高电平时进行储存。本质是电平缓冲器，在一个时钟周期内Q可以随D多次翻转<br></li><li>缺点：无法实现时钟沿储存</li></ul><p><img src="D锁存器.png"></p><h3 id="d触发器">D触发器</h3><ul><li>功能：时钟沿上升时储存<br><img src="D触发器_1.png"> <img src="D触发器_2.png"></li></ul><h3 id="带使能端的d触发器">带使能端的D触发器</h3><ul><li>功能：若使能信号有效则可以正常读入，否则保存当前值而不读入<br><img src="带使能端的D触发器.png"></li></ul><h3 id="可置位的d触发器">可置位的D触发器</h3><ul><li>功能：若置位信号有效，则下一个时钟沿到来时触发器只更新为0</li></ul><p><img src="置位_1.png"><img src="置位_2.png"></p><h3 id="多路选择器">多路选择器</h3><ul><li>功能：根据S的值选的输出D0还是D1<br><img src="多路选择器.png"></li></ul><h2 id="有限状态机基本知识">有限状态机基本知识</h2><h3 id="状态机类型">状态机类型</h3><ul><li>Moore型：输出信号仅为状态的函数，与输入信号无关（输出晚，有效周期是circle的整数倍）</li><li>Meely型：输出信号是状态与输入信号的函数（输出早，有效时间可能更短）</li></ul><h3 id="设计步骤">设计步骤</h3><ul><li><strong>确定输入和输出</strong></li><li><strong>画出状态转移图</strong>（注意所有可能的情况以及复位操作）</li><li><strong>为状态编码</strong>（独热码or二进制码）</li><li><strong>列出状态转移表和输出表</strong></li><li><strong>将真值表转化为表达式</strong></li><li><strong>连接电路</strong></li></ul><h3 id="设计要点">设计要点</h3><ul><li><p><strong>初始状态</strong><br>状态机必须指定一个初始状态，以确保系统在上电后处于确定的状态</p></li><li><p><strong>复位信号</strong><br>复位信号的作用是将状态机强制初始化为初始状态,包括同步复位和异步复位。</p></li><li><p><strong>状态编码方式</strong></p><ul><li>二进制编码：log2𝑁个触发器表示N个状态,节省逻辑资源，但可能产生毛刺</li><li>格雷编码：log2𝑁个触发器表示N个状态，但相邻状态编码值只有1位不同,节省逻辑资源,又避免产生毛刺（状态顺序的转换中有效）</li><li>一位热码编码（One-HotEncoding）：N个触发器表示这N个状态,资源消耗多，但无毛刺,降低次态逻辑和输出逻辑复杂度，有利于提高时钟频</li></ul></li></ul><h2 id="logisim中有限状态机的实现">logisim中有限状态机的实现</h2><p>总体来说，使用 Logism设计有限状态机的过程基本上可以分为三个步骤：</p><ul><li>设计实现状态存储模块</li><li>设计实现状态转移模块</li><li>设计实现输出模块</li></ul><p>其中，状态转移模块和输出模块内是纯组合逻辑，不涉及时序逻辑；状态存储模块则需要存储每个周期有限状态机的具体状态。</p><p><strong>两种状态机的状态转移和状态存储模块的设计方法基本一致</strong>：<br>状态转移模块根据当前有限状态机的状态(即状态存储模块所存储的值)和当前的输入计算出有限状态机的下一状态值，当时钟上升沿到来时，这个新的状态值被存入状态存储模块中。</p><p><strong>两种状态机的不同之处在于输出模块对输入数据的要求</strong>：</p><ul><li>more型有限状态机的设计<br><img src="moore.png"></li><li>mealy型有限状态机的设计<br><img src="mealy.PNG"></li></ul><h3 id="verilog中有限状态机的实现">verilog中有限状态机的实现</h3><p>在 Verilog HDL 中可以用许多种方法来描述有限状态机，最常用的方法是用always 语句和 case 语句。下面具体说明用 Verilog设计有限状态机的一般步骤：</p><ul><li><p>逻辑抽象，得出状态转换图。</p></li><li><p>状态化简（该步骤可以省略），如果在状态转换图中出现两个一样的状态则需要将其合并为一个状态，以得到最简的状态转换图。</p></li><li><p>状态分配，也就是状态编码。通常有很多种编码方式，比如 <strong>Gray编码</strong>、<strong>独热编码</strong>等。在实际电路中，需综合考虑电路复杂度与电路性能之间的折中。这里的设计没有用到特别复杂的电路逻辑，所以大家可以自行决定用哪种编码方式。（<strong>不过，对于需要在FPGA上运行的电路，推荐使用独热编码方式。因为FPGA有丰富的寄存器资源，门逻辑相对缺乏，采用独热编码可以有效提高电路的速度和可靠性，也有利于提高器件资源的利用率。</strong>）</p></li><li><p>根据状态转移图得出次态逻辑和输出逻辑。</p></li><li><p>按照相应逻辑，用 Verilog HDL 来描述有限状态机状态转移的情况。要注意同步复位和异步复位的不同， 尽量用 case 或 if-else语句描述出状态的转移。</p></li></ul><h4 id="设计建议">设计建议</h4><ol type="1"><li>一般用case、casez 或 casex语句进行状态判断，比用 if-else语句更加清晰明了。</li><li>在 case 语句的最后，要加上 default分支语句，以避免锁存器的产生。</li><li>状态机一般应设计为同步方式，并由一个时钟信号来触发。</li><li>实用的状态机都应设计为由唯一的时钟边沿触发的同步运行方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Algorithm」状压DP解决Hamilton回路问题</title>
      <link href="/2021/10/01/algorithm/zhuang-ya-dp-jie-jue-hamilton-hui-lu-wen-ti/"/>
      <url>/2021/10/01/algorithm/zhuang-ya-dp-jie-jue-hamilton-hui-lu-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="序言">序言</h2><p>刚看到这个哈密顿回路的题时，第一感觉就是可以采用回溯法并通过<strong>深度优先搜索(DFS)</strong>解决，笔者初次就是使用这个方法并结合状态压缩AC了这道题。但是因为要使用递归，“翻译”成MIPS汇编代码的时候需要使用大量堆栈保存返回地址、函数参数、还有在调用过程中使用过的并希望保存的寄存器（笔者曾因为堆栈处理不当陷入了十分抓狂的境地）。</p><p>后来听翔宇哥哥说这个题可以采用 <strong>状压DP</strong>的方法解决（xyggyyds！），于是笔者便开始<del>面向百度和CSDN</del>，最后终于用非递归的方法解决了这道题，于是便写了本篇文章分享一下心得。<br>***</p><h2 id="为什么可以使用状压dp">为什么可以使用<strong>状压DP</strong>？</h2><p>首先，本题满足DP算法的三个条件——</p><ul><li>重复子问题</li><li>最优子结构</li><li>无后效性</li></ul><p>在此就不具体展开，有兴趣的同学可以参考CSDN上这篇<a href="https://blog.csdn.net/lw_power/article/details/105356074">博客</a>。如果暂时不想了解也可以跳过，相信不会影响对本题算法的理解。</p><p>其次，“<strong>状压</strong>”顾名思义就是“<strong>状态压缩</strong>”，也就是<strong>“将一个阶段或集合的状态压缩到一个二进制整数</strong>，其中<strong><code>0</code></strong> 和 <strong><code>1</code></strong>分别表示两种不同的状态，从而达到节省储存空间和提高查找效率的作用。以本题为例，我们把图中每个顶点的状态压缩到二进制的位，用<strong><code>1</code></strong>表示该点被访问过，<strong><code>0</code></strong>表示该点没有被访问过。于是，我们就可以用一个二进制正数表示<strong>所有被访问过的点构成的集合S（以下简称“点集”）</strong>。例如，当S=39时，二进制表示为100111，说明此时编号为0、1、2、6的点在集合中。</p><p>既然状态压缩使用二进制数，那么必然和位运算脱不了干系。以下是常用的状态压缩操作和相应的位运算表示——</p><table><thead><tr class="header"><th style="text-align: center;">操作</th><th style="text-align: center;">位运算表示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">取出整数n在二进制表示下的第k位</td><td style="text-align: center;">（n&gt;&gt;k）&amp;1</td></tr><tr class="even"><td style="text-align: center;">取出整数n在二进制表示下的第0~k-1位（后k位）</td><td style="text-align: center;">n&amp;((1&lt;&lt;k)-1)</td></tr><tr class="odd"><td style="text-align: center;">取出整数n在二进制表示下的第k位取反</td><td style="text-align: center;">n^(1&lt;&lt;k)</td></tr><tr class="even"><td style="text-align: center;">取出整数n在二进制表示下的第k位赋值为1</td><td style="text-align: center;">n|(1&lt;&lt;k)</td></tr><tr class="odd"><td style="text-align: center;">取出整数n在二进制表示下的第k位赋值为0</td><td style="text-align: center;">n&amp;(~(1&lt;&lt;k))</td></tr></tbody></table><hr><h2 id="解题思路">解题思路</h2><p>为判断图中的是否存在<strong>哈密顿回路</strong>，我们可以先判断是否存在<strong>哈密顿路径</strong>（ 即沿着边访问每个顶点，每个顶点恰好访问一次），然后再判断 <strong>最后访问的点</strong> 和<strong>最初访问的点</strong> 之间是否有通路即可。为方便判断，我们选取<strong>0号点</strong> 为最初访问的点。</p><h3 id="判断是否存在哈密顿路径状压dp"><strong>判断是否存在哈密顿路径（状压DP）</strong></h3><p>解决本题我们需要两个数组——</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token keyword">int</span> edge<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<strong><code>edge</code></strong>是储存无向图的邻接矩阵，<strong><code>edge[u][v] = 1</code></strong>表示点v和点u之间有通路；<strong><code>dp</code></strong> 表示状态，以<strong><code>dp[S][v]</code></strong>为例，<strong><code>S</code></strong>表示点集，即<strong>此时已经被访问的所有点的集合</strong>，<strong><code>v</code></strong>表示<strong>该点集中最后一个被访问的点的序号</strong>。</p><p>例如，<strong><code>dp[39][2]</code></strong>表示<strong>点集“100111”中最后被访问的点的序号是2</strong>。访问顺序可以是<strong>"0-&gt;6-&gt;1-&gt;2"</strong>，也可以是<strong>"0-&gt;1-&gt;6-&gt;2"</strong>。也就是说，<strong><code>dp[39][2]</code></strong>之前的状态可以是<strong><code>dp[35][6]</code></strong>（点集S为”100011“，最后访问的点是6号点），也可以是<strong><code>dp[35][1]</code></strong>（点集S为”100011“，最后访问的点是1号点）</p><p>dp[S][v]的值只能是0和1。<strong><code>1</code></strong>表示此时S中的点可以形成<strong><code>哈密顿路径</code></strong>，而且该哈密顿路径的终点为<strong>v</strong>；<strong><code>0</code></strong>表示此时S中的点无法形成哈密顿路径。</p><p>因为我们默认最早访问的点为0号点，所以我们首先规定<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//表示0号点第一个被访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>为找出状态转移方程，我们可以先从小问题入手分析：<p></p><ul><li><p><strong>Q</strong>：图中现在有4个点（标号为0，1，2，3），我们怎么判断存在哈密顿路径呢？</p></li><li><p><strong>A</strong>：只需要求得<strong><code>dp[0b1111][1] = 1</code></strong> 或者<strong><code>dp[0b1111][2] = 1</code></strong> 或者<strong><code>dp[ob1111][3] = 1</code></strong> 即可。</p></li><li><p><strong>Q</strong>：那我们怎么求<strong><code>dp[0b1111][1]</code></strong>的值呢？？？（其他同理）</p></li><li><p><strong>A</strong>：此时我们转移到上一个状态（点集S =”1101“）。只需要0号点，2号点和3号点可以形成哈密顿路，并且其中至少有一个点（除了0号点）与1号点之间存在通路，即<strong>"<code>dp[0b1101][2] = 1</code> 并且<code>edge[2][1] = 1</code>"</strong> 或者<strong>"<code>dp[0b1101][3] = 1</code> 并且<code>edge[3][1] = 1</code>"</strong> ，那么<strong><code>dp[0b1111][1]</code></strong>的值就是1，否则为0。</p></li><li><p><strong>Q</strong>：那我们怎么求<strong><code>dp[0b1101][2]</code></strong>的值呢？？？（其他同理）</p></li><li><p><strong>A</strong>：我们再次转移到上一个状态（点集S =”1001“）。只需要0号点与3号点之间有哈密顿路径，并且3号点和2号点之间有通路（因为0号点是初始点，所以没有必要判断0号点和2号点之间是否有通路），即<strong>"<code>dp[0b1001][3] = 1</code> 并且<code>edge[3][2] = 1</code>"</strong>， 那么<strong><code>dp[ob1101][2]</code></strong>的值就是1，否则是0。</p></li><li><p><strong>Q</strong>：我们怎么求<strong><code>dp[0b1001][3]</code></strong> 的值呢？？？</p></li><li><p><strong>A</strong>：呃……好像结束了，只需要判断<strong><code>edge[0][3]</code></strong> 就行了。</p></li></ul><p>经过以上的Q&amp;A，你大概可以发现，每一个状态的计算都依赖他的上一个状态（即子过程）的值，状态转移方程可以写作</p><p><span class="math inline">\(\mathsf{DP[S][v]=\bigcup_{i=1}^n \(DP[S\_prev][u_i]} \ \  \&amp;\ \  \mathsf{road[u_i][v])}\)</span></p><p>相信你已经对状态转移的具体过程有了大致的了解，那么我们结合下面的代码来进一步分析</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> S <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> S<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>S <span class="token operator">&gt;&gt;</span> v<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> S_prev <span class="token operator">=</span> S <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> u <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> u<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>S_prev <span class="token operator">&gt;&gt;</span> u<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>                     dp<span class="token punctuation">[</span>S<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>S_prev<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&amp;</span> edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在最外层的循环<strong><code>for(S = 1; S &lt; (1 &lt;&lt; n); S++)</code></strong>中，我们让 <strong>子集S</strong> 从 <strong>1 (0b00000001)</strong> 到<strong>1&lt;&lt;8 (0b1111111)</strong>（假设n=8）进行遍历。因为表示子集状态的值S是从小到大变化的，所以可以保证当计算当前状态时，其子状态一定被计算过。</p><p>在第二层循环 <strong><code>for(v = 0; v &lt; n; v++)</code></strong>中，我们遍历所有的点，通过<strong><code>(S &gt;&gt; v) &amp; 1</code></strong> 来判断序号为<strong>v</strong> 的点是否在点集 <strong>S</strong>中，如果结果为1，我们便找出计算对象<strong><code>dp[S][v]</code></strong>，并找出上一状态对应的点集<strong><code>S_prev = S ^ (1 &lt;&lt; v)</code></strong>，然后进入第三层循环。</p><p>在第三层循环 <strong><code>for(u = 0; u &lt; n; u++)</code></strong>中，我们继续遍历所有点，找出可以作为上一状态终点的所有点的序号<strong>u</strong>，进一步可以找出<strong><code>dp[S_prev][u]</code></strong> 的值（因为<strong><code>S_prev &lt; S</code></strong>，因此之前必然计算过<strong><code>dp[S_prev][u]</code></strong> 的值）。</p><p>最后我们让 <strong><code>dp[S][v]</code></strong><strong>或上</strong><strong><code>dp[S_prev][u] &amp; edge[u][v]</code></strong>即可。因为只要存在一个 <strong>u</strong> 使得<strong><code>dp[S_prev][u] &amp; edge[u][v] = 1</code></strong>，就说明<strong>0号点到v号点之间有哈密顿路径</strong>（0号点到u号点之间存在哈密顿路径，u号点和v号点之间有通路）。</p><h3 id="判断是否有哈密顿回路"><strong>判断是否有哈密顿回路</strong></h3><p>经过上面的计算，我们已经得出点集"<strong><code>11111111</code></strong>"（假设点的个数n=8）中存在的所有哈密顿路径，现在只要存在<strong>某个哈密顿路径的终点与0号点（起点）之间有通路</strong>即可。该过程仅需一个循环便可解决<br></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"0"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>思路比较简单，此处不再赘述。<p></p><h2 id="后记">后记</h2><p>本题的解题方法也可以用于解决<a href="https://blog.csdn.net/qq_42505741/article/details/97788303?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.no_search_link">最短哈密顿回路</a>问题，有兴趣的同学可以尝试一下。另外，因为笔者之前也没有学过算法，能力也十分有限，如果本篇题解中有纰漏甚至错误之处，还望各位dl不吝赐教！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
