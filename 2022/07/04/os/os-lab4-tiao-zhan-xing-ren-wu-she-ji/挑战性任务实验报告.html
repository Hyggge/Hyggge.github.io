<h1>Lab4 挑战性任务实验报告</h1>
<h2 id="任务简介">任务简介</h2>
<p>Lab4的挑战性任务要求我们对MOS中以进程为单位的调度方式进行修改，实现线程相关机制，将作业调度的粒度缩小到线程，提高MOS的并发能力。此外，同一进程中的所有线程都共享进程中的资源，因此难免会出现资源竞争的现象。为了更好的控制线程之间的同步互斥关系，我们还需要实现信号量机制，从而保证各个线程能够按照我们的预期运行。</p>
<p>最终，我在任务中实现了以下用户态函数，并成功通过了自己的测试样例，达到了预期效果。</p>
<ul>
<li><strong>线程相关函数</strong>
<ul>
<li><strong>pthread_create</strong></li>
<li><strong>pthread_exit</strong></li>
<li><strong>pthread_cancel</strong></li>
<li><strong>pthread_join</strong></li>
<li><strong>pthread_testcancel</strong></li>
<li><strong>pthread_self</strong></li>
<li><strong>pthread_detach</strong></li>
<li><strong>pthread_setcanceltype</strong><br>
 </li>
</ul>
</li>
<li><strong>信号量相关函数</strong>
<ul>
<li><strong>sem_init</strong></li>
<li><strong>sem_destroy</strong></li>
<li><strong>sem_wait</strong></li>
<li><strong>sem_trywait</strong></li>
<li><strong>sem_post</strong></li>
<li><strong>sem_getvalue</strong></li>
</ul>
</li>
</ul>
<h2 id="线程相关机制">线程相关机制</h2>
<h3 id="数据结构">数据结构</h3>
<h4 id="线程控制块的设置">线程控制块的设置</h4>
<p>首先，我们需要引入记录线程相关状态的数据结构，从而实现对线程的控制。这个数据结构就是线程控制块——</p>
<pre><code class="language-cpp">struct Thread {
    u_int thread_id;        
    u_int thread_pri;       
    u_int thread_tag;       
    u_int thread_status;    
    struct Trapframe thread_tf;
    LIST_ENTRY(Thread) thread_sched_link;
    void* thread_retval;
    void** thread_retval_ptr;
    u_int thread_join_caller;
    u_int thread_cancel_type;
};
</code></pre>
<ul>
<li><code>thread_id</code>是线程的<code>id</code>。<code>thread_id</code>包括两部分，0-4位表示该线程是所属进程中的第几号线程（每个进程中最多同时运行32个线程），4-31位记录线程所属进程的<code>envid</code>；</li>
<li><code>thread_pri</code>是线程的优先级。线程通过优先级来确定时间片的大小，属于同一进程的所有线程优先级相同。</li>
<li><code>thread_tag</code>是线程的标志位集合。这里采用状态压缩的方式，每一位分别表示不同的标志位。<pre><code class="language-cpp">#define THREAD_TAG_CANCELED    1    // bit0为1表示线程已经被cancel
#define THREAD_TAG_JOINED      2    // bit1为1表示线程已经被joined
#define THREAD_TAG_EXITED      4    // bit2为1表示线程已经调用过pthread_exit函数
#define THREAD_TAG_DETACHED    8    // bit3为1表示线程已经是分离状态
</code></pre>
</li>
<li><code>thread_status</code>表示线程的运行状态，可取值有<code>THREAD_FREE</code>，<code>THREAD_RUNNABLE</code>，<code>THREAD_NOT_RUNNABLE</code>。<pre><code class="language-cpp">#define THREAD_FREE	            0
#define THREAD_RUNNABLE		    1
#define THREAD_NOT_RUNNABLE	    2
</code></pre>
</li>
<li><code>thread_tf</code>是用来存储寄存器现场的数据结构。在线程调出时，内核会将上下文存入其中，等到线程重新获得处理机资源时再恢复。</li>
<li><code>thread_retval</code>用来保存线程返回值。</li>
<li><code>thread_retval_ptr</code>是指向线程返回值的指针。该指针的拥有者是&quot;调用join的线程&quot;，指针指向的是&quot;被join作用的线程的返回值&quot;。</li>
<li><code>thread_join_caller</code>保存的是&quot;调用join的线程&quot;，而拥有这个变量的是&quot;join作用的线程&quot;。当某个线程结束时，如果它本身是被join的，则会将自身返回值<code>thread_retval</code>存储到<code>*(caller-&gt;thread_retval_ptr)</code>中。</li>
<li><code>thread_cancel_type</code>表示线程的撤销类型，可以取<code>THREAD_CANCEL_DEFREERD</code>和<code>THREAD_CANCEL_ASYNCHRONOUS</code>两个值。如果是前者，则表示被cancel作用后不立刻结束，需等待取消点的到来；如果是后者，则被cancel作用后会立即结束。<pre><code class="language-cpp">#define THREAD_CANCEL_DEFERRED          0
#define THREAD_CANCEL_ASYNCHRONOUS	1
</code></pre>
</li>
</ul>
<h4 id="进程控制块的修改">进程控制块的修改</h4>
<p>引入线程之后，进程的作用和地位就发生了改变，进程只作为系统资源的分配单元。因此，原来进程控制块中与调度相关的数据就不再需要了，例如<code>env_pop_tf</code>和<code>env_status</code>，取而代之的是和线程控制相关的数据。更改之后的进程控制块如下</p>
<pre><code class="language-cpp">struct Env {
    // struct Trapframe env_tf;         // Saved registers
    LIST_ENTRY(Env) env_link;           // Free list
    u_int env_id;                       // Unique environment identifier
    u_int env_parent_id;                // env_id of this env's parent
    // u_int env_status;                // Status of the environment
    Pde  *env_pgdir;                    // Kernel virtual address of page dir
    u_int env_cr3;
    u_int env_pri;

    LIST_ENTRY(Env) env_sched_link;

    // Lab 4 IPC
    u_int env_ipc_value;                // data value sent to us 
    u_int env_ipc_from;                 // envid of the sender  
    u_int env_ipc_recving;              // env is blocked receiving
    u_int env_ipc_dstva;		// va at which to map received page
    u_int env_ipc_perm;		        // perm of page mapping received
    u_int env_ipc_dst_thread;

    // Lab 4 fault handling
    u_int env_pgfault_handler;          // page fault state
    u_int env_xstacktop;                // top of exception stack

    // Lab 6 scheduler counts
    u_int env_runs;			// number of times been env_run'ed
    u_int env_nop;                      // align to avoid mul instruction

    // Lab 4 challenge
    u_int env_thread_bitmap;
    struct Thread env_threads[32];
};
</code></pre>
<p>可以发现，删除<code>env_pop_tf</code>和<code>env_status</code>后，我们又新增了三个数据——<code>env_ipc_dst_thread</code>，<code>env_thread_bitmap</code>和<code>env_therads</code>。</p>
<ul>
<li><code>env_ipc_dst_thread</code>保存IPC交互过程中&quot;读线程&quot;的id。</li>
<li><code>env_thread_bitmap</code>是用来记录线程使用状态的位图。一个进程中最多有32个线程，正好对应整数的32个位。1表示线程已经被分配出去，状态可能是<code>RUNNABLE</code>或者<code>NOT_RUNNABLE</code>；0表示线程仍然是<code>FREE</code>状态，可以被申请。</li>
<li><code>env_threads</code>中存储被该进程管理的32个线程的线程控制块。</li>
</ul>
<h3 id="线程的创建和销毁">线程的创建和销毁</h3>
<p>每个进程的0号线程是该进程的主线程，主线程的PC初始值是用户程序镜像中的<code>entry point</code>，从而保证线程运行时直接执行用户程序中的<code>main</code>函数。每当创建一个新的进程时，该进程的主线程也随之被分配出去了。为了保证进程及其主线程同时创建、以及主线程能够从正确的PC开始运行，我们需要对原来的<code>env_alloc</code>、<code>env_create_priority</code>、<code>load_icode</code>等函数进行修改。</p>
<p>进程中的1-31号线程都是通过<code>pthread_create</code>函数创建出来的，我们姑且把这些线程称为子线程。子线程的运行入口是某个由用户创建的&quot;线程运行函数&quot;（相当于Java中的<code>run</code>方法），而并非是<code>main</code>函数，这是子线程和主线程的根本区别。</p>
<p>不论是子线程和主线程，在运行时都需要一定的栈空间。为了保证每个线程都拥有独立的栈空间，同时尽量避免不同线程的栈之间发生冲突，我从<code>USTACKTOP</code>开始为0-31号线程依次划分了4MB大小的空间，<code>USTACKTOP</code>是0号线程的栈顶，<code>USTACKTOP+4M</code>是1号线程的栈顶…以此类推。</p>
<p><img src="" alt=""></p>
<p>接下来我们就可以编写进程的创建函数，从进程控制块中申请一个线程控制块，并对这个线程可控制块进行初始化。</p>
<pre><code class="language-cpp">int thread_alloc(struct Env *e, struct Thread **new) {
    int ret;
    struct Thread *t;
    u_int thread_id;

    // 申请一个线程控制块
    thread_id = mkthreadid(e);                      //申请一个新的id
    t = &amp;e-&gt;env_threads[THREAD2INDEX(thread_id)];   //根据id从进程控制块中获取新的线程控制块

    printf(&quot;\033[1;33;40m&gt;&gt;&gt; thread %d is alloced ... (threads[%d] of env %d) &lt;&lt;&lt;\033[0m\n&quot;, 
                thread_id, THREAD2INDEX(thread_id), THREAD2ENVID(thread_id));
    
    // 进程控制初始化
    t-&gt;thread_id = thread_id;
    t-&gt;thread_pri = e-&gt;env_pri;
    t-&gt;thread_tag = 0;
    t-&gt;thread_status = THREAD_RUNNABLE;             //将线程的状态设置为runnable
    t-&gt;thread_retval = 0;
    t-&gt;thread_retval_ptr = 0;
    t-&gt;thread_join_caller = 0;
    t-&gt;thread_cancel_type = 0;
    t-&gt;thread_tf.cp0_status = 0x1000100c; 
    t-&gt;thread_tf.regs[29] = USTACKTOP - 1024 * BY2PG * THREAD2INDEX(thread_id);   // 栈空间分配  

    *new = t;
    return 0;
}
</code></pre>
<p>在线程运行函数正常结束，或者线程自己调用<code>pthread_exit</code>退出，或者线程被<code>join</code>作用时，需要释放相应的线程控制块，我们通过<code>thread_free</code>和<code>thread_destroy</code>函数实现。前者主要是将线程控制块标记成<code>FREE</code>，并在修改对应进程控制块的位图。后者在调用前者的基础上，判断进程中所有的线程是否都已经结束，如果是，则顺便调用<code>env_free</code>将进程也释放掉，随后直接<code>sched_yield</code>进行切换。</p>
<pre><code class="language-cpp">void thread_free(struct Thread *t) {
    struct Env *e;
    e = envs + ENVX(THREAD2ENVID(t-&gt;thread_id));
    thread_index_free(e, THREAD2INDEX(t-&gt;thread_id));
    t-&gt;thread_status = THREAD_FREE;
    LIST_REMOVE(t, thread_sched_link);
}


void thread_destroy(struct Thread *t) {
    struct Env *e = envs + ENVX(THREAD2ENVID(t-&gt;thread_id));
    
    thread_free(t);
    if (curthread == t) curthread = NULL;

    bcopy(KERNEL_SP - sizeof(struct Trapframe), TIMESTACK - sizeof(struct Trapframe), 
                sizeof(struct Trapframe));

    printf(&quot;\033[1;35;40m&gt;&gt;&gt; thread %d is killed ... (threads[%d] of env %d) &lt;&lt;&lt;\033[0m\n&quot;, 
                t-&gt;thread_id, THREAD2INDEX(t-&gt;thread_id), THREAD2ENVID(t-&gt;thread_id)); 
    
    // 随后判断进程中所用的线程是不是已经结束
    if (e-&gt;env_thread_bitmap == 0) {
        env_free(e);
        printf(&quot;\033[1;35;40m&gt;&gt;&gt; env %d is killed ...  &lt;&lt;&lt;\033[0m\n&quot;, e-&gt;env_id);
    }
    sched_yield();
}
</code></pre>
<h3 id="线程的调度">线程的调度</h3>
<p>线程创建出来后，还需要对其进行调度。线程的调度完全仿照进程的调度方法：<strong>采用两个队列（<code>thread_shced_list[2]</code>），用来存放可以被调度的线程的控制块。每创建出一个新的线程，我们就将该线程加入第一个队列的队首。在需要进行调度时，我们把当前已经用完时间片的线程放入另一个队列的队尾，并从当前队列的队首获取一个状态为<code>THREAD_RUNNABLE</code>的线程，让这个线程占用处理机资源。</strong></p>
<p>为了实现线程调度机制，我们需要对<code>sched_yield</code>函数进行修改。</p>
<pre><code class="language-cpp">// sched.c
extern struct Thread* curthread;
extern struct Thread_list thread_sched_list[];


void sched_yield(void)
{
    static int count = 0;
    static int point = 0;
    struct Thread *t = curthread;

    if (count == 0 || t == NULL || t-&gt;thread_status != THREAD_RUNNABLE) {
       	if (t != NULL) {
            LIST_REMOVE(t, thread_sched_link);
            LIST_INSERT_TAIL(&amp;thread_sched_list[1-point], t, thread_sched_link);
        }
        while(1) {
            if (LIST_EMPTY(&amp;thread_sched_list[point])) {
                point = 1 - point;
            }
            
            t = LIST_FIRST(&amp;thread_sched_list[point]);

            if (t-&gt;thread_status == THREAD_RUNNABLE) {
                break;
            } 
            else {
                LIST_REMOVE(t, thread_sched_link);
                LIST_INSERT_TAIL(&amp;thread_sched_list[1-point], t, thread_sched_link);
            }
        }
        count = t-&gt;thread_pri;
    }
    count--;
    thread_run(t);
}
</code></pre>
<p>对应的，我们仿照<code>env_run</code>函数编写一个<code>thread_run</code>函数。</p>
<pre><code class="language-cpp">// thread.c
void thread_run(struct Thread *t) {
    struct Env *e;
    e = envs + ENVX(THREAD2ENVID(t-&gt;thread_id));

    if (curthread != NULL) {
        struct Trapframe *old;
        old = (struct Trapframe *)(TIMESTACK - sizeof(struct Trapframe));
        bcopy(old, &amp;(curthread-&gt;thread_tf), sizeof(struct Trapframe));
        curthread-&gt;thread_tf.pc = old-&gt;cp0_epc;
    }

    if (curenv != e) {
        curenv = e;
        lcontext(curenv-&gt;env_pgdir);
    }
    // 和curenv类似，我们设置一个全局变量curthread来指向当前运行的线程的线程控制块
    curthread = t;   
    env_pop_tf(&amp;t-&gt;thread_tf, GET_ENV_ASID(e-&gt;env_id));
}
</code></pre>
<p>有一个细节需要注意，如果换出的线程和换入的线程同属于一个进程，那我们不需要使用<code>lcontext</code>更换页表，这也就是线程切换比进程间的原因（线程很长一段时间被称作轻量级进程）。我们的MOS是运行在gxemul模拟器上的，虚实地址的转换也是采用软件模拟的（并没有采用硬件MMU）。当发生tlb中断时，模拟器会根据全局变量<code>context</code>中存储的页表地址来找到页表，并找到对应的页表项。因此，进程间切换时只需要把新进程页表的物理地址传给<code>context</code>变量即可，开销看上去也不大。<strong>但是如果运行在真正的硬件上，进程间切换时还涉及到进程页表从主存和内存之间的换入和换出，以及MMU的相关调整，时间开销就会比较大</strong>。</p>
<h3 id="相关系统调用">相关系统调用</h3>
<p>为了便于用户态函数的实现，我们需要设置一些系统调用函数提供内核服务——包括<strong>申请新的线程控制块、销毁线程控制块、获得当前运行线程的id、将线程加入或移出调度队列</strong>等等。线程操作相关的系统调用包括——</p>
<ul>
<li>
<p><strong>syscall_thread_alloc</strong>：该函数用于申请新的线程控制块，直接调用<code>thread_alloc</code>函数即可。</p>
<pre><code class="language-cpp">int sys_thread_alloc(int sysno) {
    int ret;
    struct Thread *t;

    ret = thread_alloc(curenv, &amp;t); 
    if (ret &lt; 0) return ret;

    return t-&gt;thread_id;
}
</code></pre>
</li>
<li>
<p><strong>syscall_thread_destroy</strong>：该函数在线程运行函数正常结束、线程自己调用exit退出、线程被join作用时被调用，释放线程占用的资源。需要注意的是，如果被结束的线程拥有<code>THREAD_TAG_CANCELED</code>这一标志位，还需要将自身的返回值&quot;告知&quot;join函数的调用者。</p>
<pre><code class="language-cpp">
int sys_thread_destroy(int sysno, u_int threadid) {
    int ret;
    struct Thread *t;

    ret = id2thread(threadid, &amp;t);
    if (ret &lt; 0) return ret;

    if (t-&gt;thread_status == THREAD_FREE) {
        return -E_INVAL;
    }

    if ((t-&gt;thread_tag &amp; THREAD_TAG_JOINED) != 0) {
        u_int caller_id = t-&gt;thread_join_caller;     
        // 找到join函数的调用线程   
        struct Thread * caller = &amp;curenv-&gt;env_threads[THREAD2INDEX(caller_id)];    
        if (caller-&gt;thread_retval_ptr != NULL) {     
            // 将自身的返回值&quot;告知&quot;join函数的调用者     
            *(caller-&gt;thread_retval_ptr) = t-&gt;thread_retval;    
        }
        caller-&gt;thread_status = THREAD_RUNNABLE;
    }  

    thread_destroy(t);  // 调用thread_destory函数来释放其他的内容
    return 0;
}
</code></pre>
</li>
<li>
<p><code>syscall_set_thread_status</code>：设置线程的运行状态，同时根据状态的改变将线程控制块加入或者移出调度队列。具体实现和<code>syscall_set_env_status</code>完全一样，照葫芦画瓢即可。</p>
<pre><code class="language-cpp">int sys_set_thread_status(int sysno, u_int threadid, u_int status) {
    int ret;
    struct Thread *t;

    if (status != THREAD_RUNNABLE &amp;&amp; status != THREAD_FREE &amp;&amp; status != THREAD_NOT_RUNNABLE) {
        return -E_INVAL;
    }

    ret = id2thread(threadid, &amp;t);
    if (ret &lt; 0) return ret;

    if (status == THREAD_RUNNABLE &amp;&amp; t-&gt;thread_status != THREAD_RUNNABLE) {
        LIST_INSERT_HEAD(&amp;thread_sched_list[0], t, thread_sched_link);
    }

    if (status != THREAD_RUNNABLE &amp;&amp; t-&gt;thread_status == THREAD_RUNNABLE) {
        LIST_REMOVE(t, thread_sched_link);
    }

    t-&gt;thread_status = status;
    return 0;
}
</code></pre>
</li>
<li>
<p><code>syscall_get_thread_id</code>：获取当前运行的线程的id，直接调用从<code>curthread</code>指向的线程控制块中找即可。</p>
<pre><code class="language-cpp">int sys_get_thread_id(int sysno) {

    return curthread-&gt;thread_id;

}
</code></pre>
</li>
</ul>
<h3 id="用户接口的实现">用户接口的实现</h3>
<p>编写好系统调用之后，我们就可以利用它们实现用户态的接口函数。</p>
<ul>
<li>
<p><strong>pthread_create</strong>：通过<code>syscall_thread_alloc</code>申请一个线程，然后对<code>pc</code>、<code>a0</code>、<code>sp</code>、<code>ra</code>等寄存器进行赋值，保证新创建的子线程能够正确的进入线程运行函数，并最终进入<code>exit</code>函数结束。</p>
<pre><code class="language-cpp">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                     void * (*start_rountine)(void *), void *arg) {
    u_int thread_id;
    struct Thread *t;
    
    thread_id = syscall_thread_alloc();
    if (thread_id &lt; 0) {
        *thread = NULL;
        return thread_id;
    }

    t = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];
    t-&gt;thread_tf.pc = start_rountine;   // 保证子线程能够进入线程运行函数
    t-&gt;thread_tf.regs[4] = arg;         // 传递参数
    t-&gt;thread_tf.regs[29] -= 4;         // 在栈上预留空间，符合MIPS函数调用的规范
    t-&gt;thread_tf.regs[31] = exit;       // 保证子线程退出线程运行函数后，能够进入exit函数释放进程控制块。


    syscall_set_thread_status(thread_id, THREAD_RUNNABLE);
    *thread = thread_id;
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>pthread_exit</strong>：调用这个函数会把线程本身中止，如果需要返回某个值，只需要将返回值作为参数传给该函数即可。这个函数首先获得当前运行的线程的线程控制块，然后把返回值复制给<code>thread_retval</code>，并标记上<code>THREAD_TAG_EXITED</code>，最后直接调用<code>exit</code>返回即可。当某个线程调用了join函数，而且join的目标时该进程，则它会从该线程的<code>thread_retval</code>中获得（在系统调用<code>sys_thread_destroy</code>中有这个机制）。</p>
<pre><code class="language-c++">void pthread_exit(void *retval) {
    u_int thread_id;
    struct Thread *cur;
    thread_id = syscall_get_thread_id();
    cur = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];
    
    cur-&gt;thread_retval = retval;
    cur-&gt;thread_tag |= THREAD_TAG_EXITED;
    exit();
}
</code></pre>
</li>
<li>
<p><strong>pthread_cancel</strong>：该函数可以将指定的线程撤销，不过还需要对目标线程的标志位进行检查。对于处于<code>FREE</code>状态的线程、处于分离状态的线程、已经被撤销过的线程、已经调用<code>pthread_exit</code>自杀的线程（自杀但是没来的及destroy），我们不能通过该函数取消它们。else里的内容才是正常情况下做出的操作——</p>
<ul>
<li>将目标线程标记为THREAD_TAG_CANCELED</li>
<li>将PTHREAD_CANCELED设置为返回值（笔者将其设置为666）</li>
<li>如果目标线程的撤销类型时THREAD_CANCEL_ASYNCHRONOUS，我们需要让目标线程在下一次被调度时直接进入exit函数。</li>
</ul>
<pre><code class="language-cpp">int pthread_cancel(pthread_t thread) {
    struct Thread *t;
    t = &amp;env-&gt;env_threads[THREAD2INDEX(thread)];

    if (t-&gt;thread_id != thread || t-&gt;thread_status == THREAD_FREE) {
        return -E_THREAD_NOT_FOUND;
    } 
    else if ((t-&gt;thread_tag &amp; THREAD_TAG_DETACHED) != 0) {
        return -E_THREAD_DETACHED;
    }
    else if ((t-&gt;thread_tag &amp; THREAD_TAG_CANCELED) != 0) {
        return -E_THREAD_CANCELED;
    }
    else if ((t-&gt;thread_tag &amp; THREAD_TAG_EXITED) != 0) {
        return -E_THREAD_EXITED;
    }
    else {
        t-&gt;thread_tag |= THREAD_TAG_CANCELED;       // 将目标线程标记为THREAD_TAG_CANCELED
        t-&gt;thread_retval = PTHREAD_CANCELED;        // 将PTHREAD_CANCELED设置为返回值
        if (t-&gt;thread_cancel_type == THREAD_CANCEL_ASYNCHRONOUS) {
            if (thread == syscall_get_thread_id()) {
                exit();
            }
            else t-&gt;thread_tf.pc = exit;            // 结束该进程 
        }
    }
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>pthread_join</strong>：调用该函数后，会将当前线程阻塞至目标线程结束。</p>
<ul>
<li>对于已经处于分离状态、或者已经被join的线程，我们无法对其调用join。</li>
<li>对于已经处于<code>FREE</code>状态、已经结束了的线程，我们不需要将join调用者阻塞，直接从目标线程的<code>thread_retval</code>中获取返回值即可。</li>
<li>对于其他线程，我们可以对其调用join，但是调用线程必须等待。注意<code>curthread-&gt;thread_retval_ptr = retval_ptr</code>这步比较关键——将指针<code>retval_ptr</code>赋值给调用者的<code>thread_retval_ptr</code>，当目标进程结束后，会直接将返回值写入<code>*(调用者-&gt;thread_retval_ptr)</code>，这和写入<code>*retval_ptr</code>是等价的（在<code>sys_thread_destroy</code>中有相关机制）。</li>
</ul>
<pre><code class="language-cpp">int pthread_join(pthread_t thread, void **retval_ptr) {
    struct Thread *dst;
    dst = &amp;env-&gt;env_threads[THREAD2INDEX(thread)];
    
    if (dst-&gt;thread_id != thread) {
        return -E_THREAD_NOT_FOUND;
    } 
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_DETACHED) != 0) {
        return -E_THREAD_DETACHED;
    }
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_JOINED) != 0) {
        return -E_THREAD_JOINED;
    }
    
    if (dst-&gt;thread_status == THREAD_FREE) {
        if (retval_ptr != NULL)
            *retval_ptr = dst-&gt;thread_retval;
        return 0;
    }

    dst-&gt;thread_tag |= THREAD_TAG_JOINED;               // 将目标线程标记上THREAD_TAG_JOINED
    dst-&gt;thread_join_caller = curthread-&gt;thread_id;     // 把调用者的id记录在目标线程的线程控制块中
    curthread-&gt;thread_retval_ptr = retval_ptr;          // 将传入的指针retval_ptr赋值给thread_retval_ptr
    curthread-&gt;thread_status = THREAD_NOT_RUNNABLE;     // 将当前线程阻塞
    syscall_yield();                                    // 切换线程
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>pthread_detach</strong>：将目标线程设置为分离状态，对于处于分离状态的线程，其他线程无法对其使用join、detach、cancel等函数。此外，我们不能对已经是<code>FREE</code>状态的、或者已经处于分离状态、或者已经被join的线程使用该函数。</p>
<pre><code class="language-cpp">int pthread_detach(pthread_t thread) {
    struct Thread *dst;
    dst = &amp;env-&gt;env_threads[THREAD2INDEX(thread)];

    if (dst-&gt;thread_id != thread  || dst-&gt;thread_status == THREAD_FREE) {
        return -E_THREAD_NOT_FOUND;
    } 
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_DETACHED) != 0) {
        return -E_THREAD_DETACHED;
    }
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_JOINED) != 0) {
        return -E_THREAD_JOINED;
    }

    dst-&gt;thread_tag |= THREAD_TAG_DETACHED;
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>pthread_setcanceltype</strong>：默认情况下，线程的cancel type都是<code>THREAD_CANCEL_DEFERRED</code>，而该函数修改进程的<code>cancel type</code>，并通过<code>oldtype</code>获得原值。</p>
<pre><code class="language-cpp">int pthread_setcanceltype(int type, int *oldtype) {
    u_int thread_id = syscall_get_thread_id();
    struct Thread *cur = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];

    if (oldtype) {
        *oldtype = cur-&gt;thread_cancel_type;
    }

    cur-&gt;thread_cancel_type = type;
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>pthread_teatcancel</strong>：对于<code>cancel type</code>是<code>THREAD_CANCEL_DEFERRED</code>的线程来说，被cancel函数作用后并不会立刻结束，而是到达某一个&quot;取消点&quot;才会结束自己。而这个函数可以帮助手动设置取消点，当某一个线程运行到该函数时，如果满足条件就直接进入exit函数退出。必须满足条件有两个——</p>
<ul>
<li>当前进程必须join函数作用过，即存在<code>THREAD_CANCEL_DEFERRED</code>标记。</li>
<li>当前进程的<code>cancel type</code>必须是<code>THREAD_CANCEL_DEFERRED</code>，即默认状态。</li>
</ul>
<pre><code class="language-cpp">
void pthread_testcancel(void) {
    u_int thread_id;
    struct Thread *cur;

    thread_id = syscall_get_thread_id();
    cur = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];
    if ((cur-&gt;thread_tag &amp; THREAD_TAG_CANCELED) != 0 &amp;&amp;
            cur-&gt;thread_cancel_type == THREAD_CANCEL_DEFERRED) {
        exit();
    }
}
</code></pre>
</li>
<li>
<p><strong>pthread_self</strong>：该函数可以让线程获得自己的id，只需要调用<code>syscall_get_thread_id</code>即可。</p>
<pre><code class="language-c++">pthread_t pthread_self() {

    return syscall_get_thread_id();

}
</code></pre>
</li>
</ul>
<h3 id="其他细节">其他细节</h3>
<h4 id="exit">exit</h4>
<p>所有正常或者非正常结束的线程最后都会进入<code>exit</code>函数，而这个函数也有很多细节需要注意。笔者改写的<code>exit</code>函数如下图所示</p>
<pre><code class="language-cpp">void
exit(void)
{
//	writef(&quot;enter exit!&quot;);
	//close_all();
	void *retval = get_retval();
	int thread_id = syscall_get_thread_id();
	struct Thread *cur_thread = &amp;env-&gt;env_threads[THREAD2INDEX(thread_id)];

    // THREAD2INDEX(thread_id)表示&quot;该线程是所属进程的第几号线程
	if (THREAD2INDEX(thread_id) == 0) { 
		cur_thread-&gt;thread_retval = 0;
		syscall_thread_destroy(0);
	}
	else if ((cur_thread-&gt;thread_tag &amp; THREAD_TAG_CANCELED) != 0) {
		syscall_thread_destroy(0);
	}
	else if ((cur_thread-&gt;thread_tag &amp; THREAD_TAG_EXITED) != 0)
	else {
		cur_thread-&gt;thread_retval = retval;
		syscall_thread_destroy(0);
	}
}
</code></pre>
<ul>
<li>对于0号线程，也就是主线程，它先执行<code>umain</code>函数然后再进入<code>exit</code>，由于<code>umain</code>函数是没有返回值的，因此我们需要手动将<code>0</code>作为主线程返回值。但是实际上，一般不会出现&quot;子线程获取主线程的返回值&quot;，所以这里可有可无。</li>
<li>对于标志位有<code>THREAD_TAG_CANCELED</code>或者<code>THREAD_TAG_EXITED</code>的子线程，这些线程都是通过exit或者cancel函数非正常结束的，而且在这两个函数中都已经把&quot;返回值&quot;赋值给<code>thread_retval</code>，所以在这里只需要调用<code>syscall_thread_destroy</code>释放线程资源即可。</li>
<li>对于正常结束的子线程，尽管是有返回值，但是由于执行完&quot;线程运行函数&quot;后直接跳转到了<code>exit</code>，&quot;线程运行函数&quot;的返回值我们无法直接获取。为此，笔者特地写了一个汇编函数<code>get_retval</code>来获得&quot;线程运行函数&quot;的返回值。<pre><code class="language-cpp">LEAF(get_retval)
    j	 ra
END(get_retval)
</code></pre>
我们把<code>get_retval</code>作为<code>exit</code>中运行的第一个函数，由于<code>get_retval</code>没有修改<code>v0寄</code>存器，因此它的返回值和&quot;线程运行函数&quot;的返回值一致。</li>
</ul>
<h4 id="pthread-join的线程安全">pthread_join的线程安全</h4>
<p>上面介绍的<code>pthread_join</code>函数的实现是在用户态中实现的，但是笔者在测试中发现，由于线程执行顺序的随机性会带来一些线程安全问题。</p>
<p>假设线程A调用join函数，并作用于线程B。</p>
<ul>
<li>当线程A执行<code>if (dst-&gt;thread_status == THREAD_FREE)</code>时，发现线程B并不是FREE状态，接着发生时钟中断，切换到了线程B。</li>
<li>线程B执行完并正常退出，状态变成了<code>FREE</code>，然后切换到了线程A。</li>
<li>线程A由于此前判断出&quot;线程B不是<code>FREE</code>状态&quot;，因此跳过了if，执行后续操作（被阻塞）。</li>
<li>线程A被阻塞了，但是线程B早就执行完<code>syscall_thread_destroy</code>恢复清白之身了，无法唤醒线程A</li>
</ul>
<p>为了解决这个问题，笔者将<code>pthread_join</code>函数中的操作封装成了系统调用——</p>
<pre><code class="language-cpp">int pthread_join(pthread_t thread, void **retval_ptr) {   

    return syscall_thread_join(thread, retval_ptr);

}

// 新增系统调用函数
int sys_thread_join(int sysno, u_int thread_id, void **retval_ptr) {
    struct Thread *dst;
    int ret = id2thread(thread_id, &amp;dst);
    if (ret &lt; 0) return ret; 

    if (dst-&gt;thread_id != thread_id) {
        return -E_THREAD_NOT_FOUND;
    } 
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_DETACHED) != 0) {
        return -E_THREAD_DETACHED;
    }
    else if ((dst-&gt;thread_tag &amp; THREAD_TAG_JOINED) != 0) {
        return -E_THREAD_JOINED;
    }

    if (dst-&gt;thread_status == THREAD_FREE) {
        if (retval_ptr != NULL)
            *retval_ptr = dst-&gt;thread_retval;
        return 0;
    }

    dst-&gt;thread_tag |= THREAD_TAG_JOINED;
    dst-&gt;thread_join_caller = curthread-&gt;thread_id;
    curthread-&gt;thread_retval_ptr = retval_ptr;
    curthread-&gt;thread_status = THREAD_NOT_RUNNABLE;

    struct Trapframe *tf = (struct Trapframe *)(KERNEL_SP - sizeof(struct Trapframe));
    tf-&gt;regs[2] = 0;    // 设置返回值为0
    sys_yield();
}
</code></pre>
<h2 id="信号量机制">信号量机制</h2>
<h3 id="数据结构-2">数据结构</h3>
<p>信号量机制的实现同样离不开一定的数据结构。笔者编写了<code>Semaphore</code>这一结构体，并将其作为信号量的类型(sem_t)。</p>
<pre><code class="language-cpp">struct Semaphore {
    u_int sem_perm;
    int sem_value;
    struct Thread* sem_wait_queue[32];
    u_int sem_queue_head;
    u_int sem_queue_tail;
};
</code></pre>
<ul>
<li><code>sem_perm</code>是信号量的标志位集合，同样采用了状态压缩的方式，<code>bit0</code>是信号量的&quot;有效位&quot;，<code>bit1</code>是信号量的&quot;共享位&quot;。<pre><code class="language-cpp">#define SEM_PERM_VALID          1
#define SEM_PERM_SHARE          2
</code></pre>
</li>
<li><code>sem_value</code>是信号量的当前值。</li>
<li><code>sem_wait_queue</code>是存储被阻塞线程的环形队列，因为进程最多只能同时运行32个线程，因此唤醒队列的长度也是32</li>
<li><code>sem_queue_head</code>是环形队列的队首下标</li>
<li><code>sem_queue_tail</code>是环形队列的队尾下标</li>
</ul>
<h3 id="用户接口函数的实现">用户接口函数的实现</h3>
<p>信号量的使用是为了解决线程高并发带来的同步互斥问题，因此信号量本身的各种操作也必须是原子的。为了保证原子性，笔者为每一个用户接口函数设置了对应的系统调用函数。</p>
<pre><code class="language-cpp">int sem_init (sem_t *sem, int pshared, unsigned int value) {
    return syscall_sem_init(sem, pshared, value);
}

int sem_destroy (sem_t *sem) {
    return syscall_sem_destroy(sem);
}

int sem_wait (sem_t *sem) {
    return syscall_sem_wait(sem);
}

int sem_trywait(sem_t *sem) {
    return syscall_sem_trywait(sem);
}

int sem_post (sem_t *sem) {
    return syscall_sem_post(sem);
}

int sem_getvalue (sem_t *sem, int *valp) {
    return syscall_sem_getvalue(sem, valp);
}
</code></pre>
<p>各个系统调用的实现如下——</p>
<ul>
<li>
<p><strong>sys_sem_init</strong>：这个函数主要是对信号量进行初始化，需要将参数赋值给<code>sem_value</code>，设置标志位，并将其他数据成员的值设为0。</p>
<pre><code class="language-cpp">int sys_sem_init (int sysno, sem_t *sem, int pshared, unsigned int value) {
    if (sem == NULL) {
        return -E_SEM_NOT_FOUND;
    }

    sem-&gt;sem_value = value;
    sem-&gt;sem_queue_head = 0; 
    sem-&gt;sem_queue_tail = 0;
    sem-&gt;sem_perm |= SEM_PERM_VALID;

    if (pshared) {
        sem-&gt;sem_perm |= SEM_PERM_SHARE;
    }

    int i;
    for (i = 0; i &lt; 32; i++) {
        sem-&gt;sem_wait_queue[i] = NULL;
    }
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>sys_sem_destroy</strong>：该函数需要销毁信号量，只需要将信号量的<code>VALID</code>标志位设置位0即可。但是需要注意的是，如果目前还有阻塞在信号量上的线程，则信号量无法被销毁。</p>
<pre><code class="language-cpp">int sys_sem_destroy (int sysno, sem_t *sem) {
    if ((sem-&gt;sem_perm &amp; SEM_PERM_VALID) == 0) {    // 无法销毁无效的信号量
        return -E_SEM_INVALID;
    }
    if (sem-&gt;sem_queue_head != sem-&gt;sem_queue_tail) {
        return -E_SEM_DESTROY_FAIL;         
    }
    sem-&gt;sem_perm &amp;= ~SEM_PERM_VALID;
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>sys_sem_wait</strong>：调用该函数后，<code>sem_value</code>会自减。如果自减之后<code>sem_value</code>的值小于0，则会将调用者加入信号量的阻塞队列中，并将该线程状态设置为<code>THREAD_NOT_RUNNABLE</code>，实现阻塞。</p>
<pre><code class="language-cpp">int sys_sem_wait (int sysno, sem_t *sem) {
    if ((sem-&gt;sem_perm &amp; SEM_PERM_VALID) == 0) {
        return -E_SEM_INVALID;
    }
    
    sem-&gt;sem_value--;
    if (sem-&gt;sem_value &gt;= 0) {
        return 0;
    }

    // if sem_value &lt; 0 
    if (sem-&gt;sem_value &lt; -32) {
        return -E_SEM_WAIT_MAX;
    }

    // must wait
    sem-&gt;sem_wait_queue[sem-&gt;sem_queue_tail] = curthread;
    sem-&gt;sem_queue_tail = (sem-&gt;sem_queue_tail + 1)	% 32;

    curthread-&gt;thread_status = THREAD_NOT_RUNNABLE;     //阻塞线程
    
    struct Trapframe *tf = 
        (struct Trapframe *)(KERNEL_SP - sizeof(struct Trapframe));
    tf-&gt;regs[2] = 0;        // 将返回值设置为0
    sys_yield();
}
</code></pre>
</li>
<li>
<p><strong>sys_sem_trywait</strong>：调用该函数后，<code>sem_value</code>会自减。如果自减之后<code>sem_value</code>的值小于0，则会返回错误码，不会对调用者产生任何阻塞效果。</p>
<pre><code class="language-cpp">int sys_sem_trywait(int sysno, sem_t *sem) {
    if ((sem-&gt;sem_perm &amp; SEM_PERM_VALID) == 0) {
        return -E_SEM_INVALID;
    }
    
    sem-&gt;sem_value--;
    if (sem-&gt;sem_value &gt;= 0) {
        return 0;
    }
    return -E_SEM_TRYWAIT_FAIL;
}
</code></pre>
</li>
<li>
<p><strong>sys_sem_post</strong>：调用该函数后，<code>sem_value</code>会自增。如果自增之后<code>sem_value</code>的值是小于等于0，则说明当前有阻塞在该信号量上的线程，我们需要从队首获得一个线程并将其唤醒。</p>
<pre><code class="language-cpp">int sys_sem_post (int sysno, sem_t *sem) {
    struct Thread *t;

    if ((sem-&gt;sem_perm &amp; SEM_PERM_VALID) == 0) {
        return -E_SEM_INVALID;
    }
    
    sem-&gt;sem_value++; 
    if (sem-&gt;sem_value &lt;= 0) {
        t = sem-&gt;sem_wait_queue[sem-&gt;sem_queue_head];
        sem-&gt;sem_queue_head = (sem-&gt;sem_queue_head + 1) % 32;
        t-&gt;thread_status = THREAD_RUNNABLE;  // 唤醒线程
    }
    return 0;
}
</code></pre>
</li>
<li>
<p><strong>sys_sem_getvalue</strong>：该函数可以返回目标信号量的当前值，直接返回<code>sem_value</code>即可。对于没有被初始化的信号量，也就是<code>VALID</code>位是0的信号量，直接返回错误码</p>
<pre><code class="language-cpp">int sys_sem_getvalue (int sysno, sem_t *sem, int *valp) {
    if ((sem-&gt;sem_perm &amp; SEM_PERM_VALID) == 0) {
        return -E_SEM_INVALID;
    }
    if (valp) {
        *valp = sem-&gt;sem_value;
    }
    return 0;
}
</code></pre>
</li>
</ul>
<h2 id="关于测试">关于测试</h2>
<h3 id="线程创建、等待、返回值测试">线程创建、等待、返回值测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;

void *print_message_function( void *ptr )
{
    int id = pthread_self();
    writef(&quot;\033[0;32;40m thread %d received : '%s' \033[0m\n&quot;, id, (char *)ptr);

    if (id == t1) return 1;
    else return 2;
}

umain()
{
    char *message1 = &quot;I love BUAA!&quot;;
    char *message2 = &quot;I love CS!&quot;;
    int  ret1, ret2;

    pthread_create( &amp;t1, NULL, print_message_function, (void*) message1);
    pthread_create( &amp;t2, NULL, print_message_function, (void*) message2);

    pthread_join( t1, &amp;ret1);
    pthread_join( t2, &amp;ret2); 

    writef(&quot;\033[0;32;40m thread %d returns: %d \033[0m\n&quot;, t1, ret1);
    writef(&quot;\033[0;32;40m thread %d returns: %d \033[0m\n&quot;, t2, ret2);
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0.jpg" alt=""></p>
<h3 id="pthread-exit测试">pthread_exit测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;

void *print_message_function( void *ptr )
{
    int id = pthread_self();
    printf(&quot;\033[0;32;40m thread %d received : '%s' \033[0m\n&quot;, id, (char *)ptr);

    printf(&quot;\033[0;34;40m before `pthread_exit` ...\033[0m\n&quot;, id);
    if (id == t1) pthread_exit(3);
    else pthread_exit(4);
    printf(&quot;\033[0;34;40m after `pthread_exit` ...\033[0m\n&quot;);

    if (id == t1) return 1;
    else return 2;
}

umain()
{
    char *message1 = &quot;I love BUAA!&quot;;
    char *message2 = &quot;I love CS!&quot;;
    int  ret1, ret2;

    pthread_create( &amp;t1, NULL, print_message_function, (void*) message1);
    pthread_create( &amp;t2, NULL, print_message_function, (void*) message2);

    pthread_join( t1, &amp;ret1);
    pthread_join( t2, &amp;ret2); 
    
    printf(&quot;\033[0;32;40m thread %d returns: %d \033[0m\n&quot;, t1, ret1);
    printf(&quot;\033[0;32;40m thread %d returns: %d \033[0m\n&quot;, t2, ret2);
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="exit%E6%B5%8B%E8%AF%95.jpg" alt=""></p>
<h3 id="cancel测试">cancel测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;
pthread_t t3;

void *fun1(void *arg) {
    int i;
    for (i = 0; i &lt; 1000000; i++) {
        if (i == 499999 &amp;&amp; *((int *)arg) == 12345) {
                pthread_cancel(t3);
        }
    }
}

char *str = &quot;hello!&quot;;
void *fun2(void *arg) {
    pthread_exit(str);
}

void umain()
{
    
    int a1 = 12345;
    int a2 = 10088;
    int a3 = 3381;
    pthread_create(&amp;t1, NULL, fun1, &amp;a1);
    pthread_create(&amp;t2, NULL, fun2, &amp;a2);
    pthread_create(&amp;t3, NULL, fun1, &amp;a3);
    void *temp_1;
    void *temp_2;
    void *temp_3;
    pthread_join(t1, &amp;temp_1);
    writef(&quot;\033[0;32;40mthread 1 is finished!\033[0m\n&quot;);
    pthread_join(t2, &amp;temp_2);
    writef(&quot;\033[0;32;40mthread 2 return the ptr of: %s\033[0m\n&quot;, (char *)temp_2);
    pthread_join(t3, &amp;temp_3);
    if (temp_3 == PTHREAD_CANCELED) {
            writef(&quot;\033[0;32;40mthread 3 was canceled successfully!\033[0m\n&quot;);
    } else {
            writef(&quot;\033[0;31;40mthread 3 return with wrong value!\033[0m\n&quot;);
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="%E6%B5%8B%E8%AF%95cancel.jpg" alt=""></p>
<h3 id="cancel返回值测试">cancel返回值测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;

void *fun1(void *arg) {
    printf(&quot;\033[0;34;40mreciving '%s'\033[0m\n&quot;, (char *)arg);
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf(&quot;\033[0;34;40m %d \033[0m\n&quot;, i);
    }
    printf(&quot;\033[0;34;40m fun1 end !!!\033[0m\n&quot;);
}

void umain()
{
    char *str = &quot;hello!&quot;;
    int ret = 0;

    pthread_create(&amp;t1, NULL, fun1, str);
    pthread_cancel(t1);
    pthread_join(t1, &amp;ret);

    writef(&quot;\033[0;34;40m t1 return the value of: %d\033[0m\n&quot;, ret);

    if (ret == PTHREAD_CANCELED) {
        writef(&quot;\033[0;32;40m t1 was canceled successfully!\033[0m\n&quot;);
    } else {
        writef(&quot;\033[0;31;40m t1 return with wrong value!\033[0m\n&quot;);
    }
}

</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="cancel%E8%BF%94%E5%9B%9E%E5%80%BC%E6%B5%8B%E8%AF%95.jpg" alt=""></p>
<h3 id="cancel-point测试">cancel point测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;

void *fun1(void *arg) {
    printf(&quot;\033[0;34;40mreciving '%s'\033[0m\n&quot;, (char *)arg);
    int i;
    for (i = 0; i &lt; 10; i++) {
        if (i == 5) {
            pthread_testcancel();
        }
        printf(&quot;\033[0;34;40m %d \033[0m\n&quot;, i);
    }
    printf(&quot;\033[0;34;40m fun1 end !!!\033[0m\n&quot;);
}

void umain()
{
    char *str = &quot;hello!&quot;;
    int ret1 = 0;
    int ret2 = 0;

    pthread_create(&amp;t1, NULL, fun1, str);
    pthread_create(&amp;t2, NULL, fun1, str);

    pthread_cancel(t1);
    pthread_cancel(t2);

    pthread_join(t1, &amp;ret1);
    pthread_join(t2, &amp;ret2);

    writef(&quot;\033[0;34;40m t1 return the value of: %d\033[0m\n&quot;, ret1);
    writef(&quot;\033[0;34;40m t2 return the value of: %d\033[0m\n&quot;, ret2);

    if (ret1 == PTHREAD_CANCELED) {
        writef(&quot;\033[0;32;40m t1 was canceled successfully!\033[0m\n&quot;);
    } else {
        writef(&quot;\033[0;31;40m t1 return with wrong value!\033[0m\n&quot;);
    }

    if (ret2 == PTHREAD_CANCELED) {
        writef(&quot;\033[0;32;40m t2 was canceled successfully!\033[0m\n&quot;);
    } else {
        writef(&quot;\033[0;31;40m t2 return with wrong value!\033[0m\n&quot;);
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="cancel%20point%20%E6%B5%8B%E8%AF%95.jpg" alt=""></p>
<h3 id="asynchronous-cancel测试-1">asynchronous cancel测试 1</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;

void *fun1(void *arg) {
    printf(&quot;\033[0;34;40mreciving '%s'\033[0m\n&quot;, (char *)arg);
        int oldtype;
        pthread_setcanceltype(THREAD_CANCEL_ASYNCHRONOUS, &amp;oldtype);
        printf(&quot;\033[0;32;40mthread %d old_cancel_ype is '%d', new_cancel_type is '%d'\033[0m\n&quot;, 
                    pthread_self(), oldtype, THREAD_CANCEL_ASYNCHRONOUS);

    int i;
    for (i = 0; i &lt; 10; i++) {
        if (i == 5) {
            pthread_cancel(pthread_self());
        }
        printf(&quot;\033[0;34;40m %d \033[0m\n&quot;, i);
    }
    printf(&quot;\033[0;34;40m fun1 end !!!\033[0m\n&quot;);
}

void umain()
{
    char *str = &quot;hello!&quot;;
    int ret1 = 0;
    int ret2 = 0;

    pthread_create(&amp;t1, NULL, fun1, str);
    pthread_create(&amp;t2, NULL, fun1, str);

    pthread_join(t1, &amp;ret1);
    pthread_join(t2, &amp;ret2);

    writef(&quot;\033[0;34;40m t1 return the value of: %d\033[0m\n&quot;, ret1);
    writef(&quot;\033[0;34;40m t2 return the value of: %d\033[0m\n&quot;, ret2);

    if (ret1 == PTHREAD_CANCELED) {
        writef(&quot;\033[0;32;40m t1 was canceled successfully!\033[0m\n&quot;);
    } else {
        writef(&quot;\033[0;31;40m t1 return with wrong value!\033[0m\n&quot;);
    }

    if (ret2 == PTHREAD_CANCELED) {
        writef(&quot;\033[0;32;40m t2 was canceled successfully!\033[0m\n&quot;);
    } else {
        writef(&quot;\033[0;31;40m t2 return with wrong value!\033[0m\n&quot;);
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="asys%20cancel%E6%B5%8B%E8%AF%951.jpg" alt=""></p>
<h3 id="asynchronous-cancel测试-2">asynchronous cancel测试 2</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;

void *fun1(void *arg) {
    printf(&quot;\033[0;34;40mthread %d reciving '%s'\033[0m\n&quot;, pthread_self(), (char *)arg);

    pthread_setcanceltype(THREAD_CANCEL_ASYNCHRONOUS, NULL);
    pthread_join(t2, NULL);
    
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf(&quot;\033[0;34;40m %d \033[0m\n&quot;, i);
    }
    printf(&quot;\033[0;34;40m fun1 end !!!\033[0m\n&quot;);
    return 1;
}

void *fun2(void *arg) {
    printf(&quot;\033[0;34;40mthread %d reciving '%s'\033[0m\n&quot;, pthread_self(), (char *)arg);
    syscall_yield();    
    pthread_cancel(t1);
    return 2;
}

void umain()
{
    char *str = &quot;hello!&quot;;
    int ret1 = 0;
    int ret2 = 0;

    pthread_create(&amp;t1, NULL, fun1, str);
    pthread_create(&amp;t2, NULL, fun2, str);

    pthread_join(t1, &amp;ret1);
    pthread_join(t2, &amp;ret2);

    writef(&quot;\033[0;34;40m t1 return the value of: %d\033[0m\n&quot;, ret1);
    writef(&quot;\033[0;34;40m t2 return the value of: %d\033[0m\n&quot;, ret2);
}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="asys%20cancel%E6%B5%8B%E8%AF%952.jpg" alt=""></p>
<h3 id="测试">测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">
</code></pre>
<p><strong>测试结果</strong></p>
<p>![]</p>
<h3 id="信号量创建、取值、销毁测试">信号量创建、取值、销毁测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1;
pthread_t t2;
pthread_t t3;

sem_t s1;

void *func(void *arg) {
    int i = 0;
    int ret = 0;
    int value = 0;
    for (i = 0; i &lt; 5; i++) {
    ret = sem_trywait(&amp;s1);
            sem_getvalue(&amp;s1, &amp;value);
    printf(&quot;\033[0;32;40m thread %d call the `sem_trywait`, retval is %d, s1's value is %d\033[0m\n&quot;, 
                pthread_self(), ret, value);
    }
    return 1;
}


void umain()
{
    int msg = &quot;hello, world&quot;;
    int value = 0;
    
    sem_init(&amp;s1, 0, 5);
    printf(&quot;\033[0;34;40m after init, s1 perm is %d\033[0m\n&quot;, s1.sem_perm);
    if (s1.sem_perm == SEM_PERM_VALID) 
    printf(&quot;
    
    \033[0;34;40m s1 is valid! \033[0m\n&quot;);
    
    sem_getvalue(&amp;s1, &amp;value);
    printf(&quot;\033[0;34;40m s1 value is %d\033[0m\n&quot;, s1.sem_value);


    pthread_create(&amp;t1, NULL, func, msg);
    pthread_create(&amp;t2, NULL, func, msg);


    // wait for t1
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    sem_destroy(&amp;s1);
    printf(&quot;\033[0;34;40m s1 after destroy, perm is %d\033[0m\n&quot;, s1.sem_perm);
    if (s1.sem_perm != SEM_PERM_VALID) 
    printf(&quot;\033[0;34;40m s1 is invalid! \033[0m\n&quot;);

}
</code></pre>
<p><strong>测试结果</strong></p>
<p><img src="sem%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95.jpg" alt=""></p>
<h3 id="生产者消费者模型测试">生产者消费者模型测试</h3>
<p><strong>测试例程</strong></p>
<pre><code class="language-cpp">#include &quot;lib.h&quot;

pthread_t t1, t2;
sem_t mutex, empty, full;
int max = 1;
int count = 0;

void *prodecer(void *arg) {
    int i;
    for(i = 0; i &lt; 100; i++) {
        sem_wait(&amp;empty);
        sem_wait(&amp;mutex);
        count++;
        printf(&quot;\033[0;32;40m produce successfully, no count is %d \033[0m\n&quot;, count);
        sem_post(&amp;mutex);
        sem_post(&amp;full);
    }
}

void *consumer(void *arg) {
    int i;
    for(i = 0; i &lt; 100; i++) {
        sem_wait(&amp;full);
        sem_wait(&amp;mutex);
        count--;
        printf(&quot;\033[0;31;40m consume successfully, no count is %d \033[0m\n&quot;, count);
        sem_post(&amp;mutex);
        sem_post(&amp;empty);
    }
}

void umain()
{   
    sem_init(&amp;mutex, 0, 1);
    sem_init(&amp;empty, 0, max);
    sem_init(&amp;full, 0, 0);
    
    pthread_create(&amp;t1, NULL, prodecer, NULL);
    pthread_create(&amp;t2, NULL, consumer, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
}

</code></pre>
<p><strong>测试结果</strong><br>
<img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.jpg" alt=""></p>
